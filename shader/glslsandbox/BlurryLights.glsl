{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n// Created by Martijn Steinrucken - 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// \nconst vec3 worldUp = vec3(0.,1.,0.);\n\nconst float pi = 3.141592653589793238;\nconst float twopi = 6.283185307179586;\n\nconst float NUM_SURFACE_BOKEH = 150.;\t// number of twinkly lights on the surface\nconst float NUM_LIGHTS = 100.;\t\t\t// number of twinkly lights falling down\nconst float _FocalDistance = 2.;\t// focal distance of the camera\nconst float _DOF = 2.;\t\t\t\t// depth of field. How quickly lights go out of focus\nconst float _ZOOM = 01.;\t\t// camera zoom, smaller values means wider FOV\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\nray e;\t\t\t\t// the eye ray\n\nstruct camera {\n    vec3 p;\t\t\t// the position of the camera\n    vec3 forward;\t// the camera forward vector\n    vec3 left;\t\t// the camera left vector\n    vec3 up;\t\t// the camera up vector\n\n    vec3 lookAt;\t// the lookat point\n    float zoom;\t\t// the zoom factor\n};\ncamera cam;\n\n// Helper functions - Borrowed from other peoples shaders =================================\n\nfloat hash( float n )\n{\n    return fract(sin(n)*1751.5453);\n}\n\nvec2 hash2(float n) {\n\tvec2 n2 = vec2(n, -n+2.1323);\n    return fract(sin(n2)*1751.5453);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.;\n    x /= w;\n    return 1. - x*x*(3.-2.*x);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat PeriodicPulse(float x, float p) {\n    // pulses from 0 to 1 with a period of 2 pi\n    // increasing p makes the pulse sharper\n\treturn pow((cos(x+sin(x))+1.)/2., p);\n}\n\n\nfloat BandStep(float ss, float se, float es, float ee, float t) {\n    return smoothstep(ss, se, t)*smoothstep(ee, es, t);\n}\n\nvec3 ClosestPoint(ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(1., dot(p-r.o, r.d))*r.d;\n}\n\n// ================================================================\n\n\n\nvec3 Light(ray r, vec3 p) {\n\t// renders a pointlight at position p\n    float dist = length( ClosestPoint(r, p)-p*5. );\n    \n    float lightIntensity = smoothstep(0.1, 0.8, dist);\n    \n    return lightIntensity*vec3(1.);\n}\n\nfloat Bokeh(ray r, vec3 p) {\n\tfloat dist = length( p-ClosestPoint(r, p) );\n    \n    float distFromCam = length(p-e.o);\n    float focus = cubicPulse(_FocalDistance, _DOF, distFromCam);\n    \n    vec3 inFocus = vec3(0.5, -0.1, 1.);\t// outer radius = 0.05, inner radius=0 brightness =1\n    vec3 outFocus = vec3(0.25, 0.2, .05);\t// out of focus is larger, has sharper edge, is less bright\n    \n    vec3 thisFocus = mix(outFocus, inFocus, focus);\n    \n\t//thisFocus *= vec3(hash(p.x*0.01));\n\t\n    return smoothstep(thisFocus.x, thisFocus.y, dist*0.37)*thisFocus.z;\n}\n\n\nvec3 Lights(ray r, float t) {\n\t\n    vec3 col = vec3(0.);\n    \n    float height = 1.;\n   \tfloat halfHeight = height/2.;\n   \n    for(float i=0.; i<NUM_LIGHTS; i++) {\n    \tfloat c = i/NUM_LIGHTS;\n        c *= twopi;\n        \n        vec2 xy = hash2(i)*10.-5.;\n        \n        float y = fract(c-t)*height-halfHeight;\n        \n        vec3 pos = vec3(xy.x, y, xy.y);\n        \n        float glitter = 1. +clamp((sin(c+t*30.)-0.9)*50., 0., 100.);\n       \n        float verticalFade = BandStep(halfHeight, halfHeight*0.8, -halfHeight*0.8, -halfHeight, y);\n        col += Bokeh(r, pos)*verticalFade*glitter *mix( vec3(0.94,0.3,0.0), vec3(0.0,0.4,0.9), 0.5+0.5*sin(float(i)*1.2+1.9));\n    }\n    return col;\n}\n\n\nvoid main( void ) {\n\tvec2 uv = (gl_FragCoord.xy / resolution.xy) - 0.5;\n   \tuv.y *= resolution.y/resolution.x;\n\tfloat t = time;\n    \n    float speed = 0.0;\n    \n    float st = sin(t*speed);\n    float ct = cos(t*speed);\n    \n    cam.p = vec3(st, st, ct)*vec3(4., 3.5, 4.);\n    cam.p = normalize(cam.p);// NOTE this won't work if the lookat isn't at the origin\n     \n    cam.lookAt = vec3(0., 0., 0.);\n    cam.forward = normalize(cam.lookAt-cam.p);\n    cam.left = cross(worldUp, cam.forward);\n    cam.up = cross(cam.forward, cam.left);\n    cam.zoom = _ZOOM;\n    \n    vec3 screenCenter = cam.p+cam.forward*cam.zoom;\n    vec3 screenPoint = screenCenter+cam.left*uv.x+cam.up*uv.y;\n    \n    e.o = cam.p;\t\t\t\t\t\t// ray origin = camera position\n    e.d = normalize(screenPoint-cam.p);\t// ray direction is the vector from the cam pos through the point on the imaginary screen\n   \n    vec3 col = vec3(0.);\n    \n\tcol += Lights(e, t*0.1);\t\t\t\t\t\t\t// lights falling down\n  \n\tgl_FragColor = vec4(col.r, col.g, col.b, 1.);\n}", "user": "997d9b8", "parent": null, "id": "27178.0"}