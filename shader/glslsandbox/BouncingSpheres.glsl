{"code": "// BouncingSpheres   (c) 2012 Piers Haken\n// \n// https://github.com/fxlex/ProcessingGLSL/blob/master/ProcessingGLSL/src/data/glslsandbox/bouncingspheres.glsl\n\n// (c) 2012 Piers Haken\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// uniforms\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// consts\nconst float PI = 3.1415926535897932384626433832795;\nconst vec3 UP = vec3 (0,0,1);\nconst vec3 Z3 = vec3(0,0,0);\nconst vec3 U3 = vec3(1,1,1);\n\nconst float INFINITY = 1.0/0.0;\n\n// camera\nconst vec3 at = UP;///2.0;\nconst float fov = PI / 2.0;\nfloat tanfov = tan(fov/1.8);\n\n// structs\nstruct Camera\n{\n\tvec3 Position;\n\tvec3 Side;\n\tvec3 Up;\n\tvec3 View;\n\tvec2 Scale;\n};\n\nstruct Ray\n{\n\tvec3 Position;\n\tvec3 Direction;\n};\n\nstruct Sphere\n{\n\tvec3 Center;\n\tfloat Radius;\n};\n\nstruct Plane\n{\n\tvec3 Point;\n\tvec3 Normal;\n};\n\nstruct PointLight\n{\n\tvec3 Position;\n\tvec3 DiffuseColor;\n\tfloat DiffusePower;\n\tvec3 SpecularColor;\n\tfloat SpecularPower;\n};\n\nstruct Material\n{\n\tvec3 DiffuseColor;\n\tvec3 SpecularColor;\n\tfloat Shininess;\n};\n\nstruct Ball\n{\n\tSphere Sphere;\n\tMaterial Material;\n\tvec3 Velocity;\n};\n\n\nstruct Bounce\n{\n\tRay Normal;\n\tMaterial Material;\n};\n\n\nconst Material _matFloor = Material (vec3(1,.9,.7), vec3(1,1,1), 130.0);\nconst Plane _floor = Plane (vec3(0,0,0), vec3(0,0,1));\n\nconst int _cLights = 3;\nPointLight _rgLights[_cLights];\n\nconst int _cBalls = 7;\nBall _rgBalls[_cBalls];\n\n\nvec2 Circle (const float time)\n{\n\treturn vec2 (cos(time), sin(time));\n}\n\n\nfloat IntersectSphere (const Ray ray, const Sphere sphere, inout Ray normal)\n{\n\tvec3 L = sphere.Center - ray.Position;\n\tfloat Tca = max (0.0, dot (L, ray.Direction));\n\tif (Tca < 0.0)\n\t\treturn INFINITY;\n\n\tfloat d2 = dot (L, L) - Tca * Tca;\n\tfloat p2 = sphere.Radius * sphere.Radius - d2;\n\tif (p2 < 0.0)\n\t\treturn INFINITY;\n\n\tfloat t = Tca - sqrt (p2);\n\tvec3 intersect = ray.Position + t * ray.Direction;\n\tnormal = Ray (intersect, (intersect - sphere.Center) / sphere.Radius);\n\treturn t;\n}\n\nfloat IntersectPlane (const Ray ray, const Plane plane, inout Ray normal)\n{\n\tfloat t = dot (plane.Point - ray.Position, plane.Normal) / dot (ray.Direction, plane.Normal);\n\tnormal = Ray (ray.Position + t * ray.Direction, plane.Normal);\n\treturn t;\n}\n\nvec3 Phong (PointLight light, Material material, Ray normal, vec3 eye)\n{\n\tvec3 viewDir = normalize (normal.Position - eye);\n\tvec3 lightVec = light.Position - normal.Position;\n\tfloat lightDistance2 = dot (lightVec, lightVec);\n\tvec3 lightDir = lightVec / sqrt (lightDistance2);\n\tfloat diffuse = dot(normal.Direction, lightDir);\n\n\tvec3 R = lightDir - 2.0 * diffuse * normal.Direction;\n\tfloat specular = pow(max(0.0, dot(R, viewDir)), material.Shininess);\n\n\tvec3 color =\n\t\tmax (0.0, diffuse) * light.DiffuseColor * light.DiffusePower * material.DiffuseColor +\n\t\tmax (0.0, specular) * light.SpecularColor * light.SpecularPower * material.SpecularColor;\n\n\treturn color * 110.0 / lightDistance2;\n}\n\nbool Scene (const Ray ray, out Bounce bounce)\n{\n\tfloat tMatch = INFINITY;\n\tRay normalMatch;\n\tfor (int i = 0; i < _cBalls; ++i)\n\t{\n\t\tRay normal;\n\t\tfloat t = max(0.0, IntersectSphere (ray, _rgBalls[i].Sphere, normal));\n\t\tif (t > 0.0 && tMatch > t)\n\t\t{\n\t\t\ttMatch = t;\n\t\t\tbounce = Bounce (normal, _rgBalls[i].Material);\n\t\t}\n\t}\n\n\tRay normalPlane;\n\tfloat t2 = IntersectPlane (ray, _floor, normalPlane);\n\tif (t2 > 0.0 && t2 < tMatch)\n\t{\n\t\tvec3 pt = normalPlane.Position;\n\t\tif (length(pt) < 10.0 && (fract(pt.x) < 0.9 == fract(pt.y) < 0.9))\n\t\t{\n\t\t\ttMatch = t2;\n\t\t\tbounce = Bounce (normalPlane, _matFloor);\n\t\t}\n\t}\n\n\treturn tMatch < 1000.0 && tMatch > 0.0;\n}\n\nbool LightScene (inout Ray ray, inout vec3 color)\n{\n\tBounce bounce;\n\tif (!Scene (ray, bounce))\n\t\treturn false;\n\n\tvec3 bouncePos = bounce.Normal.Position + bounce.Normal.Direction * .0001;\n\n\tBounce bounceShadow;\n\n\tfor (int iLight = 0; iLight < _cLights; ++iLight)\n\t{\n\t\tif (!Scene (Ray (bouncePos, normalize (_rgLights[iLight].Position - bouncePos)), bounceShadow))\n\t\t\tcolor += Phong (_rgLights[iLight], bounce.Material, bounce.Normal, ray.Position);\n\t}\n\n\tray = Ray (bouncePos, reflect (ray.Direction, bounce.Normal.Direction));\n\treturn true;\t\n}\n\nconst Sphere s = Sphere (Z3, .5);\n\nvoid main( void )\n{\n\tfloat time2 = time / 10.0 + 100.0;\n\n\tvec3 eye = vec3(Circle(time / 10.0) * (7.1 - 4.5 * mouse.y), 4.5 * mouse.y);\n\tvec3 look = normalize (at - eye);\n\n\tvec3 u = cross (look, UP);\n\tvec3 v = cross (u, look);\n\n\tvec3 dx = tanfov * u;\n\tvec3 dy = tanfov * v;\n\n\tvec2 position = (gl_FragCoord.xy - resolution/2.0) / min(resolution.x, resolution.y);\n\tRay ray = Ray (eye, normalize (look + dx * position.x + dy * position.y));\n\n\t_rgBalls[0] = Ball(s, Material (vec3(1,0,0), U3, 100.0), vec3(1.17, 1.9, 3.03));\n\t_rgBalls[1] = Ball(s, Material (vec3(0,1,0), U3, 100.0), vec3(1.23, 1.8, 1.79));\n\t_rgBalls[2] = Ball(s, Material (vec3(0,0,1), U3, 100.0), vec3(1.35, 1.7, 2.73));\n\n\t_rgBalls[3] = Ball(s, Material (vec3(0,1,1), U3, 100.0), vec3(1.41, 1.6, 2.53));\n\t_rgBalls[4] = Ball(s, Material (vec3(1,0,1), U3, 100.0), vec3(1.50, 1.5, 2.23));\n\t_rgBalls[5] = Ball(s, Material (vec3(1,1,0), U3, 100.0), vec3(1.69, 1.4, 1.93));\n\n\t_rgBalls[6] = Ball(s, Material (vec3(0,0,0), U3, 100.0), vec3(1.39, 1.19, 1.93));\n\t//_rgBalls[7] = Ball(s, Material (vec3(1,1,1), U3, 100.0), vec3(1.73, 1.01, 1.93));\n\n\tfor (int i = 0; i < _cBalls; ++i)\n\t{\n\t\tfloat q = fract(time2 * _rgBalls[i].Velocity.z / 3.0) - 0.5;\n\n\t\t_rgBalls[i].Sphere.Center = vec3 (\n\t\t\tabs(mod(time2 * _rgBalls[i].Velocity.xy, 8.0) - 4.0) - 2.0,\n\t\t\t_rgBalls[i].Sphere.Radius + 8.0 * (0.25-q*q));\n\t}\n\n\n\t_rgLights [0] = PointLight (4.0*vec3(1,0.,2), vec3(.5,1,.5), .3, vec3(.5,1,.5), 1.0);\n\t_rgLights [1] = PointLight (4.0*vec3(-1,-0.86,2), vec3(1,.5,.5), .3, vec3(1,.5,.5), 1.0);\n\t_rgLights [2] = PointLight (4.0*vec3(-1,0.86,2), vec3(.5,.5,1), .3, vec3(.5,.5,1), 1.0);\n\n\n\tvec3 color = vec3(0,0,0);\n\n\tLightScene (ray, color) &&\n\t\tLightScene (ray, color) &&\n\t\tLightScene (ray, color);\n\n\tgl_FragColor = vec4 (color, 1.0);\n}", "user": "4cec750", "parent": null, "id": "26493.0"}