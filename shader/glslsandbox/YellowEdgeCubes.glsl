{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nbool notEmpty(ivec3 p)\n{\n\treturn false;\n}\n\n// return location of first non-empty block\n// marching accomplished with fb39ca4's non-branching dda: https://www.shadertoy.com/view/4dX3zl\nvec3 intersect(vec3 ro, vec3 rd, out ivec3 ip, out ivec3 n)\n{\n\tivec3 mapPos = ivec3(floor(ro + 0.));\n\tvec3 deltaDist = abs(vec3(length(rd)) / rd);\n\tivec3 rayStep = ivec3(sign(rd));\n\tvec3 sideDist = (sign(rd) * (vec3(mapPos) - ro) + (sign(rd) * 0.5) + 0.5) * deltaDist; \n\t\n\tbvec3 mask;\n\tfor (int i = 0; i < 15; i++) {\n\t\tif (notEmpty(mapPos)) continue;\n\t\t\n\t\tbvec3 b1 = lessThan(sideDist.xyz, sideDist.yzx);\n\t\tbvec3 b2 = lessThanEqual(sideDist.xyz, sideDist.zxy);\n\t\tmask.x = b1.x && b2.x;\n\t\tmask.y = b1.y && b2.y;\n\t\tmask.z = b1.z && b2.z;\n\t\t\n\t\t//All components of mask are false except for the corresponding largest component\n\t\t//of sideDist, which is the axis along which the ray should be incremented.\t\t\t\n\t\tsideDist += vec3(mask) * deltaDist;\n\t\tmapPos += ivec3(mask) * rayStep;\n\t}\n\tip = mapPos;\n\tn = ivec3(mask)*ivec3(sign(-rd));\n\t\n\t// intersect the cube (copied from iq :] )\n\tvec3 mini = (vec3(mapPos)-ro + 0.5 - 0.5*sign(rd))/rd;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\treturn ro+rd*t;\n}\n\nvoid cameraTransform( inout vec3 ro, inout vec3 rd )\n{\n\t// turn camera left/right slightly\n\tfloat theta = sin(time)/4.0;\n\t\n\tfloat c = cos(cos(theta)/10.0);\n\tfloat s = sin(sin(theta)/10.0);\n    mat3 rot = mat3(\n\t\t  c,  0.0,   s,\n\t\t0.0,  1.0, 0.0,\n\t\t -s,  0.0,   c\n\t);\n\tro *= rot;\n\trd *= rot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-resolution.xy/2.0) / resolution.yy;\n\tuv.y = -uv.y;\n\t\n\t// perspective projection\n\tvec3 ro = vec3(0.01,0.01,0.01);\n\tvec3 rd = normalize(vec3(uv,1.0));\n\tcameraTransform(ro, rd);\n\t\n\tivec3 ip;\n\tivec3 n;\n\tvec3 pos = intersect(ro,rd, ip,n);\n\tvec3 col = vec3(hash(float(ip+10*ip.y+100*ip)));\n\t\n\tvec3 cubeP = mod(pos-0.001,1.0);\n\tvec3 edgeD = 0.5-abs(cubeP-0.5);\n\tedgeD += abs(vec3(n));\n\tfloat closest = min(edgeD.x,min(edgeD.y,edgeD.z));\n\tfloat glow = smoothstep(0.1,0.0,closest);\n\tcol.rg += glow;\n\n\tfragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n\tvec4 color;\n\tmainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "142100e", "parent": null, "id": "28117.0"}