{"code": "\n// SixteenSegmentDisplayV3.glsl               2015-10-04\n// 16 Segment Display Example v3\n// rearranged source code by I.G.P.\n// Do you know further optimizations ?  \n//\n// change neon colors by moving around with your mouse!\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst vec2 ch_size  = vec2(1.0, 2.0);              // character size\nconst vec2 ch_space = ch_size + vec2(0.7, 1.0);    // character distance  \nconst vec2 ch_start = vec2 (ch_space.x * -6., 4.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position\n      vec3 ch_color = vec3 (0.6, 1.7, 0.8);        // character color\nconst vec3 bg_color = vec3 (0.0, 0.0, 0.0);        // background color\n\nvec2 uv;\n\n#define REPEAT_SIGN false\n\n/*========== 16 segment display ==============\n\nSegment bit positions:\n\n  __2__ __1__         any bit adds one segment\n |\\    |    /|     \n | \\   |   / |     bit:   15 12 11 8 7654 3210              \n 3  11 10 9  0             |  | |  | |||| ||||              \n |   \\ | /   |    binary:  0000 0000 0000 0000           \n |    \\|/    |                                          \n  _12__ __8__         example: letter A                 \n |           |                                          \n |    /|\\    |            15 12 11 8 7654 3210              \n 4   / | \\   7             |  | |  | |||| ||||              \n | 13 14  15 |             0001 0001 1001 1111              \n | /   |   \\ |                                          \n  __5__|__6__          binary to hex -> 0x119F          \n\n*/\n\n#define n0 ddigit(0x22FF);\n#define n1 ddigit(0x0281);\n#define n2 ddigit(0x1177);\n#define n3 ddigit(0x11E7);\n#define n4 ddigit(0x5508);\n#define n5 ddigit(0x11EE);\n#define n6 ddigit(0x11FE);\n#define n7 ddigit(0x2206);\n#define n8 ddigit(0x11FF);\n#define n9 ddigit(0x11EF);\n\n#define A ddigit(0x119F);\n#define B ddigit(0x927E);\n#define C ddigit(0x007E);\n#define D ddigit(0x44E7);\n#define E ddigit(0x107E);\n#define F ddigit(0x101E);\n#define G ddigit(0x807E);\n#define H ddigit(0x1199);\n#define I ddigit(0x4466);\n#define J ddigit(0x4436);\n#define K ddigit(0x9218);\n#define L ddigit(0x0078);\n#define M ddigit(0x0A99);\n#define N ddigit(0x8899);\n#define O ddigit(0x00FF);\n#define P ddigit(0x111F);\n#define Q ddigit(0x80FF);\n#define R ddigit(0x911F);\n#define S ddigit(0x8866);\n#define T ddigit(0x4406);\n#define U ddigit(0x00F9);\n#define V ddigit(0x2218);\n#define W ddigit(0xA099);\n#define X ddigit(0xAA00);\n#define Y ddigit(0x4A00);\n#define Z ddigit(0x2266);\n#define s_dot     ddigit(0);\n#define s_ddot    ddigit(1);\n#define s_minus   ddigit(0x1100);\n#define s_plus    ddigit(0x5500);\n#define s_greater ddigit(0x2800);\n#define s_less    ddigit(0x8200);\n#define s_sqrt    ddigit(0x0C02);\n#define s_uline   ddigit(0x0060);\n#define _  ch_pos.x += ch_space.x;  // blanc\n#define nl ch_pos.x = ch_start.x;  ch_pos.y -= 3.0;\n\nfloat dseg(vec2 p0, vec2 p1)\n{\n  vec2 dir = normalize(p1 - p0);\n  vec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));   \n}\n\nbool bit(int n, int b)\n{\n  return mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0;\n}\n\nfloat d = 1.0;\n\nvoid ddigit(int n)\n{\n  float v = 1.0;\t\n  vec2 cp = uv - ch_pos;\n  if (n == 0)        v = min(v, dseg(vec2(-0.0054, -1.000), vec2( 0.000, -1.000)));\n  else if (n == 1) { v = min(v, dseg(vec2( 0.005, -1.000), vec2( 0.000, -1.000))); \n\t\t     v = min(v, dseg(vec2( 0.005,  0.000), vec2( 0.000,  0.000))); \n\t\t   }\n  else \n  {\n\tif (bit(n,  0)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(n,  1)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(n,  2)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(n,  3)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(n,  4)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(n,  5)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(n,  6)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n,  7)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n,  8)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n,  9)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n, 10)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n, 11)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n, 12)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n, 13)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n, 14)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n, 15)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n  }\n  ch_pos.x += ch_space.x;\n  d = min(d, v);\n}\n\nvoid showValue (float value)\n{\n  for(int ni = 4; ni > -3;ni--)\n  {\n    if (ni == -1) s_dot;   // add dot\n    float dd = (value / pow(10.0,float(ni)));\n    dd = mod(floor(dd), 10.0);\n    if      (dd < 0.5) n0\n    else if (dd < 1.5) n1\n    else if (dd < 2.5) n2\n    else if (dd < 3.5) n3\n    else if (dd < 4.5) n4\n    else if (dd < 5.5) n5\n    else if (dd < 6.5) n6\n    else if (dd < 7.5) n7\n    else if (dd < 8.5) n8\n    else if (dd < 9.5) n9\n  }\n}\n\n\nvoid main( void ) \n{\n  vec2 aspect = resolution.xy / resolution.y;\n  uv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n  uv *= 20.0 + sin(time);     //  set zoom size\n  if (REPEAT_SIGN)\n    uv = -12.0 + mod(1.8*(uv-1.0), ch_space*vec2(16.,6.5));   //  set zoom size\n\n  ch_pos = ch_start + vec2(sin(time),4.0);  // set start position\n       \n  ch_color = vec3 (2.6 - 4.*mouse.x, 1.2-mouse.x*mouse.y, 0.5+mouse.y);\n  n1 n6 s_minus S E G M E N T s_minus    nl\n  ch_pos.x += sin(time);    // set start position\n  _ _ _ D I S P L A Y s_dot V n3 s_ddot  nl\n  A B C D E F G H I J K L M nl \n  N O P Q R S T U V W X Y Z nl\n  s_sqrt s_plus s_minus n0 n1 n2 n3 n4 n5 n6 n7 n8 n9 s_dot nl\n  T I M E s_ddot showValue(time);\t\n\t\t\n  ch_color = mix(ch_color, bg_color, 1.0- (0.08 / d));  // shading\n\t\n  gl_FragColor = vec4(ch_color, 1.0);\n}\n", "user": "285473f", "parent": "/e#27934.2", "id": "28029.4"}