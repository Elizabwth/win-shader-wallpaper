{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n// Not-so-mega-ball!\n// Wasting more processor cycles to deliver an inferior breakout clone than ever before possible!\n// Original URL: http://glsl.heroku.com/456\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D backbuffer;\n\nvec3 Brick(float x, float y) {\n\t// Make random(ish) brick color based on floored x, y\n\tx += y * 17.23523;\n\tfloat ang = pow(46.0 + x, 2.8234) + pow(52.0 + y, 3.9234);\n\treturn vec3(0.7 + 0.19 * sin(ang), 0.7 + 0.19 * sin(ang + 2.094), 0.7 + 0.19 * sin(ang - 2.094));\n}\n\nvec3 Ball(bool x, bool y) {\n\t// Draw ball with indicated direction\n\treturn vec3(1.0, x ? 0.9 : 1.0, y ? 0.9 : 1.0);\n}\n\nbool IsUninitialized(vec3 color) {\n\treturn (color == vec3(0.0, 0.0, 0.0));\n}\n\nbool IsBall(vec3 color, bool x, bool y) {\n\t// Test for ball with specific direction\n\tif (color.r < 0.95) {return false;}\n\tif (abs(color.g - (x ? 0.9 : 1.0)) > 0.05) {return false;}\n\tif (abs(color.b - (y ? 0.9 : 1.0)) > 0.05) {return false;}\n\treturn true;\n}\n\nbool IsAnyBall(vec3 color) {\n\treturn ((color.r > 0.95) && (color.g > 0.85) && (color.b > 0.85));\n}\n\nbool IsWall(vec3 color) {\n\treturn (length(color - vec3(0.5, 0.7, 0.6)) < 0.1);\n}\n\nbool IsBrick(vec3 color) {\n\tif (color.r < 0.5) {return false;}\n\tif (color.g < 0.5) {return false;}\n\tif (color.b < 0.5) {return false;}\n\tif (color.r > 0.9) {return false;}\n\tif (color.g > 0.9) {return false;}\n\tif (color.b > 0.9) {return false;}\n\treturn true;\n}\n\nbool IsBlocked(vec3 color) {\n\treturn (IsWall(color) || IsBrick(color));\n}\n\nbool IsExplosion(vec3 color, bool orball) {\n\tif (orball) {if ((color.r > 0.95) && (color.g > 0.85) && (color.b > 0.85)) {return true;}}\n\treturn ((color.r > 0.5) && (color.r < 1.0) && (color.g > 0.5) && (color.b < 0.25));\n}\n\nbool IsBonus(vec3 color) {\n\treturn ((color.b > 0.95) && (color.r < 0.5));\n}\n\nbool IsStealthBonus(vec3 color) {\n\treturn (color.b > 0.15);\n}\n\nvoid main( void ) {\n\tvec2 position = ( gl_FragCoord.xy / resolution.xy );\n\tvec2 pixel = 1./resolution;\n\tvec2 mousepx = mouse * pixel;\n\n\tvec3 space = vec3(0.02, 0.04, 0.1);\n\tvec3 explosion = vec3(0.8, 0.8, 0.2);\n\tvec3 wall = vec3(0.5, 0.7, 0.6);\n\tvec3 fakeball = vec3(0.9, 1.0, 1.0);\n\tvec3 bonus = vec3(0.0, 0.5 + 0.5 * sin(time * 5.0), 1.0);\n\tvec3 fakebonus = vec3(0.0, 0.5 + 0.5 * sin(time * 5.0), 0.9);\n\tvec3 stealthbonus = vec3(0.9, 1.0, 1.0);\n\n\tvec4 old = texture2D(backbuffer, position);\n\tvec4 me = vec4(space.r, space.g, space.b, 1.0);\n\tfloat ballspeed = floor(0.002 * resolution.x) + 1.0;\n\n\tif (position.y < pixel.y) {\n\t\t// bonus-signalling column\n\t\tif (IsStealthBonus(texture2D(backbuffer, position + vec2(6.0, 0.0) * pixel).rgb)) {me.rgb = stealthbonus;}\n\t\tif (abs(position.x - mouse.x) < 0.04) {\n\t\t\tfor (int n=0; n<5; n++) {\n\t\t\t\tif (float(n) <= 0.005 * resolution.y) {\n\t\t\t\t\tif (IsBonus(texture2D(backbuffer, vec2(position.x, 0.045) + vec2(0.0, float(n)) * pixel).rgb)) {\n\t\t\t\t\t\tme.rgb = stealthbonus;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if ((position.x < 2.0 * pixel.x) || (position.x > (resolution.x - 2.0) * pixel.x) || (position.y > (resolution.y - 2.0) * pixel.y)) {\n\t\t// borders\n\t\tme.rgb = wall;\n\t} else if ((position.y > 0.02) && (position.y < 0.045) && (abs(position.x - mouse.x) < 0.04)) {\n\t\t// Player paddle\n\t\tme.rgb = wall;\n\t} else {\n\t\t// Playing field\n\n\t\t// Draw fake ball and bonus pixels around actuals from last frame\n\t\tfor (float x = -2.0; x <= 2.0; x += 1.0) {\n\t\t\tfor (float y = -2.0; y <= 2.0; y += 1.0) {\n\t\t\t\tif (IsBonus(texture2D(backbuffer, position + vec2(x, y) * pixel).rgb)) {me.rgb = fakebonus;}\n\t\t\t\tif ((abs(x) < 2.0) || (abs(y) < 2.0)) {\n\t\t\t\t\tif (IsAnyBall(texture2D(backbuffer, position + vec2(x, y) * pixel).rgb)) {me.rgb = fakeball;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (IsUninitialized(old.rgb)) {\n\t\t\t// draw blocks for first time\n\t\t\tfloat enemyrow = (1.0 - position.y - 0.05) * 25.0;\n\t\t\tfloat enemyrowmod = mod(enemyrow, 1.0);\n\t\t\tfloat enemycol = position.x * 20.4 - 0.275;\n\t\t\tfloat enemycolmod = mod(enemycol, 1.0);\n\t\t\tbool oddrow = (floor(mod(enemyrow, 2.0)) == 1.0);\n\n\t\t\tif ((enemyrow >= 0.0) && (enemyrow < 6.0)) {\n\t\t\t\tif ((enemycol >= 0.0) && (enemycol < 20.0)) {\n\t\t\t\t\tme.rgb = ((enemyrowmod < 0.8) && (enemycolmod < 0.85)) ? Brick(floor(enemycol), floor(enemyrow)) : space;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (length(gl_FragCoord.xy - vec2(floor(0.5 * resolution.x) + 0.5, floor(0.1852 * resolution.y) + 0.5)) < 1.0) {\n\t\t\t\tme.rgb = Ball(true, true);\n\t\t\t}\n\t\t} else if (IsBrick(old.rgb)) {\n\t\t\t// Grow explosions to consume whole block\n\t\t\tbool exploding = \n\t\t\t\t(IsExplosion(texture2D(backbuffer, position + vec2(1.0, 0.0) * pixel).rgb, true)) ||\n\t\t\t\t(IsExplosion(texture2D(backbuffer, position + vec2(-1.0, 0.0) * pixel).rgb, true)) ||\n\t\t\t\t(IsExplosion(texture2D(backbuffer, position + vec2(0.0, 1.0) * pixel).rgb, true)) ||\n\t\t\t\t(IsExplosion(texture2D(backbuffer, position + vec2(0.0, -1.0) * pixel).rgb, true));\n\t\t\tme.rgb = exploding ? explosion : old.rgb;\n\t\t\tfor (int n=0; n<4; n++) {\n\t\t\t\tbool bx = (n == 1) || (n == 3);\n\t\t\t\tbool by = (n >= 2);\n\t\t\t\tvec2 ballpos = position + vec2(bx ? -ballspeed : ballspeed, by ? -ballspeed : ballspeed) * 2.0 * pixel;\n\t\t\t\tif (IsAnyBall(texture2D(backbuffer, ballpos).rgb)) {\n\t\t\t\t\tme.rgb = explosion;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ((IsExplosion(old.rgb, false)) && (mod(fract(sin(dot(position + time * 0.001, vec2(14.9898,78.233))) * 43758.5453), 1.0) < 0.5 / resolution.x)) {\n\n\t\t\t// Explosions sometimes drop bonuses\n\t\t\tme.rgb = bonus;\n\t\t} else if (IsBonus(texture2D(backbuffer, position + vec2(0.0, 0.005)).rgb)) {\n\t\t\t// Existing bonuses fall\n\t\t\tme.rgb = bonus;\n\t\t}\n\n\n\t\t// If ball is going to land at this pixel this cycle, figure out which direction it needs to take for next cycle\n\t\tfor (int n=0; n<4; n++) {\n\t\t\tbool bx = (n == 1) || (n == 3);\n\t\t\tbool by = (n >= 2);\n\t\t\tvec2 ballpos = position + vec2(bx ? -ballspeed : ballspeed, by ? -ballspeed : ballspeed) * pixel;\n\t\t\tif (IsBall(texture2D(backbuffer, ballpos).rgb, bx, by)) {\n\t\t\t\tballpos = position + vec2(bx ? ballspeed : -ballspeed, by ? ballspeed : -ballspeed) * pixel;\n\t\t\t\tbool blocked_diag = IsBlocked((texture2D(backbuffer, ballpos).rgb));\n\t\t\t\tballpos = position + vec2(bx ? ballspeed : -ballspeed, by ? -ballspeed : ballspeed) * pixel;\n\t\t\t\tbool blocked_x = IsBlocked((texture2D(backbuffer, ballpos).rgb));\n\t\t\t\tballpos = position + vec2(bx ? -ballspeed : ballspeed, by ? ballspeed : -ballspeed) * pixel;\n\t\t\t\tbool blocked_y = IsBlocked((texture2D(backbuffer, ballpos).rgb));\n\t\t\t\tif (blocked_x && (!blocked_y)) {\n\t\t\t\t\tbx = !bx;\n\t\t\t\t} else if (blocked_y && (!blocked_x)) {\n\t\t\t\t\tby = !by;\n\t\t\t\t\tif (position.y < 0.1) {\n\t\t\t\t\t\tbx = (position.x > mouse.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (blocked_x || blocked_y || blocked_diag) {\n\t\t\t\t\tbx = !bx;\n\t\t\t\t\tby = !by;\n\t\t\t\t}\n\t\t\t\tme.rgb = Ball(bx, by);\n\t\t\t}\n\n\t\t\t// Bonus activation makes ball split\n\t\t\tif (IsBall(old.rgb, bx, by)) {\n\t \t\t\tfor (int n=0; n<=5; n++) {\n\t\t\t\t\tif (IsStealthBonus(texture2D(backbuffer, vec2(float(n) + 0.5, 0.5) * pixel).rgb)) {\n\t\t\t\t\t\tme.rgb = Ball(!bx,by);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tgl_FragColor = me;\n}", "user": "b2aa83a", "parent": null, "id": "456.15"}