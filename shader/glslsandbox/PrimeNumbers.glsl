{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat extract_bit(float n, float b);\nfloat sprite(float n, vec2 p);\nfloat digit(float n, vec2 p);\nfloat print_index(float index, vec2 position);\nfloat ulam_spiral(vec2 field);\nfloat little_sieve(float n);\n\nvoid main( void ) \n{\n\t//pixel coordinate\n\tvec2 coordinate\t\t= gl_FragCoord.xy-resolution*.5;\n\t\n\t\n\t//ulam spiral\n\tfloat scale\t\t= 16.;\t\n\tvec2 field\t\t= floor(coordinate/scale);\t\n\tfloat ulam\t\t= ulam_spiral(field);\n\n\t\n\t//fun\n//\tvec2 mouse_coordinate\t= floor((mouse*resolution-resolution*.5)/scale);\n//\tfloat mouse_ulam\t\t= ulam_spiral(field - mouse_coordinate);\n//\tulam\t\t\t= floor(abs(ulam+mouse_ulam));\n\t\n\t\n\t//visualization (colors, numbers)\n\tfloat grid\t\t= float(mod(coordinate.x, scale) < 1.) + float(mod(coordinate.y+.5, scale) < 1.);\n\t\n\tbvec4 quadrant\t\t\t= bvec4(false);\n\tquadrant.x\t\t= field.x >= 0. && abs(field.x) >= abs(field.y);\n\tquadrant.y\t\t= field.y >= 0. && abs(field.x)  < abs(field.y);\n\tquadrant.z\t\t= field.x  < 0. && abs(field.x) >= abs(field.y);\n\tquadrant.w\t\t= field.y  < 0. && abs(field.x)  < abs(field.y);\n\t\n\tvec2 print_coordinate\t= coordinate;\n\tprint_coordinate.x\t= mod(print_coordinate.x, scale);\n\tprint_coordinate.y\t= mod(print_coordinate.y, scale);\n\tprint_coordinate\t-= scale * .5;\n\t\n\tvec3 print\t\t= vec3(0.);\n\tprint.xyz\t\t+= print_index(ulam, print_coordinate - vec2(4.,-2.));\n\t\n\tfloat seive \t\t= .5+little_sieve(ulam);\n\t\n\t\n\t//combined results for display\n\tvec4 result\t\t= vec4(0.);\n\t\n\tresult.x \t\t+= float(quadrant.x);\n\tresult.y \t\t+= float(quadrant.y);\n\tresult.z \t\t+= float(quadrant.z);\n\tresult.xy \t\t+= float(quadrant.w);\n\n\tresult\t\t\t+= grid/4.;\n\tresult\t\t\t+= abs(floor(mod(time*128., 2048.))-ulam) < 1. ? 1. : 0.;\n\tresult.xyz\t\t+= print;\n\n\tresult \t\t\t*= seive;\n\tresult\t\t\t*= .5;\n\tresult.w\t\t\t= .5 + seive;\n\t\n\tgl_FragColor\t\t= result;\n}//sphinx\n\nfloat ulam_spiral(vec2 p)\n{\n\tfloat x \t\t= abs(p.x);\n\tfloat y\t\t= abs(p.y);\n\tbool q\t\t= x > y;\n\t\n\tx\t\t= q ? x : y;\n\ty\t\t= q ? p.x + p.y : p.x - p.y;\n\ty \t\t= abs(y) + 4. * x * x + 1.;\n\tx \t\t*= 2.;\n\t\n\treturn q ? (p.x > 0. ? y - x - x : y) \n\t\t : (p.y > 0. ? y - x : y + x);\t\n}\n\n\nfloat little_sieve(float n)\n{\t\n\tbool prime = n != 0.;\n\tconst float factors = 32.;\n\tfor(float i = 2.; i < factors; i++)\n\t{\n\t\tif(prime)\n\t\t{\n\t\t\tprime = (sqrt(2.+n) <= i || mod(n, i) > 0.);;\n\t\t}\n\t}\n\treturn float(prime);\n}\n\nfloat extract_bit(float n, float b)\n{\n\tn = floor(n);\n\tb = floor(b);\n\tb = floor(n/pow(2.,b));\n\treturn float(mod(b,2.) == 1.);\n}\n\nfloat sprite(float n, vec2 p)\n{\n\tp = floor(p);\n\tfloat bounds = float(all(lessThan(p, vec2(3., 5.))) && all(greaterThanEqual(p,vec2(0,0))));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\nfloat digit(float n, vec2 p)\n{\n\tn = mod(floor(n), 10.0);\n\tif(n == 0.) return sprite(31599., p);\n\telse if(n == 1.) return sprite( 9362., p);\n\telse if(n == 2.) return sprite(29671., p);\n\telse if(n == 3.) return sprite(29391., p);\n\telse if(n == 4.) return sprite(23497., p);\n\telse if(n == 5.) return sprite(31183., p);\n\telse if(n == 6.) return sprite(31215., p);\n\telse if(n == 7.) return sprite(29257., p);\n\telse if(n == 8.) return sprite(31727., p);\n\telse if(n == 9.) return sprite(31695., p);\n\telse return 0.0;\n}\n\nfloat print_index(float index, vec2 position)\n{\t\n\tfloat result\t= 0.;\n\tresult \t\t+= index < 0. ? sprite(24., position+vec2(4., 0.)) : 0.;\t\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\tif(index >= place || float(i) < 1.)\n\t\t{\n\t\t\tresult\t \t+= digit(abs(index/place), position);\n\t\t\tposition.x \t+= 4.;\n\t\t}\n\t}\n\treturn result;\n}", "user": "92f5465", "parent": null, "id": "30868.1"}