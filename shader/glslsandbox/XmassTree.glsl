{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n// Yet Another Christmas Tree by Ruslan Shestopalyuk, 2014/15\n// Many thanks to iq, eiffie and paolofalcao for the insight and the code\n\n#define PI                      3.14159265\n\n#define NORMAL_EPS              0.001\n\n#define NEAR_CLIP_PLANE         1.0\n#define FAR_CLIP_PLANE          100.0\n#define MAX_RAYCAST_STEPS       200\n#define STEP_DAMPING 0.7\n#define DIST_EPSILON            0.001\n#define MAX_RAY_BOUNCES         3.0\n\n#define GLOBAL_LIGHT_COLOR      vec3(0.8,1.0,0.9)\n#define SPEC_COLOR              vec3(0.8, 0.90, 0.60)\n#define MINERS_LIGHT_OFFSET      vec3(-0.2, -0.1, -0.3)\n#define BACKGROUND_COLOR        vec3(0.3, 0.342, 0.5)\n\n#define CAM_DIST                13.5\n#define CAM_H                   3.0\n#define CAM_FOV_FACTOR 2.5\n#define LOOK_AT_H               4.5\n#define LOOK_AT                 vec3(0.0, LOOK_AT_H, 0.0)\n\n#define MTL_BACKGROUND          -1.0\n#define MTL_GROUND              1.0\n#define MTL_NEEDLE              2.0\n#define MTL_STEM                3.0\n#define MTL_TOP_DEC             4.0\n#define MTL_DEC_BINDING         5.0\n#define MTL_DEC                 6.0\n\n#define DEC_REFL_FACTOR         0.7\n\n#define TREE_H                  4.0\n#define TREE_R                  3.0\n#define DEC_R                   0.5\n#define V_DEC_SPACING           1.9\n#define STAR_SCALE              0.5\n\n#define NEEDLE_LENGTH           0.35\n#define NEEDLE_SPACING          0.15\n#define NEEDLE_THICKNESS        0.05\n#define NEEDLES_RADIAL_NUM      17.0\n#define NEEDLE_BEND             0.99\n#define NEEDLE_TWIST            1.0\n#define NEEDLE_GAIN             0.7\n#define STEM_THICKNESS          0.02\n#define BRANCH_ANGLE            0.423\n#define BRANCH_SPACING          1.7\n\n// Primitives\nfloat plane(vec3 p, vec3 n, float offs) {\n  return dot(p, n) + offs;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cone(in vec3 p, float r, float h) {\n    return max(abs(p.y) - h, length(p.xz)) - r*clamp(h - abs(p.y), 0.0, h);\n}\n\n\nfloat cylinder(vec3 p, vec2 h) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat torus(vec3 p, float ri, float ro) {\n    vec2 q = vec2(length(p.xz) - ri, p.y);\n    return length(q) - ro;\n}\n\n\n// Boolean operations\nfloat diff(float d1, float d2) {\n    return max(-d2, d1);\n}\n\nfloat add(float d1, float d2) {\n    return min(d2, d1);\n}\n\nfloat intersect(float d1, float d2) {\n    return max(d2, d1);\n}\n\n\n// Boolean operations (with material ID in second component)\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\n\n// Affine transformations\nvec3 translate(vec3 p, vec3 d) {\n    return p - d;\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c-p.y*s, p.x*s+p.y*c);\n}\n\n\n//  Repetition\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nvec3 repeatAng(vec2 p, float n) {\n    float ang = 2.0*PI/n;\n    vec2 ret = rotate(p, -ang*0.5);\n    float sector = floor(atan(ret.x, ret.y)/ang);\n    p = rotate(p, sector*ang);\n    return vec3(p.x, p.y, sector);\n}\n\n//  Complex primitives\nfloat star(vec3 p) {\n    p.xy = (repeatAng(p.xy, 5.0)).xy;\n    p.xz = abs(p.xz);\n    return plane(p, vec3(0.5, 0.25, 0.8), -0.09);\n}\n\n//  Scene elements\nvec2 ground(in vec3 p) {\n    p.y += (sin(sin(p.z*0.1253) - p.x*0.371)*0.31 + cos(p.z*0.553 + sin(p.x*0.127))*0.12)*1.7 + 0.2;\n    return vec2(p.y, MTL_GROUND);\n}\n\nvec2 decoration(in vec3 pos, float matID) {\n    float decType = mod(matID, 5.0);\n    float d = sphere(pos, DEC_R);\n    if (decType <= 0.0) {\n        // bumped sphere\n        d += cos(atan(pos.x, pos.z)*30.0)*0.01*(0.5 - pos.y) + sin(pos.y*60.0)*0.01;\n    } else if (decType <= 1.0) {\n        // dented sphere\n        d = diff(d, sphere(pos + vec3(0.0, 0.0, -0.9), 0.7));\n    } else if (decType <= 2.0) {\n        // horisontally distorted sphere\n        d  += cos(pos.y*28.0)*0.01;\n    } else if (decType <= 3.0) {\n        // vertically distorted sphere\n        d += cos(atan(pos.x, pos.z)*20.0)*0.01*(0.5-pos.y);\n    }\n\n    vec2 res = vec2(d, matID);\n    // binding\n    float binding = cylinder(pos - vec3(0.0, 0.5, 0.0), vec2(0.08, 0.1));\n    binding = add(binding, torus(pos.xzy - vec3(0.0, 0.0, 0.62), 0.05, 0.015));\n    vec2 b = vec2(binding, MTL_DEC_BINDING);\n    add(res, b);\n    return res;\n}\n\n\nvec2 decorations(in vec3 p) {\n    vec3 pos = p;\n    float h = abs(-floor(pos.y/V_DEC_SPACING)/TREE_H + 1.0)*TREE_R;\n    vec3 r = repeatAng(pos.xz, max(1.0, 2.5*h));\n    float matID = h*113.0 + r.z*7.0 + 55.0;\n    // pick the material ID\n    pos.y -= mod(matID, 11.0)*0.03;\n    pos.xz = r.xy;\n    pos.y = mod(pos.y, V_DEC_SPACING) - 0.5;\n    pos += vec3(0.0, 0.0, -h + 0.2);\n    vec2 res = decoration(pos, matID);\n    res.x = intersect(res.x, sphere(p, TREE_H*2.0 - 0.5));\n    return res;\n}\n\n\nvec2 topDecoration(vec3 pos) {\n    pos.y -= TREE_H*2.0 + 0.8;\n    pos *= STAR_SCALE;\n    float d = add(star(pos), cylinder(pos - vec3(0.0, -0.2, 0.0), vec2(0.04, 0.1)))/STAR_SCALE;\n    return vec2(d, MTL_TOP_DEC);\n}\n\n\nfloat needles(in vec3 p) {\n    p.xy = rotate(p.xy, -length(p.xz)*NEEDLE_TWIST);\n    p.xy = repeatAng(p.xy, NEEDLES_RADIAL_NUM).xy;\n    p.yz = rotate(p.yz, -NEEDLE_BEND);\n    p.y -= p.z*NEEDLE_GAIN;\n    p.z = min(p.z, 0.0);\n    p.z = repeat(p.z, NEEDLE_SPACING);\n    return cone(p, NEEDLE_THICKNESS, NEEDLE_LENGTH);\n}\n\nvec2 branch(in vec3 p) {\n    vec2 res = vec2(needles(p), MTL_NEEDLE);\n    float s = cylinder(p.xzy + vec3(0.0, 100.0, 0.0), vec2(STEM_THICKNESS, 100.0));\n    vec2 stem = vec2(s, MTL_STEM);\n    add(res, stem);\n    return res;\n}\n\nvec2 halfTree(vec3 p) {\n    float section = floor(p.y/BRANCH_SPACING);\n    float numBranches =  max(2.0, 9.0 - section*1.2);\n    p.xz = repeatAng(p.xz, numBranches).xy;\n    p.z -= TREE_R*1.27;\n    p.yz = rotate(p.yz, BRANCH_ANGLE);\n    p.y = repeat(p.y, BRANCH_SPACING);\n    return branch(p);\n}\n\n\nvec2 tree(vec3 p) {\n    vec2 res = halfTree(p);\n    // repeat it again, to hide the regularity\n    p.xz = rotate(p.xz, 0.7);\n    p.y -= BRANCH_SPACING*0.4;\n    vec2 t1 = halfTree(p);\n    add(res, t1);\n\n    // trunk    \n    vec2 trunk = vec2(cone(p.xyz, 0.02, TREE_H*2.0), MTL_STEM);\n    add(res, trunk);\n    res.x = intersect(res.x, sphere(p - vec3(0.0, TREE_H, 0.0), TREE_H + 1.7));\n    return res;\n}\n\nvec2 distf(in vec3 pos) {\n    vec2 tr = tree(pos);\n    vec2 tdec = topDecoration(pos);\n    vec2 dec = decorations(pos);\n    vec2 res = ground(pos);\n    add(res, tr);\n    add(res, tdec);\n    add(res, dec);\n    return res;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n    vec2 d = vec2(NORMAL_EPS, 0.0);\n    return normalize(vec3(\n        distf(p + d.xyy).x - distf(p - d.xyy).x,\n        distf(p + d.yxy).x - distf(p - d.yxy).x,\n        distf(p + d.yyx).x - distf(p - d.yyx).x));\n}\n\n\nvec2 rayMarch(in vec3 ro, in vec3 rd) {\n    float t = NEAR_CLIP_PLANE;\n    float m = MTL_BACKGROUND;\n    for (int i=0; i < MAX_RAYCAST_STEPS; i++) {\n        vec2 res = distf(ro + rd*t);\n        if (res.x< DIST_EPSILON || t>FAR_CLIP_PLANE) break;\n        t += res.x*STEP_DAMPING;\n        m = res.y;\n    }\n\n    if (t > FAR_CLIP_PLANE) m = MTL_BACKGROUND;\n    return vec2(t, m);\n}\n\n\nvec3 applyFog(vec3 col, float dist) {\n    return mix(col, BACKGROUND_COLOR, 1.0 - exp(-0.001*dist*dist));\n}\n\n\nvec3 getMaterialColor(float matID) {\n    vec3 col = BACKGROUND_COLOR;\n    if (matID <= MTL_GROUND) col = vec3(3.3, 3.3, 4.5);\n    else if (matID <= MTL_NEEDLE) col = vec3(0.152,0.36,0.18);\n    else if (matID <= MTL_STEM) col = vec3(0.79,0.51,0.066);\n    else if (matID <= MTL_TOP_DEC) col = vec3(1.6,1.0,0.6);\n    else if (matID <= MTL_DEC_BINDING) col = vec3(1.2,1.0,0.8);\n    else col = 0.3 + 0.7*sin(vec3(0.7, 0.4, 0.41)*(matID - MTL_DEC));\n    return col;\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < MAX_RAYCAST_STEPS; i++) {\n        float h = distf( ro + rd*t ).x*STEP_DAMPING;\n        res = min(res, 8.0*h/t);\n        t += clamp(h, 0.01, 0.25);\n        if (h < DIST_EPSILON || t > tmax) break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    vec3  lig = normalize(-rd + MINERS_LIGHT_OFFSET);\n    vec3 resCol = vec3(0.0);\n    float alpha = 1.0;\n    for (float i = 0.0; i < MAX_RAY_BOUNCES; i++) {\n        vec2 res = rayMarch(ro, rd);\n        float t = res.x;\n        float mtlID = res.y;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        vec3 mtlColor = getMaterialColor(mtlID);\n        float ambient = 0.03;\n        float diffuse = clamp(dot(nor, lig), 0.0, 1.0);\n        float specular = pow(clamp( dot(ref, lig), 0.0, 1.0), 10.0);\n        diffuse *= shadow(pos, lig, 0.01, 1.0);\n        vec3 col = mtlColor*(ambient + GLOBAL_LIGHT_COLOR*(diffuse + 1.20*specular*SPEC_COLOR));\n        col = applyFog(col, t);\n        //  blend in (a possibly reflected) new color \n        resCol += col*alpha;\n        if (mtlID <= MTL_DEC) break;\n        ro = pos + ref*DIST_EPSILON;\n        alpha *= DEC_REFL_FACTOR;\n        rd = ref;\n    }\n\n    return vec3(clamp(resCol, 0.0, 1.0));\n}\n\n\nvec3 getRayDir(vec3 camPos, vec3 viewDir, vec2 pixelPos) {\n    vec3 camRight = normalize(cross(viewDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, viewDir));\n    return normalize(pixelPos.x*camRight + pixelPos.y*camUp + CAM_FOV_FACTOR*viewDir);\n}\n\n\nvoid main(void) {\n    vec2 q = gl_FragCoord.xy/resolution;\n    vec2 p = -1.0+2.0*q;\n    p.x *= resolution.x/resolution.y;\n    float ang = 0.1*(40.0 + time);\n    vec3 camPos = vec3(CAM_DIST*cos(ang), CAM_H, CAM_DIST*sin(ang));\n    vec3 rayDir = getRayDir(camPos,normalize(LOOK_AT - camPos), p);\n    vec3 color = render(camPos, rayDir);\n    gl_FragColor=vec4(color, 1.0);\n}\n\n\n\n", "user": "5f66b16", "parent": null, "id": "22095.1"}