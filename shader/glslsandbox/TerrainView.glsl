{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n//wip\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform float time;\nuniform sampler2D renderbuffer;\n\n#define PHI                  \t.0005\n#define EPSILON                 .00025\n\n#define FOV                     1.5\n#define FARPLANE                1.\n#define ITERATIONS              256\n\n#define PI                  \t(4.*atan(1.))\n#define TAU                 \t(8.*atan(1.))\n\n#define POSITION\t\tvec3(0.,0.035,0.)\n#define DIRECTION\t\tnormalize(vec3(vec2(cos(mouse.x*TAU), sin(mouse.x*TAU)), mouse.y - .75).xzy)\nstruct ray\n{\n    vec3 origin;\n    vec3 position;\n    vec3 direction;\n    vec3 normal;\n    float epsilon;\n    float range;\n    float steps;\n};\n\nstruct light\n{\n    vec3 position;\n    vec3 direction;\n    vec3 color;\n};\n\nstruct material\n{\n    vec3 color;\n    float roughness;\n    float refractive_index;\n};\n\nvec2\tformat(vec2 uv);\n\nray     view(in vec2 uv);\nray     emit(ray r);\nfloat\tmap(in vec3 position);\nvec3\tderive( const in vec3 position , const in float epsilon);\nvec3\tshade(in ray r, in light l, in material m);\n\nfloat \tdistribution(in float r, in float ndh);\nfloat \tgeometry(in float i, in float ndl, in float ndv);\nfloat \tfresnel(in float i, in float hdl);\n\nfloat\tshadow(in ray r, in light l);\nfloat \tocclusion(vec3 p, vec3 n);\n\nvec3\tsphericalharmonic(vec3 n, in vec4 c[7]);\nvoid\tshcday(out vec4 c[7]);\n\nvec3\tflare(in ray r, in light l);\n\nvec3\thsv(in float h, in float s, in float v);\n\nfloat\thash(float x);\nvec3\thash(vec3 v);\n\nmat2\trmat(in float r);\n\nvec3 g_position = vec3(0.);\n\n//prevent angles from hitting zero\nfloat bound(float angle)\n{\n    return max(angle, .00392156);\n}\n\nfloat witch(float x)\n{\n    return 1./(x*x+1.);\n}\n\nfloat witch(float x, float a)\n{\n    float w = (8.*pow(a, 3.))/(x*x+4.*a*a);\n    return w;\n}\n\n//smoothly blend to min yalxe\nfloat smoothmin(float x, float y, float w)\n{\n    return -(log(exp(w*-x)+exp(w*-y))/w);\n}\n\nfloat fold(in float x)\n{\n    return bound(abs(fract(x)-.5));\n}\n\nvec3 fold(in vec3 p)\n{\n    return vec3(fold(p.x), fold(p.y), fold(p.z));\n}\n\nfloat smooth(float x)\n{\n    return x*x*(3.-2.*x);\n}\n\n\nfloat value_noise(vec2 uv)\n{\n    const float k \t= 257.;\n    vec4 l  \t\t= vec4(floor(uv),fract(uv));\n    float u \t\t= l.x + l.y * k;\n    vec4 v  \t\t= vec4(u, u+1.,u+k, u+k+1.);\n    v       \t\t= fract(fract(v*1.23456789)*9.18273645*v);\n    l.zw    \t\t= l.zw*l.zw*(3.-2.*l.zw);\n    l.x     \t\t= mix(v.x, v.y, l.z);\n    l.y     \t\t= mix(v.z, v.w, l.z);\n    return mix(l.x, l.y, l.w);\n}\n\n\nfloat tf(in vec3 p, in float f, in float a)\n{\n    float n = value_noise(fract(p.xz*4.));\n \n    float q = 4.5;\n\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 tp     = p * f;\n        tp          += fold(tp.zzy*2.+fold(tp.yxx*-2.));\n        float fl    = fold(tp.z+fold(tp.x+fold(tp.y)))/.175-.05;\n        n           = abs(a-n-fl*a);\n        a           *= .275;\n        f           *= q;\n        q           -= .125;\n    }\n    \n    return n;\n}\n\n\nvec4 g_terrain  = vec4(0.);\n//bool rock      = false;\nbool water      = false;\nbool error      = false;\nfloat map(vec3 position)\n{\n    float result = FARPLANE;\n    \n    float noise\t= value_noise(position.xz);\n    \n    float terrain_1 = tf(noise*.125+vec3(position.zy, position.x)*.125-.8, .05, 32.);\n    float terrain_0 = tf(vec3(position.xy, position.z)*0.05+terrain_1*.00125, 1.25, 32.+terrain_1*.35);\n    \n    float terrain   = terrain_0 + terrain_0 + terrain_1 * .0125 ;\n    result  = position.y - terrain * .00175 + .25;\n    \n    //global terrain for color etc\n    g_terrain.x = terrain_1;\n    g_terrain.y = terrain_0;\n\n    g_terrain.w = terrain;\n    \n    //water\n    float wt = position.y + sin(position.x+position.z)*.0125;\n    wt = wt < position.y + .075 ? wt : position.y - .025;\n    water = result < wt;\n\n    result  = min(result, mix(result, wt, .95));\n    \n    return result;\n}\n\n\nvoid main( void )\n{\n    vec2 uv         \t= gl_FragCoord.xy/resolution.xy;\n    \n    //ray\n    ray r           \t= view(uv);\n    r               \t= emit(r);\n    r.epsilon           = r.range *  EPSILON - length(uv-.5) * r.range * EPSILON;\n    r.normal            = derive(r.position, r.epsilon);\n    \n    \n    //create a light\n    light l;\n    l.position          = r.position-vec3(2., 4., 1.);\n    //l.position.xy\t\t*= rmat(time*.5);\n    \n    l.position.y\t= abs(l.position.y);\n    l.direction \t= normalize(l.position-r.position);\n    l.color             = vec3(1., .95, .8) * 4.;\n    \n    \n    //set materials\n    material m;\n    \n    m.color             = hsv(g_terrain.w/g_terrain.z+g_position.y*8., .5, g_terrain.z*.0026);\n    m.color             += hsv(g_position.y*.005-.9, .5, 1.);\n    m.color             = pow(m.color,vec3(2.))+.25;\n    m.color             = water ? m.color : (1.2-m.color*.1) + vec3(.125, .25, .125) * .65;\n\n    m.roughness         = water ? .45 :  .25;\n    m.refractive_index\t= water ? .2 :  .9;\n    \n    vec4 result     \t= vec4(0.);\n    result.xyz          = shade(r, l, m);\n//    result.xyz          += flare(r, l)*2.;\n    result.w            = 1.;\n    \n    //vec4 buffer\t\t= texture2D(renderbuffer, uv);\n    \n    gl_FragColor = result;\n}// sphinx\n\nvec3 shade(in ray r, in light l, in material m)\n{\n    //http://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html\n    //view and light vectors\n    vec3 half_direction \t\t= normalize(r.position-l.position);         //direction halfway between view and light\n    \n    //exposure coefficients\n    float light_exposure    \t= max(dot(r.normal, l.direction), 0.);      //ndl\n    float view_exposure     \t= max(dot(r.normal, -r.direction), 0.);              //ndv\n    float half_normal   \t\t= dot(half_direction, r.normal);            //hdv\n    \n    //fog\n    float distance_fog   \t\t= clamp(r.range/FARPLANE, 0., 1.);\n    float step_fog       \t\t= clamp(r.steps/float(ITERATIONS), 0., 1.);\n    \n    //shadow and occlusion projections\n    float shadows       \t\t= shadow(r, l);\n    float occlusions            \t= occlusion(r.position, r.normal);\n    \n    //microfacet lighting components\n    float d             \t\t= distribution(m.roughness, half_normal);\n    float g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n    float f             \t\t= fresnel(m.refractive_index, light_exposure);\n    float n             \t\t= clamp(1. - fresnel(f, light_exposure), 0., 1.) * m.roughness;\n    \n    //bidrectional reflective distribution function\n    float brdf              \t= (g*d*f)/(view_exposure*light_exposure*4.);\n    \n    vec4 c[7];\n    shcday(c);\n    \n  \n    \n    //ambient light\n    vec3 ambient\t    = sphericalharmonic(normalize(r.normal + (occlusions * .0125 - .0625)), c);\n    ambient                 = clamp(mix(m.color*ambient, ambient, distance_fog), 0., 1.);\n    \n    vec3 diffuse\t    = m.color * l.color * light_exposure * n;\n    vec3 specular\t    = mix(m.color, ambient, .25) * brdf;\n    \n    //compositing\n    vec3 color              = vec3(.125 + light_exposure) * (1.-distance_fog) * diffuse + specular;// + ambient * occlusions;\n    color                   *= min(.125, occlusions * shadows) + ambient * .25;\n    color                   += (distance_fog) * step_fog + step_fog;\n    color                   = error ? vec3(1., 0., 0.) : color;\n\t\n    if(r.range == FARPLANE)\n    {\n        vec3 ambient\t\t= 32. * sphericalharmonic(value_noise(r.position.xz*.5+r.position.y*1.)*r.position, c);\n        vec3 color              = vec3(1.-distance_fog) * ambient * .9 + m.color * step_fog * shadows * occlusions + step_fog * m.color + step_fog;\n        \n        return color * 4.;\n    }\n    return color;\n}//sphinx\n\n\nfloat fresnel(in float i, in float ndl)\n{\n    return i + (1.-i) * pow(1.-ndl, 5.0);\n}\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n    ndl             = max(ndl, 0.);\n    ndv             = max(ndv, 0.);\n    float k         = i * sqrt(2./PI);\n    float ik        = 1. - k;\n    return (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\nfloat distribution(in float r, in float ndh)\n{\n    float m     = 2./(r*r) - 1.;\n    return (m+r)*pow(ndh, m)*.5;\n}\n\nfloat shadow(in ray r, in light l)\n{\n    float mint\t= .00125;\n    float maxt\t= 16.;\n    float k \t= 4.;\n    float sh\t= 1.;\n    float t\t\t= mint;\n    float h\t\t= 0.;\n    float m\t\t= 0.;\n    for (int i = 0; i < 16; i++)\n    {\n        if (t > maxt) break;\n        h = map(r.position+l.direction*t);\n        sh = min(sh, mint+k*h/t);\n        t += h;\n    }\n    return clamp(sh, 0., 1.);\n}\n\nfloat occlusion( in vec3 p, in vec3 n )\n{\n    float occ = 0.0;\n    float sca = .25;\n    for ( int i=0; i < 8; i++ )\n    {\n        float hr = sca * float(i)/4.0;\n        float dd = map(n * hr + p);\n        occ += -(dd-hr)*sca;\n        sca *= 0.99;\n    }\n    return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );\n}\n\nvec3 hsv(in float h, in float s, in float v){\n    return mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nvec3 sphericalharmonic(vec3 n, in vec4 c[7])\n{\n    vec4 p = vec4(n, 1.);\n    \n    vec3 l1 = vec3(0.);\n    l1.r = dot(c[0], p);\n    l1.g = dot(c[1], p);\n    l1.b = dot(c[2], p);\n    \n    vec4 m2 = p.xyzz * p.yzzx;\n    vec3 l2 = vec3(0.);\n    l2.r = dot(c[3], m2);\n    l2.g = dot(c[4], m2);\n    l2.b = dot(c[5], m2);\n    \n    float m3 = p.x*p.x - p.y*p.y;\n    vec3 l3 = vec3(0.);\n    l3 = c[6].xyz * m3;\n    \n    vec3 sh = vec3(l1 + l2 + l3);\n    \n    return clamp(sh, 0., 1.);\n}\n\nvoid shcday(out vec4 c[7])\n{\n    c[0] = vec4(0.0, 0.5, 0.0, 0.4);\n    c[1] = vec4(0.0, 0.3, .05, .45);\n    c[2] = vec4(0.0, 0.3, -.3, .85);\n    c[3] = vec4(0.0, 0.2, 0.1, 0.0);\n    c[4] = vec4(0.0, 0.2, 0.1, 0.0);\n    c[5] = vec4(0.1, 0.1, 0.1, 0.0);\n    c[6] = vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec3 flare(in ray r, in light l)\n{\n    if(distance(r.origin, r.position)<distance(r.origin, l.position)-r.range*.125) return vec3(0.);\n    vec3 position \t= r.origin + r.direction * clamp(dot(l.position - r.origin, r.direction), 0., 32.);//r.epsilon*FARPLANE);\n    float range \t= length(position - l.position);\n    return clamp(l.color * 0.0125/ (range * range), .0, 1.);\n}\n\nvec3 derive(const in vec3 position, const in float epsilon)\n{\n    vec2 offset = vec2(epsilon, -epsilon);\n    vec4 simplex = vec4(0.);\n    simplex.x = map(position + offset.xyy);\n    simplex.y = map(position + offset.yyx);\n    simplex.z = map(position + offset.yxy );\n    simplex.w = map(position + offset.xxx);\n    \n    vec3 normal = offset.xyy * simplex.x + offset.yyx * simplex.y + offset.yxy * simplex.z + offset.xxx * simplex.w;\n    return normalize(normal);\n}\n\nvec2 format(vec2 uv)\n{\n    uv = uv * 2. - 1.;\n    uv.x *= resolution.x/resolution.y;\n    return uv;\n}\n\nray view(in vec2 uv)\n{\n    uv              = format(uv);\n    \n    vec3 w          = normalize(DIRECTION);\n    vec3 u          = normalize(cross(w,vec3(0.,1.,0.)));\n    vec3 v          = normalize(cross(u,w));\n    \n    ray r           = ray(vec3(0.), vec3(0.), vec3(0.), vec3(0.), 0., 0., 0.);\n    r.origin        = POSITION;\n    r.origin.xz      += time*.00001;\n\n    float dist      = map(r.origin);\n    r.origin.y\t    = dist < 0. ? r.origin.y + abs(dist) : r.origin.y;\n    \n\t\n     g_position     = r.origin;\t\n\t\n    r.position      = r.origin;\n    r.direction     = normalize(uv.x*u + uv.y*v + FOV*w);;\n    r.range         = PHI;\n    r.steps         = 0.;\n    \n    return r;\n}\n\nray emit(ray r)\n{\n    float total_range   = 0.;\n    float threshold     = PHI;\n    float dither        = hash(r.position.y+r.direction.x+r.direction.y)*.125+.25;\n    float function_sign = 1.;\n    if(map(r.origin) < 0.0) function_sign = -1.0;\n    for(int i = 0; i < ITERATIONS; i++)\n    {\n        r.steps += dither;\n        if(total_range < FARPLANE)\n        {\n            if(abs(r.range) < threshold)\n            {\n                break;\n            }\n            \n            threshold\t*= 1.02;\n            \n            r.position\t+= r.direction * r.range * .75;\n            \n            r.range\t\t= map(r.position) * function_sign;\n            \n            if(r.range < 0.)\n            {\n                r.range -= threshold * 4.;\n                threshold *= float(i);\n//                error = true;\n                break;\n            }\n            \n            total_range += r.range;\n        }\n        else\n        {\n            break;\n        }\n    }\n    \n    if(r.range < threshold)\n    {\n        r.range = total_range;\n    }\n    else\n    {\n        r.range     = FARPLANE;\n        r.position  = r.direction * FARPLANE;\n    }\n    \n    return r;\n}\n\n//simple hash function - high bitwise entropy in the uv domain\nfloat hash(float v)\n{\n    return fract(fract(v*9876.5432)*(v+v)*12345.678);\n}\n\nvec3 hash(vec3 v)\t\n{\n    return vec3(hash(v.x), hash(v.y), hash(v.z));\n}\n\nmat2 rmat(in float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}", "user": "2bc4d76", "parent": null, "id": "26462.0"}