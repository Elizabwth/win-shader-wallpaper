{"code": "/// open for ideas....  @Harley\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float EPSILON = 0.00005;\n\nstruct Camera\n{\n\tvec3 position;\n\tvec3 dir;\n\tvec3 up;\n\tvec3 rayDir;\n};\n\nstruct MapResult\n{\n\tfloat dist;\n\tvec3 color;\n};\n\t\nstruct MarchResult\n{\n\tvec3 position;\n\tfloat dist;\n\tvec3 color;\n};\n\nfloat smoothcurve(float f) {\n\treturn 0.5*(1.0+cos(3.14*f));\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s, 0.0,\n\t\t    oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n\t\t    oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c, 0.0,\n\t\t    0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 opCheapBend(vec3 p, float x, float y)\n{\n    float c = cos(x*p.y);\n    float s = sin(y*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nvec3 opTwist(vec3 p, float x, float y)\n{\n    float c = cos(x*p.y);\n    float s = sin(y*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nMapResult map_cube(vec3 position)\n{\n\tMapResult result;\n\tresult.color = vec3(1.0, 0.5, 0.2);\n\t\n\tfloat cube = length(max(abs(position) - vec3(1.2), 0.0)) - 0.1;\n\tfloat sphere = length(position) - 1.6;\n\t\n\tfloat d = max(cube, -sphere);\n\t\t\n\tresult.dist = d;\n\treturn result;\n}\n\nMapResult map_torus(vec3 position)\n{\n\tMapResult result;\n\tresult.color = vec3(0.0, 0.5, 0.8);\n\t\n\tposition = (rotationMatrix(vec3(0,0,1), time) * vec4(position, 1.0)).xyz;\n\tposition = (rotationMatrix(vec3(0,1,0), time) * vec4(position, 1.0)).xyz;\n\tposition = (rotationMatrix(vec3(1,0,0), time) * vec4(position, 1.0)).xyz;\n\t\n\tvec2 q = vec2(length(position.xz) - 2.5, position.y);\n\tresult.dist = length(q) - 0.2;\n\t\t\n\treturn result;\n}\n\nMapResult map(vec3 position)\n{\n\tfloat c = 10.0;\n\t//position = mod(position, vec3(c)) - c*0.5;\n\t\n\tMapResult result;\n\t\n\tMapResult torus = map_torus(position);\n\tMapResult cube = map_cube(position);\n\t\n\tif(torus.dist < cube.dist)\n\t{\n\t\tresult = torus;\n\t}\n\telse\n\t{\n\t\tresult = cube;\n\t}\n\t\n\treturn result;\n}\n\nvec3 getColor(const in Camera cam, const in vec3 position, const in float dist, const in vec3 color)\n{\t\n\tvec3 eps = vec3(EPSILON, 0, 0);\n\t\n\tvec3 normal=normalize(\n\t\t   vec3(dist - map(position-eps.xyy).dist,\n\t\t\tdist - map(position-eps.yxy).dist,\n\t\t\tdist - map(position-eps.yyx).dist));\n\t\n\tfloat lambert = dot(normal, -cam.rayDir);\n\t\n\treturn lambert * color;\n}\n\nMarchResult raymarch(const in Camera cam)\n{\n\tMarchResult result;\n\tresult.color = vec3(0);\n\t\n\tconst int MAX_ITERATIONS = 128;\n\tconst float MAX_DEPTH = 52.0;\n\t\n\tfloat depth = 0.0;\n\tMapResult mapping;\n\tfor(int i = 0; i < MAX_ITERATIONS; ++i)\n\t{\n\t\tresult.position = cam.position + cam.rayDir * depth;\n\t\tmapping = map(result.position);\n\t\t\n\t\tif(mapping.dist <= EPSILON)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdepth += mapping.dist;\n\t\t\t\t\n\t\tif(depth > MAX_DEPTH)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tresult.dist = mapping.dist;\n\t\n\tif(depth < MAX_DEPTH)\n\t\tresult.color = getColor(cam, result.position, result.dist, mapping.color);\n\n\t\n\t// ray intersection for beam\n\tvec3 minimum = vec3(-10000, -1, -1);\n\tvec3 maximum = vec3(10000, 1, 1);\n\t\n\tvec3 OMIN = ( minimum - cam.position ) / cam.rayDir;\n\tvec3 OMAX = ( maximum - cam.position ) / cam.rayDir;\n\t\t\n\tvec3 MAX = max ( OMAX, OMIN );\n\tvec3 MIN = min ( OMAX, OMIN );\n\tfloat final = min ( MAX.x, min ( MAX.y, MAX.z ) );\n\tfloat start = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) ); \n\t\n\tif(final > start)\n\t{\n\t\tresult.color = mix(result.color, vec3(0.2, 0.4, 0.9), max(final-start, 0.0));\t\n\t}\n\t\n\treturn result;\n}\n\t\nCamera getCamera()\n{\n\tCamera cam;\n  \tcam.dir = vec3(0,0,0);\n\tfloat t = (time+1.0) * 0.15;\n\tcam.position = vec3(sin(t + 1.0)*4.0, 4, cos(t)*4.0);\n\tcam.up = vec3(0,1,0);\n  \tvec3 forward = normalize(cam.dir - cam.position);\n  \tvec3 left = cross(forward, cam.up);\n \tcam.up = cross(left, forward);\n \n\tvec3 screenOrigin = (cam.position+forward);\n\tvec2 screenPos = 2.0*gl_FragCoord.xy/resolution.xy - 1.0;\n \tfloat screenAspectRatio = resolution.x/resolution.y;\n\tvec3 screenHit = screenOrigin + screenPos.x * left * screenAspectRatio + screenPos.y * cam.up;\n  \n\tcam.rayDir = normalize(screenHit-cam.position);\n\treturn cam;\n}\n\nvoid main() \n{\t\n\tCamera cam = getCamera();\n\tMarchResult result = raymarch(cam);\n\t\t\n\tvec3 color = result.color; //getColor(cam, result);\n\t\n\tgl_FragColor = vec4(color, 1.0);\n}", "user": "ce1428b", "parent": null, "id": "34109.0"}