{"code": "\n//---------------------------------------------------------\n// Shader:   Bacterium.glsl                      12/2014\n//           Created by Vinicius Graciano Santos - vgs \n// original: https://www.shadertoy.com/view/MdBSDt\n// tags:     raymarch, antialiasing, antialias, bacteria\n//---------------------------------------------------------\n\n#ifdef GL_ES\n  precision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//---------------------------------------------------------\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.))\n                                , tri(p.z+tri(p.x*1.))\n                                , tri(p.y+tri(p.x*1.)));}\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n    float rz = 0.;\n    vec3 bp = p;\n    for (float i=0.; i<= .2; i++ )\n    {\n        vec3 dg = tri3(bp);\n        p += (dg);\n        bp *= 2.;\n\tz *= 1.5;\n\tp *= 1.3;\n        rz += (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n    }\n    return rz;\n}\n//---------------------------------------------------------\n// This shader needs some serious work on collision avoidance :D\n\n#define STEPS 66\n#define EPS 0.002\n#define FAR 18.0\n#define PI 3.14159265359\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(b-a)/k, 0.0, 1.0 );\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvec2 rep(vec2 p) {\n    float a = atan(p.y, p.x);\n    a = mod(a, 2.0*PI/18.) - PI/18.;\n    return length(p)*vec2(cos(a), sin(a));\n}\n\nfloat spikedBall(vec3 p) {\n    p = mod(p, 8.0) - 4.0;\n    float d = length(p) - 1.2;\n    p.xz = rep(p.xz); p.xy = rep(p.xy); \n    return smin(d, length(p.yz)-.1+abs(.15*(p.x-1.0)), 0.1);\n}\n\nfloat capsules(vec3 p) {\n    vec3 q = floor(p/4.0);\n    p = mod(p, 4.0) - 2.0;\n    p.yz = p.yz*cos(time + q.z) + vec2(-p.z, p.y)*sin(time + q.z);\n    p.xy = p.xy*cos(time + q.x) + vec2(-p.y, p.x)*sin(time + q.x);\n    p.zx = p.zx*cos(time + q.y) + vec2(-p.x, p.z)*sin(time + q.y);\n    \n    float angle = .3*cos(time)*p.x;\n    p.xy = cos(angle)*p.xy + sin(angle)*vec2(-p.y, p.x); p.x += 1.0; \n    float k = clamp(2.0*p.x/4.0, 0.0, 1.0); p.x -= 2.*k;\n    return length(p) - .5;\n}\n\nfloat map(vec3 p) {   \n   return min(spikedBall(p), capsules(p));\n}\n\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0.0, EPS);\n    return normalize(vec3(map(p + q.yxx) - map(p - q.yxx),\n                          map(p + q.xyx) - map(p - q.xyx),\n                          map(p + q.xxy) - map(p - q.xxy)));\n}\n\nfloat cubeMap(vec3 p, vec3 n) {\n    float a = triNoise3d(p*2.0);\n    n = abs(n);\n    return (a*n.x + 2.0*a*n.y + a*n.z) / (n.x+n.y+n.z);   \n}\n\nvec3 bumpMap(vec3 p, vec3 n, float c) {\n    vec2 q = vec2(0.0, .5);\n\tvec3 grad = -1.0*(vec3(cubeMap(p+q.yxx, n), cubeMap(p+q.xyx, n), cubeMap(p+q.xxy, n))-c)/q.y;\n    vec3 t = grad - n*dot(grad, n);\n    return normalize(n - t);\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + t*rd, n = normal(p);\n   \n    vec3 green = pow(vec3(93,102,89)/255., vec3(2.2));\n    vec3 yellow = pow(vec3(255,204,0)/255., vec3(2.2));\n    \n    float k = cubeMap(.5*p, n);\n    n = bumpMap(.5*p, n, k);\n    \n    vec3 col = mix(green, yellow, k)*(1.0-dot(-rd,n));\n    if (spikedBall(p) < capsules(p)) {\n    \tp = mod(p, 8.0) - 4.0;\n        col *= 1.0/(1.0 + .5*dot(p, p));\n    }\n        \n    return col*exp(-.008*t*t);\n}\n\nmat3 lookat(vec3 p, vec3 t) {\n    vec3 z = normalize(p - t);\n    vec3 x = cross(z, vec3(0.0, 1.0, 0.0));\n    return mat3(x, cross(x, z), z);\n}\n\nvoid main() \n{\n    vec2 uv = (-resolution.xy + 2.0*gl_FragCoord.xy) / resolution.y;\n    uv *= 1.0 + .1*dot(uv,uv);\n    \n    vec3 ro = vec3(time, time, cos(time));\n    vec3 rd = normalize(lookat(ro, ro+vec3(cos(.1*time), sin(.1*time), 1.0))*vec3(uv, -1.0)); // dire\u00e7\u00e3o do raio.\n    \n    // based on eiffie's antialiasing method (https://www.shadertoy.com/view/XsSXDt)\n    vec3 col = vec3(0.0);\n    vec4 stack = vec4(-1.0); bool grab = true;\n    float t = 0.0, d = EPS, od = d, pix = 4.0/resolution.x, w = 1.8, s = 0.0;\n    for (int i = 0; i < STEPS; ++i)\n    {\n        d = map(ro + t*rd);\n        if (w > 1.0 && (od + d < s)) \n        {\n            s -= w*s; w = 1.0;\n        } \n\t\telse \n\t\t{\n            s = d * w;   \n            if (d <= od) grab = true;\n            else if (grab && stack.w < 0. && od < pix*(t-od)) \n\t\t    {\n\t\t        stack.w = t-od; \n\t\t        stack = stack.wxyz; \n\t\t        grab = false;\n            }\n            if (d < EPS || t > FAR) break;\n        }\n        od = d; t += s; \n    }\n    col = d < EPS ? shade(ro, rd, t) : col;\n    \n    for (int i = 0; i < 4; ++i) \n\t{\n        if (stack[i] < 0.0) break;\n        d = map(ro + stack[i]*rd);\n        col = mix(shade(ro, rd, stack[i]), col, clamp(d/(pix*stack[i]), 0.0, 1.0));\n    }\n    col = smoothstep(0., .7, col);\n    col = pow(col, vec3(1.0/2.2));\n    \n    gl_FragColor = vec4(col,1.0);\n}", "user": "ecf8e5e", "parent": "/e#36867.0", "id": "36887.0"}