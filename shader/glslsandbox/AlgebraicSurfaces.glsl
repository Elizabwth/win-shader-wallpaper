{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n/*\nRaytracer for algebraic surfaces (maximal cubic)\nby Aaron Montag\nIdea from RealSurf (http://realsurf.informatik.uni-halle.de/)\n*/\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nconst float R = 4.;\nconst float oo = 1000.;\n\nconst int IT = 10;\n\nfloat F(vec3 v, float alpha) {\n  float x = v.x;\n  float y = v.y;\n  float z = v.z;\n  float s = x+y+z+1.;\n  return x*x+y*y+z*z+alpha*x*y*z-1.;\n\t\n\t//also nice:\n\t//alpha = .5+mouse.y;\n        //return 4.*(x*x*x+y*y*y+z*z*z+1.)-alpha*s*s*s;\n\t//change dF accordingly: \n\t\n}\n\nvec3 dF(vec3 v, float alpha) {\n  float x = v.x;\n  float y = v.y;\n  float z = v.z;\n\tfloat s = x+y+z+1.;\n  /*\nfor F = 4.*(x*x*x+y*y*y+z*z*z+1.)-alpha*s*s*s\nreturn vec3(\n    12.*x*x-3.*alpha*s*s,\n    12.*y*y-3.*alpha*s*s,\n    12.*z*z-3.*alpha*s*s\n  );*/\n\treturn vec3(\n\t    2.*x+alpha*y*z,\n\t    2.*y+alpha*x*z,\n\t    2.*z+alpha*x*y\n\t  );\n}\n\nfloat SR(vec3 v) {\n  return dot(v,v)-R*R;  \n}\n\nvec3 ray(vec2 pos, float t) {\n  float th = time*.2-4.*mouse.x;\n  float phi = time*.1321+3.*mouse.y;\n  return \n    mat3(\n      vec3(cos(th),0.,sin(th)),\n      vec3(0.,1.,0.),\n      vec3(-sin(th),0.,cos(th))\n    )*\n    (\n    mat3(\n      vec3(1.,0,0.),\n      vec3(0,cos(phi),sin(phi)),\n      vec3(0,-sin(phi),cos(phi))\n    )  \n    *(vec3(pos,1.)*t+vec3(mouse-vec2(.5),-18.)));\n}\n\n  \n\n\nfloat eval(vec4 poly, float t) {\n  return (((poly[3])*t+poly[2])*t+poly[1])*t+poly[0]; //horner scheme\n}\n\n\n\nvec4 d(vec4 p) {\n  vec4 r = vec4(0.);\n  for(int i=0; i<3; i++) {\n    r[i] = p[i+1]*float(i+1);  \n  }\n  return r;\n}\n\n\nfloat bisect(vec4 p, float l, float u, float def) {\n  if(l==u) return def;\n  float lv = eval(p, l);\n  float uv = eval(p, u);\n  if(lv*uv>=0.) return def;\n  \n  float m, mv;\n  for(int i=0; i<IT; i++) {\n    m = (l+u)/2.;\n    mv = eval(p, m);\n    if(lv*mv>0.) {\n      l = m;\n      //lv = mv;\n    } else {\n      u = m;\n      //bv = cv; //nobody cares\n    }\n  }\n  return m;\n}\n\nfloat firstroot(vec4 poly, float l, float u) { //finds first root of poly in interval [l, u]\n  vec4 p[4];//derivatives\n  p[3] = poly; //deg 3\n  for(int i=2; i>=1; i--) {\n    p[i] = d(p[i+1]);  \n  }\n  vec4 roots = vec4(u); //always consider u as root\n  vec4 oroots = vec4(u);\n  for(int i=1; i<4; i++) { //i: degree\n    roots[0] = bisect(p[i], l, oroots[0], l);\n    for(int j=1; j<4; j++) { if(j<i)\n      roots[j] = bisect(p[i], oroots[j-1], oroots[j],roots[j-1]);\n    }\n    oroots = roots;\n  }\n  for(int i=0; i<4; i++) {\n    if(roots[i]!=l && roots[i]!=u) return roots[i];\n    //if(abs(eval(poly,roots[i]))<.01) return roots[i];\n  }\n  return oo;\n}\n\n\nmat4 A = mat4( //polynomial interpolation for basepoints 0, 5, 10, 15 (better use chebyshev nodes)\nvec4(  1.000000000000000, -0.366666666666667,  0.040000000000000, -0.001333333333333),\nvec4( -0.000000000000000,  0.600000000000000, -0.100000000000000,  0.004000000000000),\nvec4(  0.000000000000000, -0.300000000000000,  0.080000000000000, -0.004000000000000),\nvec4( -0.000000000000000,  0.066666666666667, -0.020000000000000,  0.001333333333333)\n);\n//octave: inv(fliplr(vander([0,5,10,15])))'\n\n\nvoid main( void ) {\n\n  float alpha = 2.3+.35*sin(time);\n  vec2 pos = ( gl_FragCoord.xy / resolution.xy ) -vec2(.5);\n  pos.y *= resolution.y/resolution.x;\n  \n  vec4 vals;\n  vec4 rvals;\n  for(int i=0; i<4; i++) {\n    vec3 p = ray(pos, 5.*float(i));\n    vals[i] = F(p, alpha);\n    rvals[i] = SR(p);\n  }\n  \n  vec4 poly = A*vals;//interpolate\n  vec4 rpoly = A*rvals; \n  \n  //rpoly is quadratic\n  float D = (rpoly[1]*rpoly[1])-4.*rpoly[2]*rpoly[0]; \n  \n  float froot = oo;\n  if(D>=0.) \n    froot = firstroot(poly, max(0.,(-rpoly[1]-sqrt(D))/(2.*rpoly[2])), max(0.,(-rpoly[1]+sqrt(D))/(2.*rpoly[2])));\n\n  gl_FragColor = vec4(.8);\n  \n  if(froot != oo) {\n    vec3 n = normalize(dF(ray(pos,froot), alpha));\n    \n    \n    vec3 l[5]; //position of light\n    vec3 c[5]; //color of light\n    l[0] = -vec3(-1.,1.,0.);\n    l[1] = -vec3(0.,-1.,1.);\n    l[2] = -vec3(1.,0.,-1.);\n    l[3] = -ray(vec2(.0,.0),-10.);\n    l[4] = ray(vec2(.0,.0),-10.);\n    \n    c[0] = vec3(1.,.6,.3)*.6;\n    c[1] = vec3(.3,1.,.6)*.6;\n    c[2] = vec3(.6,.3,1.)*.6;\n    c[3] = vec3(.9,.3,.0);\n    c[4] = vec3(0.,.8,.8);\n    \n    \n    gl_FragColor = vec4(0.,0.,0.,1.);\n    \n    for(int i=0; i<5; i++) {\n      float illumination = max(0.,dot(normalize(l[i]),n));\n      gl_FragColor.rgb += illumination*illumination*c[i];\n    }\n  } \n}\n", "user": "3999dcd", "parent": null, "id": "26575.13"}