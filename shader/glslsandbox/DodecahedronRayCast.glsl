{"code": "// Ray Marching\n// the.savage@hotmail.co.uk\n\n// Some mods by @emackey: Pan and zoom with the mouse.\n\n#ifdef GL_ES\nprecision highp float;\n#endif // GL_ES\n\n// Definitions\n\n// #define CUBEFIELD\n// #define SPONGE\n// #define SIERPINSKI\n// #define MANDELBULB\n// #define MANDELBOX\n #define DODECAHEDRON\n// #define KNOT\n// #define QUATERNION\n\n// #define OCCLUSION\n#define SHADOW\n// #define REFLECTION\n// #define ANTIALIAS\n\n#define MAX_STEPS\t255\n#define MAX_ITTERS\t20\n#define MAX_OCCLUSION\t10\n#define MAX_ALIAS\t3\n\n// Constants\n\nconst float PI=3.14159;\nconst float EPSILON=6e-7;\nconst float BAILOUT=4.0;\n\n// Uniforms\n\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nuniform float time;\n\nuniform vec2 surfaceSize;\nvarying vec2 surfacePosition;\n\n// Would-be uniforms\n\nvec3 u_vCamera=vec3(0.0001);\nvec3 u_vObject=vec3(0.0);\nvec3 u_vLight=vec3(-125.0);\n\nmat3 u_mCamera=mat3(\n\t1.0,0.0,0.0,\n\t0.0,1.0,0.0,\n\t0.0,0.0,1.0);\n\nmat3 u_mObject=mat3(\n\t1.0,0.0,0.0,\n\t0.0,1.0,0.0,\n\t0.0,0.0,1.0);\n\nmat3 u_mLight=mat3(\n\t1.0,0.0,0.0,\n\t0.0,1.0,0.0,\n\t0.0,0.0,1.0);\n\nfloat u_fPower=0.2;\nvec3 u_vJulia=vec3(0.0);\nvec3 u_vOffset=vec3(0.0);\nvec3 u_vClamp=vec3(0.0);\nfloat u_fBounds=120.0;\n\n#define u_fDetail (0.0008 * resolution.y / (surfaceSize.y))\nfloat u_fSmooth=0.5;\nfloat u_fDither=0.0;\nint u_nAlias=0;\n\nconst vec3 u_cAmbient=vec3(1.0,1.0,1.0);\nconst vec3 u_cDiffuse=vec3(0.0,0.6,0.7);\nconst vec3 u_cColour1=vec3(0.8,0.6,0.1);\nconst vec3 u_cColour2=vec3(0.3,0.2,0.3);\nconst vec3 u_cInnerGlow=vec3(1.0,0.0,0.0);\nconst vec3 u_cOuterGlow=vec3(0.0,0.0,0.0);\nconst vec3 u_cLight=vec3(1.0,0.9,0.7);\nconst vec3 u_cShadow=vec3(0.0,0.0,0.0);\nconst vec3 u_cBackground=vec3(0.6,0.8,0.7);\n\nconst float u_fAmbient=0.0;\nconst float u_fDiffuse=1.0;\nconst float u_fColour1=0.5;\nconst float u_fColour2=0.5;\nconst float u_fInnerGlow=0.0;\nconst float u_fOuterGlow=0.0;\nconst float u_fLight=0.3;\nconst float u_fShadow=0.5;\nconst float u_fBackground=1.0;\n\nconst int u_nColouring=4;\n\nconst float u_fOcclusion=3.0;\nconst float u_fEnhance=0.0;\nconst float u_fShininess=1.5;\nconst float u_fHardness=4.0;\nconst float u_fReflection=0.0;\nconst float u_fSoftShadow=10.0;\nconst float u_fBacklight=0.0;\nconst float u_fFog=0.0;\nconst float u_fFalloff=0.0;\n\nconst float fNormalDetail=1.0;\nconst float fShadowDetail=2.0;\n\nconst bool u_bBounds=false;\n\n// Local data\n\n#define u_fWidth resolution.x\n#define u_fHeight resolution.y\n#define u_fRatio (u_fWidth/u_fHeight)\n#define u_fScale (1.0/min(u_fWidth,u_fHeight))\n\nfloat fMinDist=100000.0;\nfloat fOrbitTrap=0.0;\n\n// Local functions\n\n// rand\n// Call to generate random number\n\nfloat rand(const vec2 vSeed)\n{\n\tconst vec2 vR1=vec2(12.9898,78.233);\n\tconst float fR1=43758.5453;\n\n\treturn fract(sin(dot(vSeed,vR1))*fR1);\n}\n\n// rand3\n// Call to generate random vector\n\nvec3 rand3(const vec2 vSeed)\n{\n\tconst vec2 vR1=vec2(12.9898,78.233);\n\tconst vec2 vR2=vec2(4.898,7.23);\n\tconst vec2 vR3=vec2(0.23,1.111);\n\n\tconst float fR1=43758.5453;\n\tconst float fR2=23421.631;\n\tconst float fR3=392820.23;\n\n\treturn vec3(\n\t\tfract(sin(dot(vSeed,vR1))*fR1),\n\t\tfract(sin(dot(vSeed,vR2))*fR2),\n\t\tfract(sin(dot(vSeed,vR3))*fR3));\n}\n\n// deCubefield\n// Call to get distance to cubefield\n\n#ifdef CUBEFIELD\nfloat deCubefield(vec3 vRay)\n{\n\tvec3 v=abs(vRay-(floor(vRay)+u_vOffset))*u_vClamp;\n\tfloat r=max(max(v.x,v.y),v.z)-u_fPower;\n\n\tif(r<fMinDist) fMinDist=r;\n\tif(u_nColouring>0) fOrbitTrap=dot(v,v);\n\n\treturn r;\n}\n#endif // CUBEFIELD\n\n// deSponge\n// Call to get distance to menger sponge\n\n#ifdef SPONGE\nfloat deSponge(vec3 vRay)\n{\n\tint nSteps=int(u_fPower);\n\n\tvec3 c=(vRay*0.5)+0.5;\n\tvec3 v=abs(c-0.5)-0.5;\n\n\tfloat m=u_vClamp.x;\n\tfloat r=max(v.x,max(v.y,v.z));\n\n\tif(r<fMinDist) fMinDist=r;\n\n\tfor(int n=1;n<6;n++)\n\t{\n\t\tif(n>nSteps) break;\n\n\t\tm*=u_vClamp.y;\n\t\tv=(0.5-abs(mod(c*m,u_vClamp.z)-1.5))+u_vOffset;\n\t\tr=max(r,min(max(v.x,v.z),min(max(v.x,v.y),max(v.y,v.z)))/m);\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=dot(v,v);\n\t}\n\treturn r*2.0;\n}\n#endif // SPONGE\n\n// deSierpinski\n// Call to get distance to sierpinski gasket\n\n#ifdef SIERPINSKI\nfloat deSierpinski(vec3 vRay)\n{\n\tvec3 a1=u_vOffset;\n\tvec3 a2=vec3(-a1.x,-a1.y,a1.z);\n\tvec3 a3=vec3(a1.x,-a1.y,-a1.z);\n\tvec3 a4=vec3(-a1.x,a1.y,-a1.z);\n\n\tvec3 v=vRay;\n\tvec3 c;\n\n\tfloat r;\n\tfloat d;\n\n\tint nStep=0;\n\n\tfor(int n=1;n<=MAX_ITTERS;n++)\n\t{\n\t\tnStep=n-1;\n\n\t\tc=a1;\n\t\tr=length(v-a1);\n\n\t\td=length(v-a2);\n\t\tif(d<r) {c=a2; r=d;}\n\n\t\td=length(v-a3);\n\t\tif(d<r) {c=a3; r=d;}\n\n\t\td=length(v-a4);\n\t\tif(d<r) {c=a4; r=d;}\n\n\t\tv=u_fPower*v-c*u_vClamp;\n\t\tr=length(v);\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=dot(v,v);\n\t}\n\treturn length(v)*pow(u_fPower,float(-nStep));\n}\n#endif // SIERPINSKI\n\n// deMandelbulb\n// Call to get distance to mandelbulb\n\n#ifdef MANDELBULB\nfloat deMandelbulb(vec3 vRay)\n{\n\tvec3 v=vRay;\n\tvec3 c=(u_vJulia!=vec3(0.0))?u_vJulia:v;\n\n\tfloat r=0.0;\n\tfloat d=1.0;\n\n\tfor(int n=1;n<=MAX_ITTERS;n++)\n\t{\n\t\tr=length(v);\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=0.33*log(dot(v,v))+1.0;\n\n\t\tif(r>BAILOUT) break;\n\n\t\tfloat theta=acos(v.z/r);\n\t\tfloat phi=atan(v.y,v.x);\n\t\td=pow(r,u_fPower-1.0)*u_fPower*d+1.0;\n\n\t\tfloat zr=pow(r,u_fPower);\n\t\ttheta=theta*u_fPower;\n\t\tphi=phi*u_fPower;\n\n\t\tv=(vec3(sin(theta)*cos(phi),sin(phi)*sin(theta),cos(theta))*zr)+c;\n\n\t\tif(u_vClamp.x!=0.0) v.x=max(v.x,u_vClamp.x);\n\t\tif(u_vClamp.y!=0.0) v.y=max(v.y,u_vClamp.y);\n\t\tif(u_vClamp.z!=0.0) v.z=max(v.z,u_vClamp.z);\n\n\t\tv+=u_vOffset;\n\t}\n\treturn 0.5*log(r)*r/d;\n}\n#endif // MANDELBULB\n\n// deMandelbox\n// Call to get distance to mandelbox\n\n#ifdef MANDELBOX\nfloat deMandelbox(vec3 vRay)\n{\n\tvec4 v=vec4(vRay,1.0);\n\tvec4 c=(u_vJulia!=vec3(0.0))?vec4(u_vJulia,1.0):v;\n\n\tvec3 vOffset=u_vOffset*2.0;\n\tvec3 vNegOffset=-u_vOffset;\n\n\tfloat m=u_vClamp.x*u_vClamp.x;\n\tfloat f=u_vClamp.y*m;\n\n\tvec4 sv=vec4(u_fPower,u_fPower,u_fPower,abs(u_fPower))/m;\n\n\tfor(int n=1;n<=MAX_ITTERS;n++)\n\t{\n\t\tv.xyz=(clamp(v.xyz,vNegOffset,u_vOffset)*vOffset)-v.xyz;\n\n\t\tfloat r=dot(v.xyz,v.xyz);\n\t\tv=((v*clamp(max(f/r,m),0.0,1.0))*sv)+c;\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=log(dot(v.xyz,v.xyz))+1.0;\n\t}\n\treturn (length(v.xyz)-abs(u_fPower-1.0))/v.w-pow(abs(u_fPower),float(1-MAX_ITTERS));\n}\n#endif // MANDELBOX\n\n// deDodecahedron\n// Call to get distance to docecahedron ifs\n\n#ifdef DODECAHEDRON\nfloat deDodecahedron(vec3 vRay)\n{\n\tfloat fPhi=u_fPower;\n\n\tfloat n1=0.5/fPhi;\n\tfloat n2=1.0/sqrt(pow(fPhi*(1.0+fPhi),2.0)+pow(fPhi*fPhi-1.0,2.0)+pow(1.0+fPhi,2.0));\n\n\tvec3 p1=vec3(fPhi*n1,fPhi*fPhi*n1,n1);\n\tvec3 p2=vec3(fPhi*(1.0+fPhi)*n2,(fPhi*fPhi-1.0)*n2,(1.0+fPhi)*n2);\n\n\tvec3 v=vRay;\n\n\tfloat s1=sin(u_vJulia.x);\n\tfloat c1=cos(u_vJulia.x);\n\n\tfloat s2=sin(u_vJulia.y);\n\tfloat c2=cos(u_vJulia.y);\n\n\tfloat s3=sin(u_vJulia.z);\n\tfloat c3=cos(u_vJulia.z);\n\n\tmat3 rot=mat3(\n\t\tc1*c3+s1*s2*s3,c2*s3,c1*s2*s3-c3*s1,\n\t\tc3*s1*s2-c1*s3,c2*c3,s1*s3+c1*c3*s2,\n\t\tc2*s1,-s2,c1*c2);\n\n\tfloat t;\n\tfloat r=length(v);\n\n\tif(r<fMinDist) fMinDist=r;\n\n\tint nStep=0;\n\n\tfor(int n=1;n<=MAX_ITTERS;n++)\n\t{\n\t\tnStep=n-1;\n\n\t\tif(r>BAILOUT) break;\n\n\t\tv=abs(v*rot)+u_vOffset;\n\n\t\tt=p1.y*v.x+p1.z*v.y-p1.x*v.z;\n\t\tif(t<0.0) v+=vec3(-2.0,-2.0,2.0)*t*p1.yzx;\n\n\t\tt=-p1.x*v.x+p1.y*v.y+p1.z*v.z;\n\t\tif(t<0.0) v+=vec3(2.0,-2.0,-2.0)*t*p1.xyz;\n\n\t\tt=p1.z*v.x-p1.x*v.y+p1.y*v.z;\n\t\tif(t<0.0) v+=vec3(-2.0,2.0,-2.0)*t*p1.zxy;\n\n\t\tt=-p2.x*v.x+p2.y*v.y+p2.z*v.z;\n\t\tif(t<0.0) v+=vec3(2.0,-2.0,-2.0)*t*p2.xyz;\n\n\t\tt=p2.z*v.x-p2.x*v.y+p2.y*v.z;\n\t\tif(t<0.0) v+=vec3(-2.0,2.0,-2.0)*t*p2.zxy;\n\n\t\tv=v*2.0-u_vClamp;\n\t\tr=length(v);\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=dot(v,v);\n\t}\n\treturn (r-2.0)*pow(2.0,-float(nStep));\n}\n#endif // DODECAHEDRON\n\n// deKnot\n// Call to get distance to knot\n\n#ifdef KNOT\nfloat deKnot(vec3 p)\n{\n\tint nSteps=int(u_fPower);\n\n\tfloat r=length(p.xz);\n\tfloat ang=atan(p.z,p.x);\n\tfloat y=p.y;\n\tfloat d=10000.0;\n\n\tfor(int n=1;n<=MAX_ITTERS;n++)\n\t{\n\t\tif(n>nSteps) break;\n\n\t\tvec3 p=vec3(r,y,ang+2.0*PI*float(n-1));\n\t\tp.x-=u_vOffset.z;\n\n\t\tfloat ra=p.z*u_vClamp.x/u_vClamp.z;\n\t\tfloat raz=p.z*u_vClamp.y/u_vClamp.z;\n\n\t\td=min(d,length(p.xy-vec2(u_vOffset.y*cos(ra)+u_vOffset.z,u_vOffset.y*sin(raz)+u_vOffset.z))-u_vOffset.x);\n\n\t\tif(d<fMinDist) fMinDist=d;\n\t\tif(n==u_nColouring) fOrbitTrap=dot(p,p);\n\t}\n\treturn d;\n}\n#endif // KNOT\n\n// deQuaternion\n// Call to get distance to quaternion\n\n#ifdef QUATERNION\nfloat deQuaternion(vec3 vRay)\n{\n\tvec4 c=vec4(u_vJulia,u_fPower);\n\n\tvec4 v=vec4(vRay,0.0);\n\tvec4 d=vec4(1.0,0.0,0.0,0.0);\n\n\tfor(int n=1;n<MAX_ITTERS;n++)\n\t{\n\t\td=2.0*vec4(v.x*d.x-dot(v.xzw,d.yzw),v.x*d.yzw+d.x*v.yzw+cross(v.yzw,d.yzw));\n\t\tv=vec4(v.x*v.x-dot(v.yzw,v.yzw),vec3(2.0*v.x*v.yzw))+c;\n\n\t\tfloat r=dot(v,v);\n\n\t\tif(r<fMinDist) fMinDist=r;\n\t\tif(n==u_nColouring) fOrbitTrap=r;\n\n\t\tif(r>10.0) break;\n\t}\n\tfloat r=length(v);\n\treturn 0.5*r*log(r)/length(d);\n}\n#endif // QUATERNION\n\n// rayDistance\n// Call to estimate distance to object\n\nfloat rayDistance(vec3 vRay)\n{\n\t// adjust for rotation\n\tvRay*=u_mObject;\n\n\t// what estimator?\n\t#ifdef CUBEFIELD\n\treturn deCubefield(vRay);\n\t#endif // CUBEFIELD\n\n\t#ifdef SPONGE\n\treturn deSponge(vRay);\n\t#endif // SPONGE\n\n\t#ifdef SIERPINSKI\n\treturn deSierpinski(vRay);\n\t#endif // SIERPINSKI\n\n\t#ifdef MANDELBULB\n\treturn deMandelbulb(vRay);\n\t#endif // MANDELBULB\n\n\t#ifdef MANDELBOX\n\treturn deMandelbox(vRay);\n\t#endif // MANDELBOX\n\n\t#ifdef DODECAHEDRON\n\treturn deDodecahedron(vRay);\n\t#endif // DODECAHEDRON\n\n\t#ifdef KNOT\n\treturn deKnot(vRay);\n\t#endif // KNOT\n\n\t#ifdef QUATERNION\n\treturn deQuaternion(vRay);\n\t#endif // QUATERNION\n\n\treturn 0.0;\n}\n\n// rayIntersec\n// Call to get bounding intersection distances\n\nbool rayIntersec(vec3 vRay,vec3 vDir,out float fMin,out float fMax)\n{\n\t// find discriminant\n\tfloat fRdt=dot(vRay,vDir);\n\tfloat fRdr=dot(vRay,vRay)-u_fBounds;\n\n\tfloat fDisc=(fRdt*fRdt)-fRdr;\n\n\t// ray missed bounds?\n\tif(fDisc<=0.0) return false;\n\n\t// find intersection distances\n\tfDisc=sqrt(fDisc);\n\tfRdt=-fRdt;\n\n\t// may start inside sphere\n\tfMin=max(0.0,fRdt-fDisc);\n\tfMax=fRdt+fDisc;\n\n\treturn true;\n}\n\n// rayNormal\n// Call to get surface normal\n\nvec3 rayNormal(vec3 vRay,float fEps)\n{\n\tvec2 e=vec2(fEps,0.0);\n\n\treturn normalize(vec3(\n\t\trayDistance(vRay+e.xyy)-rayDistance(vRay-e.xyy),\n\t\trayDistance(vRay+e.yxy)-rayDistance(vRay-e.yxy),\n\t\trayDistance(vRay+e.yyx)-rayDistance(vRay-e.yyx)));\n}\n\n// rayOcclusion\n// Call to find occlusion for surface point\n\nfloat rayOcclusion(vec3 vRay,vec3 vDir,float fEps)\n{\n\tfloat fOcclusion=1.0;\n\n\t#ifdef OCCLUSION\n\tfloat fLen=fEps*fShadowDetail;\n\tfloat fStep=1.0/u_fOcclusion;\n\n\tfor(int n=0;n<MAX_OCCLUSION;n++)\n\t{\n\t\tif(n>=int(u_fOcclusion)) break;\n\n\t\tfloat fDist=rayDistance(vRay+vDir*fLen);\n\t\tfOcclusion*=1.0-max(0.0,(fLen-fDist)*fStep/fLen);\n\n\t\tfLen+=fEps*u_fEnhance;\n\t}\n\t#endif // OCCLUSION\n\n\treturn 1.0-fOcclusion;\n}\n\n// rayShadow\n// Call to march ray to light\n\nfloat rayShadow(vec3 vRay,vec3 vDir,vec3 vLight,float fLight,float fEps)\n{\n\tfloat fShadow=1.0;\n\n\t#ifdef SHADOW\n\tfloat fLen=fEps*fShadowDetail;\n\n\tfor(int n=0;n<MAX_STEPS;n++)\n\t{\n\t\tif(fLen>=fLight) break;\n\n\t\tfloat fDist=rayDistance(vRay+(vLight*fLen));\n\t\tif(fDist<fEps) return 1.0;\n\n\t\tif(u_fSoftShadow!=0.0)\n\t\t\tfShadow=min(fShadow,u_fSoftShadow*(fDist/fLen));\n\n\t\tfLen+=fDist;\n\t}\n\t#endif // SHADOW\n\n\treturn 1.0-fShadow;\n}\n\n// raySun\n// Call to calc sun intensity\n\nvec3 raySun(const vec3 vDir,const vec3 vLight)\n{\n\tif(u_fLight>0.0)\n\t\treturn u_cLight*(1.0-clamp(abs(acos(dot(vDir,vLight)/length(vLight)))/u_fLight,0.0,1.0));\n\n\treturn vec3(0.0);\n}\n\n// rayBackground\n// Call to calc background colour\n\nvec3 rayBackground(const vec3 vDir)\n{\n\t// generate background\n\tif(u_fBackground>0.0)\n\t\treturn mix(vec3(0.0),u_cBackground,clamp(abs(vDir.y)*u_fBackground,0.0,1.0));\n\n\treturn u_cBackground;\n}\n\n// rayColour\n// Call to calc ray colour\n\nvec3 rayColour(vec3 vRay,vec3 vDir,vec3 vHit,vec3 vNormal,vec3 vLight,float fLen,int nStep,float fEps,float fDist)\n{\n\t// step back some\n\tvHit-=vDir*(fEps*fShadowDetail);\n\n\t// show hit points?\n\tif(u_fDiffuse<0.0)\n\t\treturn vec3(0.5)+(normalize(vHit)*abs(u_fDiffuse));\n\n\t// diffuse colour\n\tvec3 colour=u_cDiffuse*u_fDiffuse;\n\n\t// add orbit trap colouring\n\tif(u_nColouring>0)\n\t\tcolour=mix(colour,mix(u_cColour1,u_cColour2,fMinDist*u_fColour1),fOrbitTrap*u_fColour2);\n\n\t// ambient light\n\tcolour+=u_cAmbient*u_fAmbient;\n\n\t// get light info\n\tvec3 vToLight=vLight-vHit;\n\tvec3 vHalf=normalize(vToLight);\n\n\tfloat fLight=length(vToLight);\n\tfloat fProd=dot(vNormal,vHalf);\n\n\t// in shadow?\n\tfloat fShadow=0.0;\n\n\tif(u_fShadow!=0.0)\n\t{\n\t\tif(fProd>0.0)\n\t\t{\n\t\t\tfShadow=rayShadow(vHit,vDir,vHalf,fLight,fEps);\n\t\t\tif(u_fSoftShadow==0.0 && fShadow>0.0) fShadow=1.0;\n\t\t}\n\t\telse fShadow=1.0;\n\t}\n\n\t// add phong?\n\tif(u_fHardness!=0.0 && u_fShininess!=0.0 && fProd>0.0)\n\t\tcolour+=vec3(pow(max(fProd,0.0),u_fHardness)*u_fShininess)*(1.0-fShadow);\n\n\t// add backlighting?\n\tif(u_fBacklight!=0.0 && fProd<=0.0)\n\t\tcolour*=abs(fProd)*u_fBacklight;\n\n\t// add light attenuation?\n\t//if(u_fAttenuation!=0.0)\n\t//\tcolour*=1.0-((fLight*fLight)*u_fAttenuation);\n\n\t// add shadow?\n\tif(fShadow!=0.0)\n\t\tcolour=mix(colour,u_cShadow,fShadow*u_fShadow);\n\n\t// add ambient occlusion\n\tif(u_fOcclusion!=0.0)\n\t{\n\t\tfloat fOcclusion=(u_fEnhance==0.0)?\n\t\t\t(float(nStep)/float(MAX_STEPS))*u_fOcclusion:\n\t\t\trayOcclusion(vHit,vNormal,u_fEnhance);\n\n\t\tcolour=mix(colour,vec3(0.0),clamp(fOcclusion,0.0,1.0));\n\t}\n\n\t// add inner glow\n\tif(u_fInnerGlow!=0.0)\n\t\tcolour=mix(colour,u_cInnerGlow,(float(nStep)/float(MAX_STEPS))*u_fInnerGlow);\n\n\t// add fog\n\tif(u_fFog!=0.0)\n\t\tcolour=mix(u_cBackground,colour,exp(-pow(fLen*exp(u_fFalloff),2.0))*u_fFog);\n\n\treturn colour;\n}\n\n// rayMarch\n// Call to march ray into scene\n\nvec3 rayMarch(vec3 vRay,vec3 vDir,out vec3 vHit,out vec3 vNormal)\n{\n\t// reset for reflection\n\tfMinDist=10000.0;\n\tfOrbitTrap=0.0;\n\n\t// setup marching\n\tfloat fMin;\n\tfloat fMax;\n\n\tfloat fDist=0.0;\n\tfloat fLen=0.0;\n\tfloat fEps=EPSILON;\n\n\tbool bHit=false;\n\tbool bInside=false;\n\n\tint nStep=0;\n\n\t// get bounding intersection\n\tif(rayIntersec(vRay,vDir,fMin,fMax))\n\t{\n\t\tfloat fFactor=u_fScale*u_fDetail;\n\n\t\tbInside=true;\n\n\t\t// start at intersection\n\t\tfLen=fMin;\n\n\t\t// dither start point?\n\t\tif(u_fDither!=0.0)\n\t\t\tfLen+=u_fDither*rand(vDir.xy);\n\n\t\t// march ray into scene\n\t\tfor(int n=0;n<MAX_STEPS;n++)\n\t\t{\n\t\t\tnStep=n;\n\n\t\t\t// how far from object?\n\t\t\tvHit=u_vCamera+(vDir*fLen);\n\t\t\tfDist=rayDistance(vHit)*u_fSmooth;\n\n\t\t\t// step to object\n\t\t\tfLen+=fDist;\n\n\t\t\t// out of bounds?\n\t\t\tif(fLen>fMax || fLen<fMin)\n\t\t\t\tbreak;\n\n\t\t\t// ray hit object?\n\t\t\tif(fDist<fEps)\n\t\t\t{\n\t\t\t\tbHit=true;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// adjust eps for distance\n\t\t\tfEps=fLen*fFactor;\n\t\t}\n\t}\n\n\t// get light position\n\tvec3 vLight=u_vLight*u_mLight;\n\tvec3 cColour;\n\n\t// hit object?\n\tif(bHit)\n\t{\n\t\t// get surface normal\n\t\tvNormal=rayNormal(vHit-((fNormalDetail*fEps)*vDir),fEps);\n\n\t\t// show normals?\n\t\tif(u_fAmbient<0.0) cColour=vec3(0.5)+(vNormal*abs(u_fAmbient));\n\t\telse cColour=rayColour(vRay,vDir,vHit,vNormal,vLight,fLen,nStep,fEps,fDist);\n\t}\n\telse\n\t{\n\t\t// get back colour\n\t\tcColour=rayBackground(vDir)+raySun(vDir,vLight);\n\n\t\t// add outer glow?\n\t\tif(u_fOuterGlow>0.0)\n\t\t{\n\t\t\tfloat fGlow=clamp((float(nStep)/float(MAX_STEPS))*u_fOuterGlow,0.0,1.0);\n\t\t\tcColour=mix(cColour,u_cOuterGlow,fGlow);\n\t\t}\n\n\t\t// signal for reflection\n\t\tvHit=vec3(0.0);\n\t}\n\n\t// missed bounding?\n\tif(u_bBounds && !bInside) cColour.r+=6.0;\n\n\treturn cColour;\n}\n\n// rayColour\n// Call to get colour for point\n\nvec3 rayColour(const vec2 vPoint)\n{\n\t// get ray direction\n\tvec3 vDir=normalize(vec3(vPoint,1.0)*u_mCamera);\n\n\t// march ray into scene\n\tvec3 vHit;\n\tvec3 vNormal;\n\n\tvec3 cColour=rayMarch(u_vCamera,vDir,vHit,vNormal);\n\n\t#ifdef REFLECTION\n\t// add reflection?\n\tif(u_fReflection>0.0 && vHit!=vec3(0.0))\n\t{\n\t\t// march to reflection\n\t\tvec3 vReflect=normalize(vDir-2.0*dot(vNormal,vDir)*vNormal);\n\t\tcColour+=rayMarch(u_vCamera,vReflect,vHit,vNormal)*u_fReflection;\n\t}\n\t#endif // REFLECTION\n\n\treturn clamp(cColour,0.0,1.0);\n}\n\n// rayAntiAlias\n// Call to get anti alias colour for point\n\nvec3 rayAntiAlias(const vec2 vPoint)\n{\n\t#ifdef ANTIALIAS\n\tvec2 v=vPoint;\n\n\tfloat fScale=float(u_nAlias+1);\n\tfloat fStep=u_fScale/fScale;\n\n\tvec3 cColour=vec3(0.0);\n\n\tfor(int y=0;y<MAX_ALIAS;y++)\n\t{\n\t\tif(y>u_nAlias) break;\n\n\t\tfor(int x=0;x<MAX_ALIAS;x++)\n\t\t{\n\t\t\tif(x>u_nAlias) break;\n\n\t\t\tcColour+=rayColour(v);\n\t\t\tv.x+=fStep;\n\t\t}\n\t\tv.y+=fStep;\n\t}\n\treturn cColour/pow(fScale,2.0);\n\t#else  // ANTIALIAS\n\treturn rayColour(vPoint);\n\t#endif // ANTIALIAS\n}\n\n// rotate\n// Call to add rotation matrix\n\nmat3 rotate(float fAngle,float x,float y,float z,mat3 m)\n{\n\tfloat a00=m[0].x,a01=m[0].y,a02=m[0].z,\n\t\ta10=m[1].x,a11=m[1].y,a12=m[1].z,\n\t\ta20=m[2].x,a21=m[2].y,a22=m[2].z;\n\n\tfloat fTheta=radians(fAngle);\n\n\tfloat s=sin(fTheta);\n\tfloat c=cos(fTheta);\n\n\tfloat t=1.0-c;\n\n\tfloat b00=x*x*t+c,b01=y*x*t+z*s,b02=z*x*t-y*s,\n\t\tb10=x*y*t-z*s,b11=y*y*t+c,b12=z*y*t+x*s,\n\t\tb20=x*z*t+y*s,b21=y*z*t-x*s,b22=z*z*t+c;\n\n\treturn mat3(\n\t\ta00*b00+a10*b01+a20*b02,a01*b00+a11*b01+a21*b02,a02*b00+a12*b01+a22*b02,\n\t\ta00*b10+a10*b11+a20*b12,a01*b10+a11*b11+a21*b12,a02*b10+a12*b11+a22*b12,\n\t\ta00*b20+a10*b21+a20*b22,a01*b20+a11*b21+a21*b22,a02*b20+a12*b21+a22*b22);\n}\n\n// main\n// Shader program entry point\n\nvoid main(void)\n{\n\t#ifdef CUBEFIELD\n\tu_fPower=0.2;\n\tu_vOffset=vec3(0.5,0.5,0.5);\n\tu_vClamp=vec3(1.0,1.0,1.0);\n\tu_vLight=vec3(0.0,0.0,0.0);\n\t#endif // CUBEFIELD\n\n\t#ifdef SPONGE\n\tu_fPower=3.0;\n\tu_vClamp=vec3(1.0,3.0,3.0);\n\tu_fBounds=5.0;\n\tu_vCamera.z-=3.2;\n\t#endif // SPONGE\n\n\t#ifdef SIERPINSKI\n\tu_fPower=2.0;\n\tu_vOffset=vec3(1.0,1.0,1.0);\n\tu_vClamp=vec3(1.0,1.0,1.0);\n\tu_fBounds=5.0;\n\tu_fSmooth=0.5;\n\tu_vCamera.z-=3.2;\n\t#endif // SIERPINSKI\n\n\t#ifdef MANDELBULB\n\tu_fPower=8.0;\n\tu_fBounds=5.0;\n\tu_vCamera.z-=2.5;\n\t#endif // MANDELBULB\n\n\t#ifdef MANDELBOX\n\tu_fPower=-1.77;\n\tu_vOffset=vec3(1.0,1.0,1.0);\n\tu_vClamp=vec3(0.5,1.0,0.0);\n\tu_fBounds=25.0;\n\tu_fDetail=0.1;\n\tu_vCamera.z-=6.5;\n\t#endif // MANDELBOX\n\n\t#ifdef DODECAHEDRON\n\tu_fPower=1.61803399;\n\tu_vClamp=vec3(1.0,1.0,1.0);\n\tu_fBounds=10.0;\n\tu_vCamera.z-=3.5;\n\t#endif // DODECAHEDRON\n\n\t#ifdef KNOT\n\tu_fPower=3.0;\n\tu_vOffset=vec3(0.07,0.29,0.43);\n\tu_vClamp=vec3(-2.0,-4.0,3.0);\n\tu_fBounds=10.0;\n\tu_fSmooth=0.5;\n\tu_vCamera.z-=3.5;\n\t#endif // KNOT\n\n\t#ifdef QUATERNION\n\tu_fPower=0.16;\n\tu_vJulia=vec3(0.18,0.88,0.24);\n\tu_fBounds=10.0;\n\tu_fSmooth=0.5;\n\tu_vCamera.z-=3.5;\n\t#endif // QUATERNION\n\n\tu_vCamera.z *= surfaceSize.y * 0.5 + 0.4;\n\t\n\tvec2 centerPosition = (0.5 - ( gl_FragCoord.xy / resolution )) * surfaceSize + surfacePosition;\n\tu_mObject=rotate(centerPosition.y*-120.0+15.0,1.0,0.0,0.0,u_mObject);\n\tu_mObject=rotate(centerPosition.x*120.0+10.0,0.0,1.0,0.0,u_mObject);\n\tu_mObject=rotate(time*2.0,0.0,0.0,1.0,u_mObject);\n\t\n\tu_mLight=rotate(mouse.y*-100.0,1.0,0.0,0.0,u_mLight);\n\tu_mLight=rotate(mouse.x*100.0-20.0,0.0,1.0,0.0,u_mLight);\n\n//\tfloat n=sin(time);\n//\tfloat m=abs(n); //mod(n,1.0);\n\n//\tu_fPower=mod(abs(n),1.0);//-(1.5+m);\n//\tu_vJulia=vec3(m,m,m);\n//\tu_vOffset=vec3(m,m,m);\n//\tu_vClamp=vec3(m,m,m);\n\n\t// get ray point\n\tvec2 vPoint=vec2(\n\t\t((gl_FragCoord.x/u_fWidth)-0.5)*u_fRatio,\n\t\t(gl_FragCoord.y/u_fHeight)-0.5);\n\n\t// get ray colour\n\tvec3 cColour=(u_nAlias>0)?\n\t\trayAntiAlias(vPoint):\n\t\trayColour(vPoint);\n\n\t// set fragment colour\n\tgl_FragColor=vec4(cColour,1.0);\n}\n", "user": "682a219", "parent": "/e#1893.0", "id": "2406.1"}