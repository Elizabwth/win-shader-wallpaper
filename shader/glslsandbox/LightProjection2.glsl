{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//Show the number of steps taken (green = ~1, red = ~MAX_STEPS)\n//#define SHOW_SHADOW_COST\n\n//Enable soft shadows\n#define SOFT_SHADOWS\n\n#define MAX_STEPS 96\n#define STEP_MULT 0.2\n#define MIN_DIST 0.0005\n#define SHADOW_HARDNESS 16.0\n\nfloat tau = atan(1.0)*8.0;\n\nvec2 angleRep(float a, vec2 p)\n{\n\tfloat pa = atan(p.y,p.x);\n\tfloat pl = length(p);\n\t\n\tpa = mod(pa - a/2., a) - a/2.;\n\t\n\treturn vec2(cos(pa),sin(pa))*pl;\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat sdCircle(float r, vec2 p)\n{\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec2 s, vec2 p)\n{\n    p = abs(p) - s / 2.0;\n    return max(p.x,p.y);\n}\n\nfloat map(vec2 p)\n{\n\tfloat dist = 1e6;\n\t\n\tvec2 p1 = mod(p, vec2(0.25)) - 0.125;\n\tvec2 p2 = angleRep(tau/12.,p);\n\t\n\tfloat ring = opS(sdCircle(0.275, p), sdCircle(0.325, p));\n\tring = opS(sdBox(vec2(0.2,0.075), p2 - vec2(0.3,0.0)), ring);\n\t\n\t\n\tdist = opU(dist, sdCircle(0.1, p));\n\tdist = opU(dist, sdCircle(0.05, p2 - vec2(0.5,0.0)));\n\tdist = opU(dist, ring);\n\t\n\treturn dist;\n}\n\nvec3 normal(vec2 p)\n{\n\tvec2 offs = vec2(0.001,0);\n\tfloat a = -map(p + offs.xy);\n\tfloat b = -map(p - offs.xy);\n\tfloat c = -map(p + offs.yx);\n\tfloat d = -map(p - offs.yx);\n\t\n\treturn normalize(cross(vec3(offs.xy*2.0,a-b), vec3(offs.yx*2.0,c-d)));\n}\n\nfloat steps = 0.0;\n\nfloat shadow(vec2 p, vec2 l)\n{\n\tvec2 dir = normalize(l - p);\n\tfloat dist = distance(p, l);\n\tfloat t = 0.0;\n\tfloat s = 1.0;\n\t\n\tfor(int i = 0;i < MAX_STEPS;i++)\n\t{\n\t\tfloat sd = map(p + dir * t);\n\t\t\n\t\t#ifdef SOFT_SHADOWS\n\t\tt += sd * STEP_MULT;\n\t\t#else\n\t\tt += sd;\n\t\t#endif\n\t\t\n\t\ts = min(s, SHADOW_HARDNESS*sd/t);\n\t\t\n\t\tsteps++;\n\t\t\n\t\tif(sd < MIN_DIST || t > dist)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t}\n\t\n\t#ifdef SOFT_SHADOWS\n\treturn (t < dist) ?  0.0 : s;\n\t#else\n\treturn (t < dist) ?  0.0 : 1.0;\n\t#endif\n}\n\nvec3 PointLight(vec3 col, float bright, vec3 pos, float dist, vec2 p)\n{\n\tfloat shade = shadow(p, pos.xy) * bright / pow(length(vec3(p, 0) - pos), 2.0);\n\tif(dist < 0.0) //Only apply normalmapping to objects.\n\t{\n\t\tshade += max(0.0,dot(normal(p), normalize(pos- vec3(p, 0))));\n\t}\n\treturn col * shade;\n}\n\nvoid main( void ) \n{\n\tvec2 aspect = resolution.xy / resolution.y;\n\tvec2 uv = ( gl_FragCoord.xy / resolution.y ) - aspect/2.0;\n\tvec2 mo = mouse * aspect - aspect/2.0;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = map(uv);\n\t\n\tvec3 li1 = vec3(cos(time),sin(time), 0.15);\n\tli1.xy *= 0.15;\n\t\n\tvec3 li2 = vec3(cos(-time),sin(-time), 0.15);\n\tli2.xy *= 0.4;\n\t\n\tvec3 shade = vec3(0.0);\n\tshade += PointLight(vec3(1,0.6,0.3), 0.03, li1, d, uv);\n\tshade += PointLight(vec3(0.5,0.7,1), 0.02, li2, d, uv);\n\tshade += 0.125;\n\t\n\t\n\tvec3 bg = vec3(0.75);\n\tbg *= smoothstep(-0.02,0.02,d);\n\tbg *= shade;\n\t\n\tvec3 fg = vec3(1.0,0.5,0.0) * smoothstep(0.000,0.003,-map(uv));\n\tfg *= shade;\n\t\n\tcolor = mix(fg, bg, smoothstep(0.000,0.001,map(uv)));\n\t\n\t#ifdef SHOW_SHADOW_COST\n\tcolor = mix(vec3(0,1,0),vec3(1,0,0),steps/float(MAX_STEPS));\n\t#endif\n\t\n\tgl_FragColor = vec4( vec3( color ), 1.0 );\n\n}", "user": "a8250a4", "parent": null, "id": "27539.11"}