{"code": "// GLSL rubik's cube by Kabuto\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Traces a single big cube (= here: layer of 3x3 small cubes)\nvoid cubetrace(vec3 pos, vec3 dir, vec3 scale, vec3 ofs, inout vec4 hit) {\n\tpos *= scale;\n\tpos += ofs;\n\tdir *= scale;\n\tvec3 h1 = (-pos-sign(dir))/dir;\n\tvec3 h2 = (-pos+sign(dir))/dir;\n\tfloat h1f = max(max(h1.x,h1.y),h1.z);\n\tfloat h2f = min(min(h2.x,h2.y),h2.z);\n\tif (h1f < h2f && h1f < hit.w) {\n\t\thit = vec4((pos+dir*h1f-ofs)/scale,h1f);\n\t}\n}\n\n// What layer to rotate in what frame\n// x: rotation axis (0 to 2), y: rotation layer (0 to 2), z: rotation direction (-1 or 1)\n// Math has to be that way (rounding redundantly) due to numerical precision issues\nvec3 rotframe(float time) {\n\ttime = floor(time)+.5;\n\treturn floor(vec3(mod(time,3.),mod(floor(time/3.+.1)+.5,3.),floor(mod(time,2.))*2.-1.));\n}\n\n\nconst int FRAMES = 32;\n\nvoid main( void ) {\n\tvec3 pos = vec3(0.,-.21,-7.);\n\tvec2 uv = (gl_FragCoord.xy - resolution*.5)/resolution.y*.5;\n\tvec3 dir = normalize(vec3(uv,1.));\n\n\tfloat tf = mod(time,float(FRAMES))+1e-5;\n\tvec3 r = rotframe(tf);\n\t\n\tfloat t2 = time*.3;\n\tmat3 globalrot = mat3(cos(t2),0,-sin(t2),0,1,0,sin(t2),0,cos(t2));\n\t\n\tfloat t = -fract(tf)*3.141592653589*.5*r.z;\n\tmat3 rot = r.x < .5 ?\n\t\tmat3(1,0,0,0,cos(t),sin(t),0,-sin(t),cos(t))\n\t: r.x < 1.5 ?\n\t\tmat3(cos(t),0,-sin(t),0,1,0,sin(t),0,cos(t)) :\n\t\tmat3(cos(t),sin(t),0,-sin(t),cos(t),0,0,0,1);\n\n\tmat3 rot2 = mat3(1,0,0,0,1,0,0,0,1);\n\n\tfloat a = -.4;\n\tmat3 prot = mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a))*globalrot;\n\tpos *= prot;\n\tdir *= prot;\n\n\tvec4 vhit = vec4(0,0,0,1e9);\n\tvec3 s = r.x < .5 ? vec3(1,0,0) : r.x < 1.5 ? vec3(0,1,0) : vec3(0,0,1);\n\tcubetrace(pos*(r.y==0.?rot:rot2),dir*(r.y==0.?rot:rot2),vec3(1,1,1)+s*2.,s*2.,vhit);\n\tcubetrace(pos*(r.y==1.?rot:rot2),dir*(r.y==1.?rot:rot2),vec3(1,1,1)+s*2.,vec3(0, 0,0),vhit);\n\tcubetrace(pos*(r.y==2.?rot:rot2),dir*(r.y==2.?rot:rot2),vec3(1,1,1)+s*2.,-s*2.,vhit);\n\t\n\t\t\n\t\t\n\tvec3 hit = vhit.xyz;\n\t\n\tfor (int i = FRAMES-1; i >= 0; i--) {\n\t\tif (float(i)+1. < tf) {\n\t\t\tvec3 r = rotframe(float(i));\n\t\t\thit = r.x < .5 ? hit : r.x < 1.5 ? hit.yzx : hit.zxy;\n\t\t\tif (abs(floor(hit.x*1.49+1.5)- r.y) < .5) hit.yz *= mat2(0,-r.z,r.z,0);\n\t\t\thit = r.x < .5 ? hit : r.x < 1.5 ? hit.zxy : hit.yzx;\n\t\t}\n\t}\n\t\n\t\n\tvec3 ahit = abs(hit.xyz);\n\tvec3 side = sign(hit.xyz)*step(vec3(.99),ahit);\n\tfloat m = max(max(ahit.x,ahit.y),ahit.z);\n\t\n\thit.xyz *= 3.;\n\thit.xyz = abs(fract(hit.xyz*.5+.5)-.5)*2.;\n\tfloat b = max(max(hit.x,hit.y),hit.z);\n\tfloat d = min(min(hit.x,hit.y),hit.z);\n\tfloat c = hit.x+hit.y+hit.z-b-d;\n\tc = max(c-.7,0.);\n\td = max(d-.7,0.);\n\t\n\t\n\t\n\tvec3 facecolour = max(side,vec3(0)) + (1.+min(side,vec3(0)))*dot(-min(side,vec3(0)),vec3(1));\n\tvec3 colour = vec3(step(sqrt(c*c+d*d),.17)*step(.99,m))*facecolour+step(m,.1);\n\tcolour += 1.-min(1.,float(FRAMES)-tf);\n\t\n\tgl_FragColor = vec4( colour, 1.0 );\n\n}", "user": "b9b84f", "parent": null, "id": "16971.0"}