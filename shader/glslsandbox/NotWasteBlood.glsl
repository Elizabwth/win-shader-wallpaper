{"code": "// NotWasteBlood by I.G.P.    2015-10-04\n// Todo: add light refraction, multicolored drops\n\n#ifdef GL_ES\nprecision mediump float; \n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//----------------------------------------------------------------------\n// http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\n//----------------------------------------------------------------------\nvec3 hash3( vec2 p )\n{\n\tvec3 q = vec3( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec2 x, float u, float v )\n{\n\tvec2 p = floor(x);\n\tvec2 f = fract(x);\n\n\tfloat k = 1.0 + 63.0*pow(1.0-v,4.0);\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n\tfor( int j=-2; j<=2; j++ )\n\t{\n\t    for( int i=-2; i<=2; i++ )\n\t    {\n\t\tvec2  g = vec2( float(i), float(j) );\n\t\tvec3  o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2  r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += w*o.z;\n\t\twt += w;\n\t    }\n\t}\n\treturn va/wt;\n}\n\n//http://www.iquilezles.org/www/articles/warp/warp.htm\nfloat pattern( in vec2 p )\n{\n\tvec2 q = vec2(noise( p + vec2(0.0, 0.0), 1., 1.)\n\t\t     ,noise( p + vec2(5.2, 1.3), 1., 1.));\n\treturn noise( p + 4.0*q , 1., 1.);\n}\n\nvec3 background () \n{\n  vec2 p = 2.0 * gl_FragCoord.xy / resolution.xy - 1.0;\n  p.x *= resolution.x / resolution.y;\n  vec3 color = 0.1+0.8*vec3(pattern(p*20.));\n  return color;\n}\n\n//--------------------------------------------------------\n// https://www.shadertoy.com/view/ll2SWD\n//--------------------------------------------------------\n\n#define PI 3.14159265358979\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdPlane(vec3 p) {\treturn p.z; }\n\nfloat sdEllipsoid(in vec3 p, in vec3 r) { return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z); }\n\n//----------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\nvec2 opB(vec2 d1, vec2 d2) { return vec2(smin(d1.x,d2.x,.2),smin(d1.x,d2.x,.2));}\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n  float c1 = cos(time);\n  float c2 = cos(time/2.0);\n  float c3 = cos(time/3.0);\n  float s1 = sin(time);\n  float s2 = sin(time/2.0);\n  float s3 = sin(time/3.0);\n  vec2 res=vec2(sdEllipsoid( pos+vec3(s3,0.9*c3, 0.0), vec3(2.0+c1/5.0, 2.0+s2/5.0, .5)/4.0 ), 45.0 );\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.6*s1, cos(time/2.5),0.0), vec3(2.0+s1/5.0, 2.0+cos(time/1.2)/5.0, .5)/4.0 ), 45.0 ));    \n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.8*c3, 1.7*s3,0.0), vec3(2.0+c3/5.0, 2.0+sin(time/5.0)/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.4*s3, 0.8*c3,0.0), vec3(2.0+s2/5.0, 2.0+c2/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.1*c2, s3,0.0), vec3(2.0+c3/5.0, 2.0+sin(time/5.0)/5.0, .5)/4.0 ), 45.0 ));\n  res=opB(res,vec2(sdEllipsoid( pos+vec3(1.2*s2, 1.7*c3,0.0), vec3(2.0+s2/5.0, 2.0+c2/5.0, .5)/4.0 ), 45.0 )); \n  res=opU(res,vec2(sdPlane(pos), 1.5)); \n  return res;\n}  \nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 0.0;\n  float tmax =20.0;\n    \n  #if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n  #endif\n    \n  float precis = 0.0002;\n  float t = tmin;\n  float m = -1.0;\n  for( int i=0; i<50; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n  if( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for( int i=0; i<16; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3( map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t                 map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t                 map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i)/4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  vec3 col = vec3(10.8, 10.9, 1.0);\n  vec2 res = castRay(ro,rd);\n  float t = res.x;\n  float m = res.y;\n  if(m > 0.0)\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n    vec2 ballUv =(pos.xy+vec2(2.5,2.0))*.2;\n    // material\n    col = background();\n    if(m < 0.01)\n      col = mix (col, vec3(1.8,-0.4,-0.4), 0.58);\t\n\n    // lighting        \n    vec3  lig = normalize( vec3(5.0*sin(time/3.0), 5.0*cos(time/3.0), 3.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n\n    vec3 brdf = .5*dif*vec3(1.00,0.90,0.60);\n    brdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n    brdf += 0.05;\n    col = col*brdf;\n  }\n  else t /= 15.0;\n  col *= exp( -0.015*t*t );\n\n  // lights\n  vec3 lv = normalize(vec3(5.0*sin(time/3.0), 5.0*cos(time/3.0), 3.5)) - ro/3.5;\n  float ll = length( lv );\n  if( ll<t )\n  {\n    float dle = clamp( dot( rd, lv/ll), 0.0, 1.0 );\n    dle = (1.0-smoothstep( 0.0, 0.2*(0.7+0.3*.5), acos(dle)*ll ));\n    col += dle*6.0*.5*vec3(1.0,1.0,0.0)*dle*exp( -0.1*ll*ll );;\n  }\n  return vec3( clamp(col,0.0,1.0) );\n}  \n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvec3 liquid()\n{\n  vec2 p = 2.0 * gl_FragCoord.xy / resolution.xy - 1.0;\n  p.x *= resolution.x / resolution.y;\n  vec2 mo = mouse.xy / resolution.xy;\n\t\t \n  // camera\t\n  vec3 ro = vec3(0.0,-6.0+6.0*cos(mo.y*PI),2.0+2.0*cos(mo.y*PI));\n  vec3 ta = vec3( 0.0, -0.5, 0.0 );\n  // camera-to-world transformation\n  mat3 ca = setCamera( ro, ta, 0.0 );\n    \n  vec3 rd = ca * normalize( vec3(p.xy,2.0) );    // ray direction\n  vec3 col = render( ro, rd );    // render\t\n  col = pow( col, vec3(0.4545) );\n  return col;\n}\n\nvoid main()\n{\n  vec3 col = liquid();\n  gl_FragColor = vec4( col, 1.0 );\n}\n", "user": "9ccfc78", "parent": null, "id": "28039.1"}