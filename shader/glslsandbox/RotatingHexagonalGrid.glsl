{"code": "\n// Rotating Hexagonal Grid\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float tau = 6.28318;\n\nmat3 Rotate3D(vec3 angles)\n{\n    vec3 c = cos(angles),   s = sin(angles);\n    mat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n    return rotX*rotY*rotZ;\n}\n\nmat2 Rotate2D(float angle)\n{\n    float c = cos(angle),   s = sin(angle);\n    return mat2(c,s,-s,c);\n}\n\nvec2 hex0 = vec2(cos(tau * (1.0/12.0)), sin(tau * (1.0/12.0)));\nvec2 hex1 = vec2(cos(tau * (3.0/12.0)), sin(tau * (3.0/12.0)));\nvec2 hex2 = vec2(cos(tau * (5.0/12.0)), sin(tau * (5.0/12.0)));\n\nfloat dhex(vec2 uv, float r)\n{\n    r *= cos(tau / 12.0);\n    return max(max(abs(dot(uv, hex0)), abs( dot(uv, hex1) )), abs(dot(uv, hex2))) - r;\n}\n\nfloat dhexgrid(vec2 uv, float r)\n{\n\tfloat sr = r * cos(tau / 12.0);\n\t\n\tvec2 repsz = vec2(r * 1.5, sr * 2.0);\n\n\tuv -= repsz;\n\tuv = mod(uv, repsz*2.0) - repsz;\n\t\n\tfloat d = dhex(uv, r);\n\td = min(d, dhex(uv - vec2(r + r * 0.5, sr), r));\n\td = min(d, dhex(uv - vec2(r + r * 0.5,-sr), r));\n\td = min(d, dhex(uv + vec2(r + r * 0.5, sr), r));\n\td = min(d, dhex(uv + vec2(r + r * 0.5,-sr), r));\n\td = min(d, dhex(uv - vec2(0.0, sr + sr), r));\n\td = min(d, dhex(uv + vec2(0.0, sr + sr), r));\n\t\n\treturn d;\n}\n\nvec4 plane(vec3 o, vec3 d)\n{\n\tvec3 n = normalize(vec3(0,1,0));\n\tfloat t = (dot(o, n) / max(0.0,dot(d, -n)));\n\treturn vec4(o + d * t, t);\n}\n\nvoid main( void ) \n{\n\tvec2 aspect = resolution.xy / resolution.y;\n\tvec2 uv = (gl_FragCoord.xy / resolution.y);\n\tuv -= aspect/2.0;\n\t\n\t//Camera\n\tvec3 corig = vec3(0.4,0.8,-0.6);\n\tvec3 cdir = normalize(vec3(uv,1.0));\n\tcdir *= Rotate3D(vec3(-0.9,0.3,0.2));\n\t\n\tvec4 pl = plane(corig, cdir);   //3D Plane (w = depth)\n\tpl.xz *= Rotate2D(time * 0.1);  //Rotate the plane's surface\n\t\n\t//Shading\n\tfloat hdist = dhexgrid(pl.xz,0.08);\n\tfloat lnscale = pl.w / resolution.y;\n\tfloat cmix = smoothstep(0.0,-2.0*lnscale, (sin(time)*0.4+0.8)*hdist) + hdist;\n\tvec3 color = mix(vec3(3.1, 3.1, 0.5),vec3(0),cmix);\n\tcolor *= smoothstep(0.8,0.3,length(pl.xz));\n\n\tgl_FragColor = vec4(color, 1.0 );\n}", "user": "e0a8400", "parent": "/e#27652.0", "id": "27682.0"}