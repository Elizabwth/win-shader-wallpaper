{"code": "//Made by Jordan Duty(AKA djdduty) May 14, 2014.\nprecision highp float;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nvarying vec2 surfacePosition;\n\n#define M_PI 3.1\n\n#define useFractal fractal2Color\n\n//universeFractal from http://glsl.heroku.com/e#16703\n#define iterations 10\n#define formuparam 0.42\n\n#define volsteps 10\n#define stepsize 0.120\n\n#define zoom   0.1000\n#define tile   0.1120\n#define speed  0.00100\n\n#define brightness 0.001\n#define darkmatter 0.500\n#define distfading 0.120\n#define saturation -0.900\nvec3 universeFractal(vec2 surfacePos) {\n\t//get coords and direction\n\tvec2 uv=surfacePos;\n\tvec3 dir=vec3(uv*zoom,10.);\n\t\n\tfloat a2=time/10.0*speed;\n\tfloat a1=10.0;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=rot1;\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\t\n\t//mouse movement\n\tvec3 from=vec3(0.,0.,0.);\n\tfrom+=vec3(.001*time,.001*time,-2.);\n\t\n\t//from.x-=mouse.x;\n\t//from.y-=mouse.y;\n\t\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=.4,fade=.2;\n\tvec3 v=vec3(0.4);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-1.1*formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a*2.; // add contrast\n\t\tif (r>3) fade*=1.-dm; // dark matter, don't render near\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec3(v * .01);\t\n\n}\n\n//other fractal2 from http://glsl.heroku.com/e#16840\n#define fractal_details 10\n#define zoomout 1.0\n\nvec3 fractal2Color(vec2 surfacePos) {\n\n\tvec2 p = surfacePos*zoomout;//*sin(time*0.5)*10.5;\n\tvec3 c = vec3(0);\n\tvec2 fractal;\n\tfloat deepfade = 1.0;\n\tfor (int i=-0; i<fractal_details; i++) \n\t{\n\t\t//deepfade -= float(i)/float(fractal_details);\n\t\tdeepfade *= 0.5;\n\t\tfractal = abs(p)/dot(p,p)-1.0+sin(time*0.5)*0.5;\n\t\tvec2 pdiff = fractal-p;\n\t\tfloat ddiff = abs(length(pdiff));\n\t\t//c.rg += fractal*deepfade;\n\t\tc.rg += pdiff*deepfade;\n\t\tc.b += ddiff*deepfade;\n\t\tp = fractal;\n\t}\n\treturn c;\n}\n\n//scene with spheres\nstruct Ray\n{\n\tvec3 Dir;\n\tvec3 Pos;\n};\n\t\nstruct Sphere\n{\n\tvec3 Pos;\n\tvec3 Color;\n\tfloat Rad;\n\tfloat Reflection;\n};\n\nconst int numSpheres = 7;\nSphere spheres[numSpheres];\n\nvec3 LightPos = vec3(0,-3,10);\n\t\nvec3 Intersects(Sphere s, Ray r)\n{\n\tfloat t0, t1;\n\tvec3 l = s.Pos - r.Pos;\n\tfloat tca = dot(l, r.Dir);\n\tif(tca < 0.0) return vec3(0,0,-1.0);\n\tfloat d2 = dot(l, l) - tca*tca;\n\tif(d2 > s.Rad*s.Rad) return vec3(0,0,-1.0);\n\tfloat thc = sqrt((s.Rad*s.Rad) - d2);\n\treturn vec3(tca-thc, tca+thc, 1);\n}\n\t\nfloat mix2(float a, float b, float c)\n{\n\treturn b*c+a*(1.0-c);\t\n}\n\nvec3 Trace3(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;        float spaceScale = 0.1;       Color+=(useFractal(phit.xy*spaceScale)+useFractal(phit.xz*spaceScale)+useFractal(phit.yz*spaceScale))/3.0;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit)) {\n\t\t\t\tblocked = true;\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\treturn Color;\n}\n\nvec3 Trace2(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace3(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvec3 Trace(Ray r)\n{\n\tvec3 Color = vec3(0,0,0);\n\tSphere s;\n\tbool col = false;\n\tfloat tnear = 1e8;\n\tfor(int i = 0; i < numSpheres; i++)\n\t{\n\t\tvec3 intTest = Intersects(spheres[i],r);\n\t\tif(intTest.z != -1.0) {\n\t\t\tif(intTest.x < tnear) {\n\t\t\t\ttnear = intTest.x;\n\t\t\t\ts = spheres[i];\n\t\t\t\tcol = true;\n\t\t\t}\n\t\t}\n\t}\n\tif(col==false) return vec3(0,0,0);\n\tvec3 phit = r.Pos + r.Dir * tnear;\n\tvec3 nhit = phit - s.Pos;\n\tnhit = normalize(nhit);\n\tfloat bias = 1e-4;\n\t\n\tbool inside = false;\n\tif(dot(r.Dir, nhit) > 0.0) nhit *= -1.0, inside = true;\n\t\n\tif(s.Reflection > 0.0)\n\t{\n\t\tfloat facingratio = dot((r.Dir*-1.0), nhit);\n\t\tvec3 refldir = r.Dir - nhit * 2.0 * dot(r.Dir, nhit);\n\t\trefldir = normalize(refldir);\n\t\tRay rd;\n\t\trd.Pos = phit;\n\t\trd.Dir = refldir;\n\t\tvec3 refl = Trace2(rd);\n\t\tfloat param1 = (1.0-s.Reflection);\n\t\tfloat param2 = s.Reflection;\n\t\tColor.x = (param1 * Color.x + param2 * refl.x);\n\t\tColor.y = (param1 * Color.y + param2 * refl.y);\n\t\tColor.z = (param1 * Color.z + param2 * refl.z);\n\t}\n\t\n\tvec3 lightDir = LightPos - phit;\n\tbool blocked = false;\n\tlightDir = normalize(lightDir);\n\tfloat DiffuseFactor = dot(nhit, lightDir);\n\tvec3 diffuseColor = vec3(0,0,0);\n\tvec3 ambientColor = vec3(s.Color * 0.2);\n\t\n\tfor(int n = 0; n < numSpheres; n++)\n\t{\n\t\tRay rl;\n\t\trl.Pos = phit;\n\t\trl.Dir = lightDir;\n\t\tvec3 intTestL = Intersects(spheres[n],rl); \n\t\tif(intTestL.z != -1.0)\n\t\t{\n\t\t\tif(intTestL.x < length(LightPos-phit))\n\t\t\t\tblocked = true;\t\n\t\t}\n\t}\n\t\n\tif(!blocked)\n\t{\n\t\tif(DiffuseFactor > 0.0)\n\t\t{\n\t\t\tdiffuseColor = \tvec3(1,1,1)*DiffuseFactor;\n\t\t\tColor += s.Color*diffuseColor + ambientColor;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tColor+=ambientColor;\t\n\t\t}\n\t} \n\telse\n\t{\n\t\tColor+=ambientColor;\n\t}\n\t\n\t\n\treturn Color;\n}\n\nvoid main(void)\n{\n\tspheres[0].Pos = vec3(5,0,-0);\n\tspheres[0].Color = vec3(1.0,1.0,1.0);\n\tspheres[0].Rad = 4.0;\n\tspheres[0].Reflection = 0.4;\n\t\n\tspheres[1].Pos = vec3(-5,0,-0);\n\tspheres[1].Color = vec3(0.0,0.0,0.0);\n\tspheres[1].Rad = 4.0;\n\tspheres[1].Reflection = 0.3;\n\t//floor\n\tspheres[2].Pos = vec3(-5,1004,-0);\n\tspheres[2].Color = vec3(0.0,0.0,0.0);\n\tspheres[2].Rad = 1000.0;\n\tspheres[2].Reflection = 0.5;\n\t//sides\n\tspheres[3].Pos = vec3(-5,0,-1040);\n\tspheres[3].Color = vec3(0.9,0.0,0.0);\n\tspheres[3].Rad = 1000.0;\n\tspheres[3].Reflection = 0.505;\n\t\n\t\n\tspheres[5].Pos = vec3(-1020,0,-0);\n\tspheres[5].Color = vec3(0.0,0.0,0.7);\n\tspheres[5].Rad = 1000.0;\n\tspheres[4].Pos = vec3(1020,0,-0);\n\tspheres[4].Color = vec3(0.0,0.9,0.0);\n\tspheres[4].Rad = 1000.0;\n\tspheres[4].Reflection = 0.505;\n\tspheres[5].Reflection = 0.505;\n\t\n\tspheres[6].Pos = vec3(-5,0,1040);\n\tspheres[6].Color = vec3(0.9,0.9,0.0);\n\tspheres[6].Rad = 1000.0;\n\tspheres[6].Reflection = 0.505;\n\t\n\tfloat invWidth = 1.0 / resolution.x;\n\tfloat invHeight = 1.0 / resolution.y;\n\tfloat fov = 60.0; \n\tfloat aspectratio = resolution.x/resolution.y;\n\tfloat angle = tan(M_PI * 0.5 * fov / 180.0);\n\t\n\tvec3 sinTime = vec3(sin(time*2.0));\n\t\n\tvec3 camTrans = vec3(20.0*cos(0.5*time), 0, 20.0*sin(0.5*time));\n\tvec3 camDir = camTrans - vec3(0);\n\t\n\tcamTrans.y = -5.0;\n\tLightPos.y = -10.0;//camTrans;\n\t\n\tmat3 rot;\n\tvec3 f = normalize(camTrans);\n\tvec3 u = vec3(0,1,0);\n\tvec3 s = normalize(cross(f,u));\n\tu = cross(s,f);\n\trot[0][0] = s.x; rot[1][0] = s.y; rot[2][0] = s.z;\n\trot[0][1] = u.x; rot[1][1] = u.y; rot[2][1] = u.z;\n\trot[0][2] = f.x; rot[1][2] = f.y; rot[2][2] = f.z;\n\t\n\tRay R;\n\tfloat xx = (2.0 *((gl_FragCoord.x+0.5) * invWidth) -1.0)*angle*aspectratio;\n\tfloat yy = (1.0-2.0*((gl_FragCoord.y+0.5)*invHeight))*angle;\t\n\tR.Pos = camTrans;\n\tR.Dir = vec3(xx,yy,-1) * rot;\n\tR.Dir = normalize(R.Dir);\n\t\n\tgl_FragColor = vec4(Trace(R), 1.0);\n}", "user": "b54df9f", "parent": "/e#16936.0", "id": "16940.0"}