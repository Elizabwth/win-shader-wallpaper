{"code": "// ------------- Counter. (c) Fabrice NEYRET June 2013 -----------------------\\\\\n// adapted for glslsandbox by Gigatron\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n#define STYLE 2     // 1/2\n#define EFFECT 2    // 0/1/2\n#define E (1./6.)   // segment thickness\n#define DELAY 5.    // effect periodicity\n#define RIGHT_HALF (gl_FragCoord.x > resolution.x * .0)\nfloat rad = 6.;     // segment shape ratio\n\n#define PI 3.1415927\n \n\n// --- Displays digit b at pos with size=scale ------------------------------\n//     return code =  1:pixel on , 0: pixel off , -1: pixel out of digit bbox\nint aff(int b, inout vec2 pos)\n{\n\tvec2 scale = vec2(.25*resolution.y,.375*resolution.y);\n\tvec2 uv = (gl_FragCoord.xy-pos)/scale;       // normalized coordinates in digit bbox\n\tpos.x -= 1.0*scale.x;                        // 1.2*scale.x\n\tif((abs(uv.x)<.5)&&(abs(uv.y)<.5))          // pixel is in bbox\n\t{\n\t\tconst float dy = 2.*(1.-E);\n\t\tfloat ds = 1./sqrt(1.+dy*dy)*3./1.414/(1.-2.*E);\n\t\tvec2 st = ds*vec2(uv.x-dy*uv.y,-uv.x-dy*uv.y); // in diamond frame coords\n\t\tif((abs(st.x)>1.5)||(abs(st.y)>1.5)) return 0; // pixel is not in 3x3 diamond grid\n\t\tst += 1.5;\n\t\tint seg = int(st.x)+3*int(st.y);           // diamond cell number\n\t\tif ((seg==2)||(seg==6)) return 0;          // pixel is in a non-segment cells\n\t\tuv = 2.*(st-floor(st))-1.;                 // pixel in diamond cell coords\n\t\tfloat t=PI/4.; \n#if EFFECT>0\n\t\tfloat dt = DELAY*floor(time/DELAY); // effect every DELAY seconds\n  #if EFFECT==1                       // rotation effect\n\t\tif (time-dt<PI/2.) {\n\t\t\tt=4.*(time-dt); \n\t\t\tt = PI/4.+.5*(t-sin(t));\n\t\t}\n  #elif EFFECT==2                     // zoom effect\n\t\tif (time-dt<PI) {\n\t\t\tfloat tt = 2.*(time-dt); \n\t\t\ttt = sin(tt)*(1.-cos(tt))/1.3; // -1..1\n\t\t\trad /= 1.-.9*tt;\n\t\t}\t\t\n  #endif\n#endif\n\t\tfloat C = cos(t), S=sin(t);\n\t\tuv = vec2(C*uv.x-S*uv.y,S*uv.x+C*uv.y); // pixel in screen-parallel cell coords\n\t    bool c;                                 // true if pixel is in a set segment of digit b.\n#if 1\n\t\tif     (b==0) c = (seg!=4);             // is pix in a segment of digit b ?\n\t\telse if(b==1) c = (seg==1)||(seg==5);\n\t\telse if(b==2) c = (seg!=3)&&(seg!=5);\n\t\telse if(b==3) c = (seg!=3)&&(seg!=7);\n\t\telse if(b==4) c = (seg!=0)&&(seg!=7)&&(seg!=8);\n\t\telse if(b==5) c = (seg!=1)&&(seg!=7);\n\t\telse if(b==6) c = (seg!=1);\n\t\telse if(b==7) c = (seg==0)||(seg==1)||(seg==5);\n\t\telse if(b==8) c =   true;\n\t\telse if(b==9) c = (seg!=7);\n#else\n\t\tc = (seg==b);                        // drawn cell b\n#endif\n\t    // return 1 if pixel should be drawn.\n#if STYLE==1\n\t    if (c)\tif (length(uv)<1.) return 1; // pixel in positive shape for segment on\n\t\telse    if (length(uv)>.9) return 1; // pixel in positive shape for segment off\t\t\t\n#elif STYLE==2\n\t\tif (4*(seg/4)==seg) uv.y *=rad;       // segment = vertical or horizontal ellips\n\t\telse                uv.x *=rad;\n\t    if (c)\tif (length(uv)<1.3) return 1; // pixel in a set segment\tshape\n#endif\n        return 0; // pixel is in digit bbox but out of a set segment\n\t}\n\treturn -1;    // pixel is out of digit bbox\n}\n\nvoid main()\n{\n\t \n    int c;\n\tvec2 pos   = vec2(.95*resolution.x, .50*resolution.y);// x=0.85 , y=0.50 \n\tint t = int(9999999.+time*1000.);   // decompose 1000*timer in digits \n\tfor (int i=0; i<9; i++) {             // i=Num Digit\n\t\tint n = t-10*(t/10); t=t/10; // n = digit from right to left\n\t\tc = aff(n, pos);             // 1 if pixel is in the digit bbox AND in a set segment \n\t\tif (c>=0) break;             // the digit under pixel as been found\n\t}\n\t\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tfloat background = uv.y;\n\tfloat pix_s = .022;\n\tvec2 pix = mod( uv, pix_s );\n\tif( RIGHT_HALF )\n\tuv -= pix;\n\tpix -= pix_s * .5;\n\tuv = uv * .5 + .5;\n\tif (c>0) \n\t\tgl_FragColor = vec4(0.5+0.5*sin(time),uv,1.0);     // draw set pixels\n\t//else if (c==0)\n\t//\tfragColor = vec4(0.*uv,0.5-0.5*sin(iGlobalTime),1.0);  // draw digit background\n\t//else\n\t//gl_FragColor = vec4(uv,0.5-0.5*sin(time),1.0);     // draw background\n\t\n\tgl_FragColor = vec4(smoothstep(2.,-4.,background) );\n\tif( RIGHT_HALF ) gl_FragColor *= smoothstep( pix_s*float(c), 0.,length(pix) ); // OK !\n\tif (c>0) \n\tgl_FragColor += vec4(0.*uv,0.5-0.9*sin(time),1.0);\n}", "user": "1c04ace", "parent": null, "id": "26521.6"}