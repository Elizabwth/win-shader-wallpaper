{"code": "//building off paulo falcao's raymarch framework -alice (http://y-alice.blogspot.com/)\n//--added random building size -h3r3 ;)\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nuniform vec2 resolution;\nuniform float time;\nuniform vec2 mouse;\n//Simple raymarching sandbox with camera\n\n//Raymarching Distance Fields\n//About http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n//Also known as Sphere Tracing\n//Original seen here: http://twitter.com/#!/paulofalcao/statuses/134807547860353024\n\n//Declare functions\nvec2 ObjUnion(in vec2 d1,in vec2 d2);\nvec2 floorPlane(in vec3 p);\nvec3 color_checkers(in vec4\n\t\t    p);\nvec2 roundBox(in vec3 p);\nvec2 sdBox( vec3 p, vec3 b );\nvec3 color_white(in vec3 p);\nvec2 distanceField(in vec3 p);\nvec2 simpleBuilding (vec3 p, vec3 b );\nvec4 applyFog (in vec4 currColor, in vec3 ray);\nfloat maxcomp(in vec3 p );\nvec2 infiniteBuildings(in vec3 p);\nfloat sdCross( in vec3 p );\nvec2 sidewalk(vec3 p);\nvec2 tallBuilding (vec3 p, vec3 b );\nvec2 infiniteTallBuildings(in vec3 p);\nvec3 color_brick(in vec3 p);\n\n\n\n#define EPS 0.01\n#define INF 100000.0\n\n#define PHONG_SHADING 1\n#define RAYMARCH_SHADING 1\n#define TEST_SHADING 0\n\n#define SPINNING_CAMERA 0\n#define MOUSE_CAMERA 1\n#define PAN_CAMERA 2\n#define STILL_CAMERA 3\n#define AUTOPAN_CAMERA 4\n\n// mode selection\nconst int SHADING_MODE = TEST_SHADING; \nconst int CAMERA_MODE = AUTOPAN_CAMERA; \nvec3 E;\n\n// some simple colors\nconst vec3 COLOR_GREY = vec3(0.2,0.2,0.2);\nconst vec3 COLOR_WHITE = vec3(1.0,1.0,1.0);\nconst vec3 COLOR_BLACK = vec3(0);\nconst vec3 COLOR_WINDOW = vec3(0,0.4,0.55);\n\n//============================== UTILS ====================================//\nvec2 distanceField(in vec3 p){\n\treturn ObjUnion(floorPlane(p),ObjUnion(infiniteTallBuildings(p), infiniteBuildings(p))); // infinite boxes\n\t\n\t//vec2 test = ObjUnion(infiniteBuildingsShort(p),infiniteBuildingsTall(p)); //multiple mod patterns\n\t//return ObjUnion(floorPlane(p),test);\n}\n\nvec2 ObjUnion(in vec2 d1,in vec2 d2){\n\tif (d1.x<d2.x)\n\treturn d1;\n\telse\n\treturn d2;\n}\n\n// http://www.ozone3d.net/blogs/lab/20110427/glsl-random-generator/\nfloat rand(vec2 n)\n{\n\treturn 0.5 + 0.5 *\n\tfract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n// from IQ\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\n\n\n// =============================== OBJECTS =======================================//\n// CREDIT: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm //\n\n//floorPlane (color is determined by y-component, ie 0.0)\nvec2 floorPlane(in vec3 p){\n\treturn vec2(p.y+2.0,0);\n}\n\n// ROUNDBOX (try other objects )\n//(color is determined by y-component, ie 1.0)\nvec2 roundBox(in vec3 p){\n\treturn vec2(length(max(abs(p)-vec3(1,1,1),0.0))-0.25,1);\n}\n\n// SIGNED BOX\nvec2 sdBox( vec3 p, vec3 b ){\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return vec2(min(mc,length(max(di,0.0))), 1);\n}\n\n\n// INFINITE SIMPLE BUILDINGS RANDOm (CREDIT: H3R3)\nvec2 infiniteBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(5); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*5.0;//* 10.0 - 4.0;\n\tfloat width1 = rand(pos + 100.0) + 0.5;\n\tfloat width2 = rand(pos + 1500.0) + 0.5;\n\t\n\t//building height\n\t//vec3 k = vec3(1,height,1);\n\tvec3 k = vec3(max(0.0, width1), max(0.0, height += height * snoise(vec2((width1 * cos(time/5.)), width2 * sin(time/4.) ) )), max(0.0, width2));\n\treturn simpleBuilding(q,k);\n}\n\n\n// SIMPLE BUILDING (white)\nvec2 simpleBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5); //0.5\n\n\tq = mod(p,c)-0.5*c;\n\t\n\tfloat cr = sdCross(q*3.0)/3.0;\n\tbody = max( body, -cr );\n\t\n\t// top \"cap\" of building\n\tfloat top = sdBox(p-vec3(0,b.y,0),vec3(b.x, b.y/25.0, b.z)).x;\n\t\n\t// some buildings have an additional top that's slightly smaller\n\tif(fract(b.y/2.0) < 0.5){\n\t\tfloat c = fract(b.y)<0.2? 10.0:fract(b.y)*30.0; //if top portion is small enough, make it longer\n\t\tfloat toptop = sdBox(p-vec3(0,b.y+b.y/25.0,0),vec3(b.x*fract(b.y), b.y/c, b.z*fract(b.y))).x;\n\t\tbody = min(body,toptop);\n\t}\n\t\n\t// make a box inside to look like windows\n\tfloat inside = sdBox(p,vec3(b.x*0.9, b.y, b.z*0.9)).x;\n\tbody = min(inside,min(body,top));\n\t\t\n\tfloat outputColor = b.y;\n\tif(body==inside)\n\t\toutputColor = 99.0; // if inside is hit, shade with window color (99.0 is just placeholder value)\n\t\t\n\t\n  return vec2(body,outputColor);\n}\n\n\n\n// INFINITE TALL BUILDINGS RANDOM\nvec2 infiniteTallBuildings(in vec3 p){\n\t\n\tvec3 c = vec3(23,0,23); // how close cubes are to each other\n\t\n\tvec3 q = p;\n\t//repetition in x and z direction\n\tq.x = mod(p.x,c.x)-0.5*c.x;\n\tq.z = mod(p.z,c.z)-0.5*c.z;\n\t\n\tvec2 pos = vec2(ceil(p.x/c.x), ceil(p.z/c.z));\n\t\n\tfloat height = rand(pos)*20.0;\n\tif (fract(height)/2.0 < 0.4) //adding some variation in height\n\t\theight = height/2.0;\n\t\t\n\tfloat width1 = rand(pos + 80.0) + 0.5;\n\tfloat width2 = rand(pos + 500.0) + 0.5;\n\t\n\t//building height\n\n\tvec3 k = vec3(max(0.0, width1), max(0.0, height), max(0.0, width2));\n\treturn tallBuilding(q,k);\n}\n\n\n\n//TALL BUILDING (WHITE)\nvec2 tallBuilding (vec3 p, vec3 b ){\n\tfloat body = sdBox(p,b).x;\n\t\n\tvec3 q = p;\n\tvec3 c = vec3(0.5);\n\tq = mod(p,c)-0.5*c;\n\tfloat vert_bars = sdBox(q,vec3(0.1,INF,0.1)).x;\n\tbody = max(body, -vert_bars);\n\t\n\t//dividng ledge\n\tconst float ledgeheight = 0.2;\n\tfloat ledge = sdBox(p-vec3(0,b.y,0),vec3(b.x,ledgeheight,b.z)).x;\n\tbody = min(body,ledge);\n\t\n\t//2nd portion\n\tfloat body2 = sdBox(p-vec3(0,b.y+ledgeheight,0),b*vec3(0.8,0.2,0.8)).x;\n\tbody = min(body,body2);\n\t\n\t//3rd portion\n\tfloat body3 = sdBox(p-vec3(0,b.y+ledgeheight+b.y*0.2, 0), b*vec3(0.6,0.2,0.6)).x;\n\tbody = min(body3, body);\n\t\t\t    \n\t\n\treturn vec2(body,1);\n}\n\n// SD_CROSS (modified from IQ's original)\nfloat sdCross( in vec3 p ){\n\tconst float w = 0.4;\n  float da = sdBox(p.xyz,vec3(INF,w,w)).x;\n  float db = sdBox(p.yzx,vec3(w,INF,w)).x;\n  float dc = sdBox(p.zxy,vec3(w,w,INF)).x;\n  return min(da,db);\n}\n\n\n\n// ============COLORS============= //\n// Checkerboard Color\nvec3 color_checkers(in vec3 p){\n\tif (fract(p.x*.5)>.5)\n\tif (fract(p.z*.5)>.5)\n\treturn COLOR_GREY;\n\telse\n\treturn vec3(1,1,1);\n\telse\n\tif (fract(p.z*.5)>.5)\n\treturn vec3(1,1,1);\n\telse\n\treturn COLOR_GREY;\n}\n\n//Brick Color\nvec3 color_brick(in vec3 p){\t\n\tconst vec3 brickColor = vec3(0.2,0.2,0.2);\n\tconst vec3 mortarColor = vec3(0.8);\n\tconst vec2 brickSize = vec2(0.3,0.15);\n\tconst vec2 brickPct = vec2(0.9,0.85);\n\t\n\tvec2 position = (p.zy)/brickSize;\n\tvec2 useBrick = vec2(0);\n\t\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\t\t\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\t\n\tvec3 color =  mix(mortarColor, brickColor, useBrick.x*useBrick.y);\n\t\n\t\n\tposition = p.xy/brickSize;\n\tif(fract(position.y*0.5) > 0.5)\n\t\tposition.x += 0.5;\n\tposition = fract(position);\n\tuseBrick = step(position, brickPct);\n\tcolor = (color+mix(mortarColor, brickColor, useBrick.x*useBrick.y))/2.0;\n\t\n\treturn color;\n\t\n}\n\n// ==================== RAY MARCH =============================//\nvoid main(void){\n\t//Camera animation\n\tvec3 U=vec3(0,1,0);//Camera Up Vector\n\tvec3 viewDest=vec3(0,0,0); //Change camere view vector here\n\t//vec3 E; //moved to global space\n\tif (CAMERA_MODE == SPINNING_CAMERA)\n\tE=vec3(-sin(time/10.0)*10.0,5,cos(time/10.0)*10.0); //spinning scene\n\telse if(CAMERA_MODE == MOUSE_CAMERA){\n\t\tfloat spin = mouse.x * 8.0; //time * 0.1 + mouse.x * 8.0;\n\t\tE=vec3(-sin(spin)*10.0, 10.0 * mouse.y, cos(spin)*10.0);//Change camera path position here\n\t}\n\telse if(CAMERA_MODE == PAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tfloat mouse_val = mouse.y-0.5;\n\t\tE+=moveCamDir*time*(mouse_val>0.0?mouse_val:0.0);\n\t}\n\telse if(CAMERA_MODE == STILL_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);//Change camera path position here\n\t}\n\telse if (CAMERA_MODE == AUTOPAN_CAMERA){\n\t\tE=vec3(-sin(1.0)*10.0,7,cos(1.0)*10.0);\n\t\tvec3 moveCamDir = normalize(vec3(E.x,0.0,E.y));\n\t\tE+=moveCamDir*time;\n\t}\n\t\n\t\n\t//Camera setup\n\tvec3 C=normalize(viewDest-E);\n\tvec3 A=cross(C, U);\n\tvec3 B=cross(A, C);\n\tvec3 M=(E+C);\n\n\tvec2 vPos=2.0*gl_FragCoord.xy/resolution.xy - 1.0; // = (2*Sx-1) where Sx = x in screen space (between 0 and 1)\n\tvec3 P=M + vPos.x*A*resolution.x/resolution.y + vPos.y*B; //normalize resolution in either x or y direction (ie resolution.x/resolution.y)\n\tvec3 rayDir=normalize(P-E); //normalized direction vector from Eye to point on screen\n\t\n\t//Colors\n\tconst vec4 skyColor = vec4(0.7, 0.8, 1.0, 1.0);\n\tconst vec4 sunColor = vec4 (1.0, 0.9, 0.7, 1.0);\n\t\n\t//Raymarching\n\tconst vec3 e=vec3(0.1,0,0);\n\tconst float MAX_DEPTH=170.0; //Max depth use 500\n\tconst int MAX_STEPS = 100; // max number of steps use 150\n\tconst float MIN_DIST = 0.01;\n\n\tvec2 dist=vec2(0.0,0.0);\n\tfloat totalDist=0.0;\n\tvec3 c,p,n; //c=color (used in PHONG and RAYMARCH modes), p=ray position, n=normal at any point on the surface\n\n\tint steps = 0;\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tsteps++;\n\t\ttotalDist+=dist.x*0.7; //use smoothing constant\n\t\tp=E+rayDir*totalDist; // p = eye + total_t*rayDir\n\t\tdist=distanceField(p);\n\t\tif (abs(dist.x)<MIN_DIST) break; // break when p gets sufficiently close to object or exceeds max dist\n\t}\n\n\tvec4 finalColor = skyColor;\n\t\n\tif (totalDist<MAX_DEPTH){\n\t\t// check which color to use via the y-component\n\t\tif (dist.y==0.0) // floorPlane color\n\t\tc=color_checkers(p);\n\t\telse if(dist.y==1.0) // building color\n\t\tc=COLOR_WHITE;\n\t\t\n\t\tif(SHADING_MODE==PHONG_SHADING){\n\t\t\t// compute normal at this point on the surface using a gradient vector\n\t\t\tn=normalize(\n\t\t\tvec3(\n\t\t\tdist.x-distanceField(p-e.xyy).x,\n\t\t\tdist.x-distanceField(p-e.yxy).x,\n\t\t\tdist.x-distanceField(p-e.yyx).x));\n\t\t\t\n\t\t\t//e.xyy is equal to (0.001,0.0,0.0) \n\t\t\t//e.yxy is equal to (0.0,0.001,0.0)\n\t\t\t//e.xxy is equal to (0.0,0.0,0.001)\n\n\t\t\t//simple phong LightPosition=CameraPosition\t   \n\t\t\tfloat b=dot(n,normalize(E-p));\n\t\t\tfinalColor=vec4((b*c+pow(b,8.0))*(1.0-totalDist*.01),1.0);\n\t\t}\n\t\telse if (SHADING_MODE==RAYMARCH_SHADING){\n\t\t\t//Shading based on raymarched distance\n\t\t\tfloat v = 1.0-float(steps)/float(MAX_STEPS);\n\t\t\tfloat R=v*c.r, G=v*c.g, B=v*c.b;\n\t\t\tfinalColor=vec4(R,G,B,1.0);\n\t\t}\n\t\telse if (SHADING_MODE==TEST_SHADING){\n\t\t\tvec3 sunDir = vec3(normalize(viewDest-E)); //sun comes from the camera\n\t\t\t\n\t\t\tvec3 N = normalize(vec3(\n\t\t\tdistanceField(p).x-distanceField(p-e.xyy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yxy).x,\n\t\t\tdistanceField(p).x-distanceField(p-e.yyx).x)); //normal at point\n\t\t\t\n\t\t\tvec3 L = sunDir;\n\t\t\tvec3 V = normalize(E-p);\n\t\t\t\n\t\t\t// color info is stored in y component\n\t\t\t\n\t\t\tif(fract(dist.y) < 0.5) // building color (half of the buildings are brick)\n\t\t\t\tfinalColor=vec4(color_brick(p),1.0);\n\t\t\tif(fract(dist.y) >= 0.5)\n\t\t\t\tfinalColor = vec4(COLOR_GREY,1.0);\n\t\t\tif (dist.y==0.0) // floorPlane color\n\t\t\t\tfinalColor=vec4(COLOR_BLACK,1.0);\n\t\t\tif (dist.y == 99.0)\n\t\t\t\tfinalColor = vec4(COLOR_WINDOW,1);\n\t\t\n\t\t\t\n\t\t\t//calculate lighting: diffuse + sunlight\n\t\t\tfloat diffuseTerm = clamp(dot(V,N), 0.0, 1.0);\n\t\t\tfinalColor = mix(finalColor, sunColor, diffuseTerm*0.55);\t\t\t\n\t\t\t\n\t\t}\n\t}\n\t//apply fog\n\tvec3 r = p-E;\n\tfinalColor = applyFog(finalColor, r);\n\tgl_FragColor = finalColor;\n}\n\n\n// Fog (credit: http://www.mazapan.se/news/2010/07/15/gpu-ray-marching-with-distance-fields/)\nvec4 applyFog (in vec4 currColor, in vec3 ray){\n\tfloat rayLength = length(ray);\n\tvec3 nRay = ray/rayLength;\n\t\n\tfloat fogAmount = 1.0-exp(-rayLength * 0.02); //0.008\n\tfloat sunAmount = 0.0;//pow( max( dot (nRay, sunDir), 0.0), 8.0);\n\t\n\tvec4 fogColor = mix(vec4(0.5,0.6,0.7,1.0), vec4(1.0,0.9,0.7,1.0), sunAmount);\n\treturn mix(currColor, fogColor, fogAmount);\n}\n", "user": "aa8b273", "parent": "/e#10329.1", "id": "10370.1"}