{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4scBW8\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n#define FOV 2.0\n\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat de( in vec3 p, in vec3 dir, in float r, out vec3 color ) {\n    // accumulate distance and color\n    float d = 9e9;\n    color = vec3(0);\n    float colorAcc = 0.0;\n    \n    // hexagonal tiling\n    const vec2 dim = vec2(1, 1.73205080757);\n    vec2 centerA = (floor(p.xy*dim)+0.5)/dim;\n    vec2 centerB = (floor((p.xy+dim*0.5)*dim)+0.5)/dim-dim*0.5;\n    vec2 a = p.xy-centerA.xy; vec2 b = p.xy-centerB.xy;\n    vec2 center = dot(a,a)<dot(b,b) ? centerA : centerB;\n\t\n    for (int i = 0 ; i < 7 ; i++) {\n        float theta = float(i) * (2.0*PI/6.0);\n        vec2 offset = vec2(sin(theta), cos(theta))*min(1.0/dim.y, float(i));\n        vec3 sphere = vec3(center + offset, 0);\n        sphere.z = sin(sphere.x-sphere.y*4.3+iTime)*0.2;\n\n        vec3 inCenter = p - sphere;\n        float len = length(inCenter);\n        vec3 norm = inCenter / len;\n\n        // select the nearest sphere\n        float dist = len-0.3;\n        d = min(d, dist);\n\n        // colors and light\n        vec3 colorHere = vec3(sin(sphere.x*90.0+sphere.y*80.0)*0.45+0.5);\n        const vec3 lightDir = normalize(vec3(1, -1, 3));\n        colorHere *= vec3(max(0.0, dot(lightDir, norm)));\n        colorHere += pow(max(0.0, dot(lightDir, reflect(dir, norm))), 8.0);\n        \n        // accumulate color across neighborhood\n        float alpha = max(0.0001, smoothstep(r, -r, dist));\n        color += colorHere*alpha;\n        colorAcc += alpha;\n    }\n    \n    color /= colorAcc;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\tvec3 from = vec3(iTime, iTime, 1.2);\n\tvec3 dir = normalize(vec3(uv, -1.0/tan(FOV*0.5)));\n\tdir.yz *= rot(-0.85);\n    dir.xy *= rot(0.2);\n    \n    float sinPix = sin(FOV / iResolution.y);\n    vec4 acc = vec4(0, 0, 0, 1);\n    vec3 dummy = vec3(0);\n    float totdist = de(from, dir, 0.0, dummy)*hash13(vec3(fragCoord, iTime));\n    for (int i = 0 ; i < 100 ; i++) {\n\t\tvec3 p = from + totdist * dir;\n        float r = max(totdist*sinPix, abs((totdist-2.5)*0.1));\n        vec3 color = vec3(1);\n        float dist = de(p, dir, r, color);\n        \n        // cone trace the surface\n\t\tfloat alpha = smoothstep(r, -r, dist);\n        acc.rgb += acc.a * (alpha*color.rgb);\n        acc.a *= (1.0 - alpha);\n        \n        // hit a surface, stop\n        if (acc.a < 0.01) break;\n        // continue forward\n        totdist += max(abs(dist), r*0.5);\n\t}\n    \n    fragColor.rgb = clamp(acc.rgb, vec3(0), vec3(1));\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    fragColor.a = 1.0;\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "c0bdfe8", "parent": null, "id": "46649.0"}