{"code": "// Forked to say that this looks absolutely cool! Nice work David!\n// @rianflo\n\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Mars rover. By David Hoskins, December 2013.\n// https://www.shadertoy.com/view/Md23Wz\n\n// Uses sphere tracing to accumulate normals across the landscape.\n// Materials are calculated after the tracing loop,\n// so only the normal can be used as reference.\n// The square of the distance is used for the sphere diameter to create depth of field.\n// Probably needs faster landscape code.\n\n// For red/cyan 3D...\n//#define STEREO\n\nvec3 sunLight  = normalize( vec3(  0.35, 0.1,  0.3 ) );\nvec3 cameraPos;\nvec3 sunColour = vec3(1.0, .75, .4);\nconst mat2 rotate2D = mat2(1.732, 1.323, -1.523, 1.652);\nfloat gTime = 0.0;\n\n//--------------------------------------------------------------------------\n// Noise functions...\nfloat Hash( float n )\n{\n    return fract(sin(n)*56753.545383);\n}\n\n//--------------------------------------------------------------------------\nfloat Hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 63758.5453);\n}\n\nvec3 NoiseD( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 u = fract(x);\n    float n = p.x + p.y*57.0;\n    float a = Hash(n+  0.0);\n    float b = Hash(n+  1.0);\n    float c = Hash(n+ 57.0);\n    float d = Hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*u*u*(u*(u-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\n//--------------------------------------------------------------------------\nfloat Terrain( in vec2 p)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.004;\n\tfloat w = 60.0;\n\tfloat f = .0;\n\tvec2  d = vec2(0.0);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\t//f += Noise(pos) * w;\n        vec3 n = NoiseD(pos);\n        d += n.yz;\n        f += w * n.x/(1.0+dot(d,d));\n\t\tw = w * 0.52;\n\t\tpos = rotate2D * pos;\n\t}\n\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\nfloat Terrain2( in vec2 p, in float sphereR)\n{\n\tfloat type = 0.0;\n\tvec2 pos = p*0.004;\n\tfloat w = 60.0;\n\tfloat f = .0;\n\tvec2  d = vec2(0.0);\n\t// Set a limit to the loop as further away terrain doesn't need fine detail.\n\tint t = 10-int(sphereR);\n\tif (t < 5) t = 5;\n\t\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tif (i > t) continue;\n        vec3 n = NoiseD(pos);\n        d += n.yz;\n        f += w * n.x/(1.0+dot(d,d));\n\t\tw = w * 0.52;\n\t\tpos = rotate2D * pos;\n\t}\n\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\nfloat Map(in vec3 p)\n{\n\tfloat h = Terrain(p.xz);\n    return p.y - h;\n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\nvec3 GetSky(in vec3 rd)\n{\n\tfloat sunAmount = max( dot( rd, sunLight), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.2), vec3(.42, .2, .1), v);\n\tsky *= smoothstep(-0.3, .0, rd.y);\n\tsky = sky + sunColour * sunAmount * sunAmount * .25;\n\tsky = sky + sunColour * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\n//--------------------------------------------------------------------------\nfloat SphereRadius(float t)\n{\n\tt = abs(t-60.0);\n\treturn max(t*t*0.0002, 0.2);\n}\n\n//--------------------------------------------------------------------------\nfloat Linstep(float a, float b, float t)\n{\n\treturn clamp((t-a)/(b-a),0.,1.);\n}\n\n//--------------------------------------------------------------------------\n// Calculate sun light...\nvec3 DoLighting(in vec3 mat, in vec3 normal, in vec3 eyeDir)\n{\n\tfloat h = dot(sunLight,normal);\n\treturn mat * sunColour*(max(h, 0.0)+.1);\n}\n\n//--------------------------------------------------------------------------\nvec4 Scene(in vec3 rO, in vec3 rD)\n{\n    float t = 0.0;\n\tfloat alpha;\n\tvec4 normal = vec4(0.0);\n\tvec3 p = vec3(0.0);\n\tfor( int j=0; j < 100; j++ )\n\t{\n\t\tif (normal.w > .8 || t > 600.0) break;\n\t\tp = rO + t*rD;\n\t\tfloat sphereR = SphereRadius(t);\n\t\tfloat h = Map(p);\n\t\th += sphereR * .5;\n\t\tif( h < sphereR)\n\t\t{\n\t\t\t// Accumulate the normals...\n\t\t\tvec2 j = vec2(sphereR * .5, 0.0);\n\t\t\tvec3 nor  \t= vec3(0.0,\t\tTerrain2(p.xz, sphereR), 0.0);\n\t\t\tvec3 v2\t\t= nor-vec3(j.x,\tTerrain2(p.xz+j, sphereR), 0.0);\n\t\t\tvec3 v3\t\t= nor-vec3(0.0,\tTerrain2(p.xz-j.yx, sphereR), -j.x);\n\t\t\tnor = cross(v2, v3);\n\t\t\tnor = normalize(nor);\n\t\t\talpha = (1.0 - normal.w) * Linstep(-sphereR, sphereR, -h);\n\t\t\tnormal += vec4(nor * alpha, alpha);\n\t\t}\n\t\t//t += max(h*.5, t*.01)+0.01;\n\t\t//t += max(h*.75, (t*t*0.0001));\n\t\tt += h * .75 + .1;\n\t}\n\t// Scale the alpha up to meet 1.0...\n\tnormal.w = clamp(normal.w * 1.25, 0.0, 1.0);\n\treturn normal;\n}\n\n//--------------------------------------------------------------------------\nvec3 CameraPath( float t )\n{\n\t//t = time + t;\n    vec2 p = vec2(200.0 * sin(3.54*t), 200.0 * cos(2.0*t) );\n\treturn vec3(p.x+25.0,  0.0+sin(t*.3)*6.5, 0.0+p.y);\n} \n\n//--------------------------------------------------------------------------\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\t// Gamma first...\n\trgb = pow(rgb, vec3(0.45));\n\t\n\t// Then...\n\t#define CONTRAST 1.4\n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t// Vignette...\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n//--------------------------------------------------------------------------\nvoid main(void)\n{\n\t\n\tfloat gTime = (time*5.0+2352.0)*.006;\n\tfloat hTime = time;\n    \tvec2 xy = gl_FragCoord.xy / resolution.xy;\n\tvec2 uv = (-1.0 + 2.0 * xy) * vec2(resolution.x/resolution.y,1.0);\n\tvec3 camTar;\n\t\n\t#ifdef STEREO\n\tfloat isCyan = mod(gl_FragCoord.x + mod(gl_FragCoord.y,2.0),2.0);\n\t#endif\n\n\tcameraPos = CameraPath(gTime + 0.0);\n\n\tfloat height = max(0.0, 9.0-hTime)*16.0;\n\tcamTar\t = CameraPath(gTime + .3);\n\tcameraPos.y += height*2.0-5.0;\n\n\t\n\tfloat t = Terrain(CameraPath(gTime + .009).xz)+10.0;\n\tif (cameraPos.y < t) cameraPos.y = t;\n\tcamTar.y = cameraPos.y-height*1.0;\n\n\tfloat roll = .4*sin(gTime+.5);\n\tvec3 cw = normalize(camTar-cameraPos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = cross(cw,cp);\n\tvec3 cv = cross(cu,cw);\n\tvec3 dir = normalize(uv.x*cu + uv.y*cv + 1.3*cw);\n\tmat3 camMat = mat3(cu, cv, cw);\n\n\t#ifdef STEREO\n\tcameraPos += .85*cu*isCyan; // move camera to the right - the rd vector is still good\n\t#endif\n\n\tvec3 col;\n\tfloat distance;\n\tvec4 normal;\n\tnormal = Scene(cameraPos, dir);\n\tnormal.xyz = normalize(normal.xyz);\n\tcol = mix(vec3(.45, 0.4, 0.3), vec3(.2, 0.05, 0.0),smoothstep(0.5, 1.5, (normal.y)));\n\tcol += vec3(0.3, 0.3, 0.3) * clamp(normal.z, 0.0, 1.0);\n\n\tif (normal.w > 0.0) col = DoLighting(col, normal.xyz, dir);\n\n\tcol = mix(GetSky(dir), col, normal.w);\n\n\t// bri is the brightness of sun at the centre of the camera direction.\n\t// Yeah, the lens flares is not exactly subtle, but it was good fun making it.\n\tfloat bri = dot(cw, sunLight)*.7;\n\tif (bri > 0.0)\n\t{\n\t\t// Rotate the sun to 2D, but backwards...\n\t\tvec2 sunPos = (-camMat * sunLight).xy;\n\t\t\n\t\tbri = pow(bri, 7.0)*.8;\n\n\t\t// glare = the red shifted blob...\n\t\tfloat glare1 = max(dot(normalize(vec3(dir.x, dir.y+.3, dir.z)),sunLight),0.0)*1.4;\n\n\t\t// glare2 is the yellow dot...\n\t\tfloat glare2 = max(1.0-length(sunPos - uv*2.1), 0.0);\n\t\t\n\t\t// glare2 is the small white circle past centre point...\n\t\tfloat glare3 = max(sin(smoothstep(-0.4, .7, length(sunPos + uv*2.5))*3.0), 0.0);\n\n\t\tcol += bri * vec3(1.0, .0, .0)   * pow(glare1, 12.5)*.05;\n\t\tcol += bri * vec3(1.0, 1.0, 0.0) * pow(glare2, 3.0)*4.0;\n\t\tcol += bri * vec3(1.0, 1.0, 1.0) * pow(glare3, 33.9)*.7;\n\t\t//col += bri * pow(bri, 2.0)*30.0;\n\t}\n\tcol = PostEffects(col, xy);\t\n\t\n\t#ifdef STEREO\t\n\tcol *= vec3( isCyan, 1.0-isCyan, 1.0-isCyan );\t\n\t#endif\n\t\n\tgl_FragColor=vec4(col,1.0);\n}\n\n//--------------------------------------------------------------------------", "user": "b2e8e71", "parent": "/e#12688.0", "id": "12705.0"}