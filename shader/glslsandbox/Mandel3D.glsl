{"code": " /**\\  /**\\ \n/*||*\\\t||\n  ||\tLt==> Change  resolution to 1 :)\n  ||\n  Lt==> Click hide code :*\n\n*/\n\n\n\n//////////////////////////////////\n//\t\t\t\t//\n//          VRG corp\t      \t//\n//\t\t\t\t//\n//        Le kubikoto,\t\t//\n//\t   Le kubikoto,\t\t//\n//\t    Le kubikoto,\t//\n//\t       ....\t\t//\n//   A les plus gros biscotos   //\n//\t\t\t       //\n//////////////////////////////// *\n\n\n// Tried some simple volume rendering attempt :)\n// Added some correctness\n// A bit more correct :D\n\n// comment to get original density function\n//#define ALT_DENSITY\n//#define ALT_DENSITY_2\n\n\n// comment to display density in greyscale\n#define ENABLE_COLORS\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define INF  20.\n#define EPSILON  0.0043543454301\n#define PI  3.14159265359\n\n\n//#define time 176.\n\n#define BOX_SPEED 0.\n#define BOX_THICKNESS (.5*INF/10.)\n#define BOX_SIZE 2.*INF/20.\n#define BOX_P vec3(0., 0., sin(time*BOX_SPEED)*PI*INF/20.)\n#define BOX_ROT BOX_P.z\n#define BOX_DE max(sdSphere(vec3(rotate(p.xy, BOX_ROT), p.z)-BOX_P, BOX_SIZE), sdBox(vec3(rotate(p.xy, BOX_ROT), p.z)-BOX_P, vec3(BOX_SIZE, BOX_SIZE, BOX_THICKNESS)))\n\n\n\n/* Begin of rendering functions declaration */\nfloat map(vec3 p);\nvec3 raymarch(vec3 origin, vec3 dir);\nvec3 raymarch32(vec3 origin, vec3 dir);\nvec3 getNormal(vec3 p);\nvec3 getColor(vec3 dir, vec3 p, vec3 normal);\n/* End of rendering functions declaration */\n\n/* Begin of geometric/math functions declaration */\nvec2 rotate(vec2 p, float angle);\nfloat rand(vec2 n);\nfloat noise(vec2 n);\n/* End of geometric/math functions declaration */\n\n\n/* Begin of volumes distance functions declaration */\nfloat sdSphere(vec3 p, float r);\nfloat sdBox(vec3 p, vec3 b);\n/* End of volumes distance functions declaration */\n\n/* Begin of transform functions declaration */\nvec3 hsv2rgb(vec3 c);\n/* End of transform functions declaration */\n\n\n/* Begin of the definition of global variables */\n\n\nfloat fov = 45.; // Fake fov :*\n\nfloat viewRot;\nvec3 origin;\nvec3 lightPosition;\n\nint object = 0;\nfloat acc_density = 0.;\n\n/* End of the definition of global variables */\n\nvoid main( void ) {\n\n\tviewRot = mod(time, 120.*PI)*.1 ;\n\torigin = vec3(INF/3.5*cos(viewRot), INF/16.*sin(time*.1), INF/3.5*sin(viewRot));\n\tlightPosition = vec3(cos(-time*.45)*.5*INF, INF/6., sin(-time*.45)*.5*INF);\n\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy) - vec2(.5);\n\t\t\n\tuv.x *= resolution.x/resolution.y;\n\t\n\tuv.xy*=fov/45.;\n\t\n\tvec3 eyeDir = normalize(vec3(uv, 1.));\n\tvec3 dir = eyeDir;\n\tdir.xz = rotate(dir.xz, viewRot+ PI/2. );\n\t\n\tvec3 hit = raymarch(origin, dir);\n\tvec3 normal = getNormal(hit.xyz);\n\t\n\t\n\tvec3 p = hit;\n\tbool inCube = false;\n\tif(BOX_DE < EPSILON){\n\t\tobject = 1;\n\t\tinCube = true;\n\t}\n\t\n\tvec3 color = getColor(dir, hit.xyz, normal);\n\t\n\tvec3 reflectDir = reflect(dir, normal);\n\tvec3 reflectHit = raymarch(hit + reflectDir, reflectDir);\n\tvec3 reflectNormal = getNormal(reflectHit.xyz);\n\t\n\tdir = refract(dir, normal, 0.9); \n\t\n\tfloat incr = BOX_THICKNESS*2./32.;\n\t\n\t\t\thit = hit.xyz + dir*BOX_DE*2.;\n\tif(inCube){\n\t\tacc_density = 0.;\n\t\tfor(int n = 0; n < 64; n++){\n\t\t\thit = hit.xyz + dir*incr;\n\t\t\t\n\t\t\tcolor = mix(color, getColor(dir, hit, getNormal(hit)), clamp(1.-acc_density, 0., 1.));\n\t\t\tif(abs(normal.z) == 0. && n >=32 ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\tdir = refract(dir, normal, 1.1); \n\t\thit = raymarch32(hit+dir*10., dir);\n\t\tnormal = getNormal(hit.xyz);\n\t\t\n\t\tobject = 0;\n\t\t\n\t\tcolor = mix(color, getColor(dir, hit, normal), clamp(1.-acc_density, 0., 1.)*1.);\n\t\t\n\t\t\n\t\n\t}\n\t\n\tif(inCube){\n\t\tp = reflectHit;\n\t\tobject = 0;\n\t\tif(BOX_DE < EPSILON){\n\t\t\tobject = 1;\n\t\t}\n\t\tvec3 reflectColor = getColor(reflectDir, reflectHit.xyz, reflectNormal);\n\t\t\n\t\tcolor = mix(color, reflectColor, .25);\n\t}\n\tcolor = pow(max(color, vec3(0.)), vec3(1.0 / 1.2));\n\tgl_FragColor = vec4(color, 1.0 );\n\n}\n\n\n\n\nvec3 raymarch(vec3 origin, vec3 dir){\n\tfloat d;\n\tfloat dist;\n\tfor(int i = 0; i < 128; i++){\n\t\td = map(origin);\n\t\tif(d < EPSILON){\n\t\t\tdist = float(i);\n\t\t\tbreak;\n\t\t}\n\t\torigin+=dir*d*.6;\n\t}\n\treturn origin;\n}\n\n\nvec3 raymarch32(vec3 origin, vec3 dir){\n\tfloat d;\n\tfloat dist;\n\tfor(int i = 0; i < 32; i++){\n\t\td = map(origin);\n\t\tif(d < EPSILON){\n\t\t\tdist = float(i);\n\t\t\tbreak;\n\t\t}\n\t\torigin+=dir*d;\n\t}\n\treturn origin;\n}\n\n\nvec3 getNormal(vec3 p){\n  \tvec3 n;\n  \tn.x = map(vec3(p.x+EPSILON, p.y, p.z));\n  \tn.y = map(vec3(p.x, p.y+EPSILON, p.z));\n  \tn.z = map(vec3(p.x, p.y, p.z+EPSILON));\n  \treturn normalize(n-map(p));\n}\n#ifdef ALT_DENSITY\n\t\n\tfloat boxDensity(vec3 p){\n\t\t// Put any volume describing function here :)))))\n\t\treturn clamp(cos(p.x*10.)*cos(p.y*10.)*cos(p.z*10.), 0., 1.)*.25;\n\t}\n#else\n\t#ifdef ALT_DENSITY_2\n\t\t\n\t\tfloat boxDensity(vec3 p){\n\t\t\treturn clamp((1.-step(0.2,distance(p.xy, vec2(cos(p.x+time), sin(p.z+time))) ))*(.75+.25*cos(p.z+time)), 0., 1.)*.25;\n\t\t}\n\t#else\n\t\tfloat boxDensity(vec3 p){\n\t\t\tfloat x0 = -p.y-.777;\n\t\t\tfloat y0 = p.x;\n\t\t\tfloat x = p.z;\n\t\t\tfloat y = .0;\n\t\t\tint iteration = 0;\n\t\t\tconst int max_iteration = 50;\n\t\n\t\t\tfor (int i = 0; i < max_iteration; i++) {\n\t\t\t\tif(x*x + y*y < (exp(time)*2. + 2.)) {\n\t\t\t\tfloat xtmp = x*x - y*y + x0;\n\t\t\t\ty = 2.*x*y + y0;\n\t\t\t\tx = xtmp;\n\t\t\t\titeration ++;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tif (iteration == max_iteration) { return 0.7; }\n\t\t\treturn float(iteration)/float(max_iteration) * 0.1;\n\t\t}\n\t#endif\n#endif\n\nvec3 getColor(vec3 dir, vec3 p, vec3 normal){\n\tvec3 color = vec3(.5)+.5*normal;\n\tif(object == 1){\n\t\tfloat weight = boxDensity(p)*smoothstep(abs(p.z)*.9,abs(p.z),BOX_THICKNESS)*smoothstep(length(p)*.9, length(p),BOX_SIZE);\n\t\t#ifdef ENABLE_COLORS\n\t\t\tcolor = hsv2rgb(vec3(weight*PI, 1., 1.));\n\t\t#else\n\t\t\tcolor = vec3(weight);\n\t\t#endif\n\t\tacc_density+=weight;\n\t} else {\n\t\tcolor = vec3(1.);\n\t\tfloat shade = clamp(dot(normal, normalize(lightPosition-p)), 0., 1.);\n\t\tshade = shade*.5+.5;\n\t\tshade*=shade*shade;\n\t\tshade *= 1.-distance(lightPosition, p)*.5/INF;\n\t\tcolor*=shade*.95+.05;\n\t}\n\treturn color;\n}\n\n\n\nfloat map(vec3 p){\n\tfloat d = -sdBox(p, vec3(INF, INF/2., INF));\n\td = min(d, BOX_DE);\n\t\n\treturn d;\n}\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p) - r;\t\n}\n\n\n\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 rotate(vec2 p, float angle){\n\treturn vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\n}\n\n\nfloat sfract(float n){\n    \treturn smoothstep(0.0,1.0,fract(n));\n}\n\nfloat rand(vec2 n){\n \treturn fract(abs(sin(dot(n,vec2(5.3357,-5.8464))))*256.75+0.325);   \n}\n\nfloat noise(vec2 n){\n\tfloat h1 = mix(rand(vec2(floor(n.x),floor(n.y))),rand(vec2(ceil(n.x),floor(n.y))),sfract(n.x));\n\tfloat h2 = mix(rand(vec2(floor(n.x),ceil(n.y))),rand(vec2(ceil(n.x),ceil(n.y))),sfract(n.x));\n    \tfloat s1 = mix(h1,h2,sfract(n.y));\n    \treturn s1;\n}\n\n// http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\t\n", "user": "fd18cc", "parent": "/e#23760.2", "id": "23818.2"}