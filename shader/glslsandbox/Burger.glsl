{"code": "// https://twitter.com/FMS_Cat\n\n// ------\n\n#define MARCH_ITER 50\n#define INIT_LEN 0.01\n#define MARCH_MULT 0.8\n\n#define material float\n#define MTL_NONE 0.0\n#define MTL_BASE 1.0\n#define MTL_MEAT 2.0\n#define MTL_HAPPA 3.0\n#define MTL_CHEESE 4.0\n#define MTL_TOMATO 5.0\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n\n// ------\n\n// \u6d6e\u52d5\u5c0f\u6570\u70b9\u306e\u7cbe\u5ea6\u306e\u8a2d\u5b9a\nprecision mediump float;\n\n// JS\u304b\u3089\u6e21\u3055\u308c\u308b\u5909\u6570\u306e\u5b9a\u7fa9\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// ------\n\n// \u4e8c\u6b21\u5143\u56de\u8ee2\u884c\u5217\nmat2 rotate2D( float _t ) {\n  return mat2(\n    cos( _t ), sin( _t ),\n    -sin( _t ), cos( _t )\n  );\n}\n\n// smooth minimum : http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float _a, float _b, float _k, out float h ) {\n  h = clamp( 0.5 + 0.5 * ( _b - _a ) / _k, 0.0, 1.0 );\n  return mix( _b, _a, h ) - _k * h * ( 1.0 - h );\n}\n\nfloat smin( float _a, float _b, float _k ) {\n  float h;\n  return smin( _a, _b, _k, h );\n}\n\nfloat random( vec2 _uv ) {\n  return fract( sin( dot( vec2( 12.563, 21.864 ), _uv ) ) * 19934.54 );\n}\n\nfloat iRandom( vec2 _uv ) {\n  float v00 = random( floor( _uv + V.xx ) );\n  float v10 = random( floor( _uv + V.yx ) );\n  float v01 = random( floor( _uv + V.xy ) );\n  float v11 = random( floor( _uv + V.yy ) );\n  return mix(\n    mix( v00, v10, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    mix( v01, v11, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    smoothstep( 0.0, 1.0, fract( _uv.y ) )\n  );\n}\n\nfloat noise( vec2 _uv ) {\n  float sum = 0.0;\n  for ( int i = 0; i < 4; i ++ ) {\n    float p = pow( 2.0, float( i ) + 1.0 );\n    sum += iRandom( _uv * p * 4.0 ) / p;\n  }\n  return sum;\n}\n\nvec3 rainbow( vec3 _i, float _p ) {\n  float p = fract( _p );\n  return mix(\n    mix(\n      mix(\n        _i.xyz,\n        _i.yzx,\n        saturate( p * 3.0 )\n      ),\n      _i.zxy,\n      saturate( p * 3.0 - 1.0 )\n    ),\n    _i.xyz,\n    saturate( p * 3.0 - 2.0 )\n  );\n}\n\n// ------\n\n// \u30ab\u30e1\u30e9\u306e\u69cb\u9020\u4f53\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\n// \u30ec\u30a4\u306e\u69cb\u9020\u4f53\nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\n// \u30ab\u30e1\u30e9\u306e\u521d\u671f\u5316\nCamera camInit( in vec3 _pos, in vec3 _tar, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, V.xyx ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\n// \u30ec\u30a4\u306e\u521d\u671f\u5316\nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\n// \u30ab\u30e1\u30e9\u304b\u3089\u51fa\u308b\u30ec\u30a4\u3092\u6c42\u3081\u308b\nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\n// \u7403\u4f53\u306e\u8ddd\u96e2\u95a2\u6570\nfloat distFuncSphere( vec3 _p, float _r ) {\n  return length( _p ) - _r;\n}\n\n// \u7bb1\u306e\u8ddd\u96e2\u95a2\u6570\nfloat distFuncBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// \u30c8\u30fc\u30e9\u30b9\u306e\u8ddd\u96e2\u95a2\u6570\nfloat distFuncTorus( vec3 _p, float _r, float _R ) {\n  vec2 q = vec2( length( _p.xz ) - _R, _p.y );\n  return length( q ) - _r;\n}\n\n// \u5186\u67f1\u306e\u8ddd\u96e2\u95a2\u6570\nfloat distFuncPillar( vec3 _p, float _r, float _t ) {\n  return max( abs( _p.y ) - _t, length( _p.xz ) - _r );\n}\n\n// xz\u5186\u72b6\u306bRepetition\nvec3 circleRep( vec3 _p, float _r, float _c ) {\n  vec3 p = _p;\n  float intrv = PI * 2.0 / _c;\n  p.zx = rotate2D( floor( atan( p.z, p.x ) / intrv ) * intrv ) * p.zx;\n  p.zx = rotate2D( intrv / 2.0 ) * p.zx;\n  p.x -= _r;\n  return p;\n}\n\n// \u8ddd\u96e2\u95a2\u6570\nfloat distFunc( vec3 _p, out material mtl ) {\n  vec3 p = _p;\n  float dist = HUGE;\n  \n  { // base\n    vec3 p = p;\n    p.y -= -0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.1;\n    float distt = distFuncPillar( p, 0.85, 0.02 );\n    distt = smin( distt, distFuncTorus( ps, 0.1, 0.9 ), 0.1 );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // top\n    vec3 p = p;\n    p.y *= 2.5;\n    p.y -= 0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.2;\n    float distt = max(\n      distFuncSphere( ps, 1.0 ),\n      -p.y\n    );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // niku\n    vec3 p = p;\n    p.y += ( noise( p.zx * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.x += ( noise( p.yz * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.z += ( noise( p.xy * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.y -= -0.15;\n    float distt = distFuncPillar( p, 1.0, 0.05 );\n    distt = smin( distt, distFuncTorus( p, 0.05, 1.0 ), 0.1 );\n    mtl = distt < dist ? MTL_MEAT : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // happa\n    vec3 p = p;\n    p += vec3(\n      noise( p.yz * 0.4 - 0.7 ) - 0.5,\n      noise( p.zx * 0.4 - 0.7 ) - 0.5,\n      noise( p.xy * 0.4 - 0.7 ) - 0.5\n    ) * 0.5 * smoothstep( 1.0, 1.2, length( p.xz ) );\n    p.y -= 0.1;\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 1.15, 0.01 );\n    mtl = distt < dist ? MTL_HAPPA : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // cheese\n    vec3 p = p;\n    p.y -= -0.05;\n    p.y -= -0.2 * smoothstep( 1.0, 1.5, length( p.xz ) );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncBox( p, vec3( 0.95, 0.02, 0.95 ) );\n    mtl = distt < dist ? MTL_CHEESE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // tomato\n    vec3 p = p;\n    p.y -= 0.02;\n    p = circleRep( p, 0.6, 3.0 );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 0.5, 0.05 );\n    float fresh = 0.99 * smoothstep( 0.15, 0.4, length( p ) ) * smoothstep( 0.45, 0.4, length( p ) );\n    fresh *= 0.5 + 0.5 * sin( atan( p.z, p.x ) * 16.0 );\n    mtl = distt < dist ? ( MTL_TOMATO + fresh ) : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  material dummy = MTL_NONE;\n  return distFunc( _p, dummy );\n}\n\n// \u8ddd\u96e2\u95a2\u6570\u304b\u3089\u6cd5\u7dda\u3092\u6c42\u3081\u308b\nvec3 normalFunc( in vec3 _p ) {\n  vec2 d = V * 1E-3;\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvec4 draw( vec2 p, float time ) { \n  // \u30ab\u30e1\u30e9\u3068\u30ec\u30a4\u3092\u5b9a\u7fa9\n  Camera cam = camInit(\n    vec3( cos( time ) * 4.0, 1.0, sin( time ) * 4.0 ),\n    vec3( 0.0, -0.2, 0.0 ),\n    50.0\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  // ------\n\n  float rayLen = INIT_LEN; // \u63a2\u7d22\u30ec\u30a4\u306e\u9577\u3055\n  vec3 rayPos = ray.ori + rayLen * ray.dir; // \u63a2\u7d22\u30ec\u30a4\u306e\u4f4d\u7f6e\n  float rayDist = 0.0; // \u63a2\u7d22\u30ec\u30a4\u5230\u9054\u70b9\u304b\u3089\u7269\u4f53\u307e\u3067\u306e\u8ddd\u96e2\n  material mtl = MTL_NONE;\n\n  // raymarch\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    rayDist = distFunc( rayPos, mtl );\n    rayLen += rayDist * MARCH_MULT;\n    rayPos = ray.ori + rayLen * ray.dir;\n    if ( 10.0 < rayLen ) { return vec4( 0.0 ); }\n    if ( rayLen < 1E-4 ) { break; }\n  }\n\n  vec4 col = V.xxxx; // \u51fa\u529b\u3059\u308b\u8272\n  if ( rayDist < 1E-2 ) { // \u3082\u3057\u7269\u4f53\u306b\u885d\u7a81\u3057\u305f\u306a\u3089\n    // \u5404\u30d9\u30af\u30c8\u30eb\u3092\u6c42\u3081\u308b\n    vec3 normal = normalFunc( rayPos );\n    vec3 camDir = normalize( rayPos - cam.pos );\n    vec3 ligPos = cam.pos + cam.sid + cam.top * 1.0 - cam.dir;\n    vec3 ligDir = normalize( rayPos - ligPos );\n\n    // \u62e1\u6563\u53cd\u5c04\u30fb\u5149\u6e90\u306e\u93e1\u9762\u53cd\u5c04\u3092\u6c42\u3081\u308b\n    float dif = 0.5 + 0.5 * dot( -normal, ligDir );\n    float spe = pow( dot( normalize( camDir - normal ), ligDir ), 40.0 );\n    \n    // \u6750\u8cea\u306b\u5fdc\u3058\u3066\u8272\u3068\u53cd\u5c04\u7387\u3092\u5909\u5316\u3055\u305b\u308b\n    vec3 mtlCol = vec3( 0.0 );\n    float mtlSpe = 0.0;\n\t  \n    if ( floor( mtl ) == MTL_BASE ) {\n      mtlCol = vec3( 1.0, 0.4, 0.1 );\n      mtlSpe = 0.5;\n\t  \n    } else if ( floor( mtl ) == MTL_MEAT ) {\n      float yaki = smoothstep( 0.4, 0.8, noise( rayPos.xz * 4.0 ) );\n      mtlCol = mix( vec3( 0.6, 0.4, 0.2 ), vec3( 0.1 ), yaki * 0.4 );\n      mtlSpe = 0.2;\n\t    \n    } else if ( floor( mtl ) == MTL_HAPPA ) {\n      mtlCol = vec3( 0.6, 0.8, 0.2 );\n      mtlSpe = 0.5;\n\t    \n    } else if ( floor( mtl ) == MTL_CHEESE ) {\n      mtlCol = vec3( 0.9, 0.7, 0.1 );\n      mtlSpe = 0.4;\n\t    \n    } else if ( floor( mtl ) == MTL_TOMATO ) {\n      float fresh = fract( mtl );\n      mtlCol = mix( vec3( 0.9, 0.2, 0.2 ), vec3( 1.0, 0.9, 0.7 ), fresh );\n      mtlSpe = mix( 0.5, 0.8, fresh );\n    }\n\n    // \u8272\u3092\u6c7a\u5b9a\n    col.xyz += mtlCol * dif;\n    col.xyz += mtlSpe * spe;\n    col.w = 1.0;\n\t  \n    return col;\n  } else { // \u7269\u4f53\u306b\u5f53\u305f\u3089\u306a\u304b\u3063\u305f\u3089\n    return vec4( 0.0 );\n  }\n}\n\nvoid main() {\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.x;\n  gl_FragColor = draw( p, time );\n}\n", "user": "c097220", "parent": null, "id": "37065.4"}