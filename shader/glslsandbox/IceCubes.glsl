{"code": "// This is a snapshot of the GLSL ray marching renderer\n// Michele Bianchi and I (Nicolas Silva) are working on,\n// adapted to webgl (it's a school project).\n//\n// Just copy paste it on iq's ShaderToy (http://www.iquilezles.org/apps/shadertoy/) to see it working.\n//\n// the project is here : http://github.com/nical/GLSL-Raymarching\n// It's open source, feel free to use it :)\n// Please tell me on twitter (@nicalsilva) if you like it or if it's been useful\n// to you!\n// Pretty much all we've learned about ray marching comes from\n// iq's website: http://www.iquilezles.org/\n//\n// Enjoy!\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\n#define time time * 30.0\nuniform vec2 resolution;\nuniform vec4 mouse;\nuniform sampler2D tex0;\nuniform sampler2D tex1;\n\n\n#define MAX_STEPS 200\n\n#define shadowColor vec3(0.0,0.3,0.7)\n#define buildingsColor vec3(1.0,1.0,1.0)\n#define groundColor vec3(1.0,1.0,1.0)\n#define redColor vec3(1.0,0.1,0.1)\n#define skyColor vec3(0.9,1.0,1.0)\n#define viewMatrix mat4(0.0)\n#define fovyCoefficient 1.0\n#define shadowHardness 7.0\n\n\n\n#define epsilon 0.01\n#define PI 3.14159265\n\n#define NO_HIT 0\n#define HAS_HIT 1\n// materials\n#define SKY_MTL 0\n#define GROUND_MTL 1\n#define BUILDINGS_MTL 2\n#define RED_MTL 3\n\n\nfloat PlaneDistance(in vec3 point, in vec3 normal, in float pDistance)\n{\nreturn dot(point - (normal * pDistance), normal);\n}\n\nfloat SphereDistance(vec3 point, vec3 center, float radius)\n{\n  point.z = mod(point.z+15.0, 230.0)-15.0;\n  point.x = mod(point.x+15.0, 230.0)-15.0;\n  //point.y = mod(point.y, 30.0);\n  return length(point - center) - radius;\n}\n\n\nfloat CubeDistance2 (in vec3 point, in vec3 size) {\n\n  return length(max(abs(point)-size, 0.0));\n}\n\nvec3 DistanceRepetition(in vec3 point, in vec3 repetition ) {\n  vec3 q = mod(point, repetition)-0.5*repetition;\n  return q;\n}\n\n\nfloat CubeRepetition(in vec3 point, in vec3 repetition ) {\n    vec3 q = mod(point, repetition)-0.5*repetition;\n    q.y = point.y;\n    return CubeDistance2 ( q, vec3 (2.0, 4.0, 2.0));\n}\n\nvoid applyFog( in float distance, inout vec3 rgb ){\n\n    float fogAmount = (1.0 - clamp(distance*0.0015,0.0,1.0) );\n    //float fogAmount = exp( -distance* 0.006 );\n    vec3 fogColor = vec3(0.9,0.95,1);\n    //if( fogAmount < 0.6 ) \n    //  rgb = vec3(1.0,1.0,0.0);\n    //else\n    //rgb = clamp( rgb, 0.0, 1.0);\n    rgb = mix( skyColor, rgb, fogAmount );\n}\n\n\nfloat RedDistance(in vec3 position)\n{\n    return SphereDistance(position, vec3(0.0, 3.0, 5.0), 5.0);\n}\n\nfloat BuildingsDistance(in vec3 position)\n{\n    return min(\n      CubeRepetition(position, vec3(17.0, 0.0, 20.0))\n      , CubeRepetition(position+vec3(350.0,-2.0,0.0), vec3(23.0, 0.0, 23.0))\n    );\n}\n\nfloat GroundDistance(in vec3 position)\n{\n    return PlaneDistance(position, vec3(0.0,1.0,0.0), 0.0);\n}\n\nfloat DistanceField(in vec3 position, out int mtl )\n{\n    float redDistance = RedDistance(position);\n    float bldDistance = BuildingsDistance(position);\n    float gndDistance = GroundDistance(position);\n    float closest = gndDistance;\n    mtl = GROUND_MTL;\n    if ( bldDistance < closest )\n    {\n        closest = bldDistance;\n        mtl = BUILDINGS_MTL;\n    }\n    if ( redDistance < closest )\n    {\n        closest = redDistance;\n        mtl = RED_MTL;\n    }\n    return closest;\n}\n\n\nfloat Softshadow( in vec3 landPoint, in vec3 lightVector, float mint, float maxt, float iterations )\n{\n    float penumbraFactor = 1.0;\n    vec3 sphereNormal;\n    float t = mint; //(mint + rand(gl_FragCoord.xy) * 0.01);\n    for( int s = 0; s < 100; ++s )\n    {\n        if(t > maxt) break;\n        float nextDist = min(\n            BuildingsDistance(landPoint + lightVector * t )\n            , RedDistance(landPoint + lightVector * t )\n        );\n\n        if( nextDist < 0.001 ){\n            return 0.0;\n        }\n        //float penuAttenuation = mix (1.0, 0.0, t/maxt);\n        penumbraFactor = min( penumbraFactor, iterations * nextDist / t );\n        t += nextDist;\n    }\n    return penumbraFactor;\n}\n\n\nvec3 RayMarch(in vec3 position, in vec3 direction, out int mtl)\n{\n    float nextDistance = 1.0;\n    for (int i = 0; i < MAX_STEPS ; ++i)\n    {\n        nextDistance = DistanceField(position,mtl);\n        \n        if ( nextDistance < 0.01)\n        {\n            return position;\n        }\n        position += direction * nextDistance;\n    }\n    // out of steps\n    if (direction.y < 0.0 )\n    {\n        mtl = GROUND_MTL;\n    }\n    else\n    {\n        mtl = SKY_MTL;\n    }\n    return position;\n}\n\nvec3 MaterialColor( int mtl )\n{\n    if(mtl==SKY_MTL) return skyColor;\n    if(mtl==BUILDINGS_MTL) return buildingsColor;\n    if(mtl==GROUND_MTL) return groundColor;\n    if(mtl==RED_MTL) return redColor;\n\n    return vec3(1.0,0.0,1.0); // means error\n}\n\nvec3 ComputeNormal(vec3 pos, int material)\n{\n    int dummy;\n    return normalize(\n        vec3(\n          DistanceField( vec3(pos.x + epsilon, pos.y, pos.z), dummy ) - DistanceField( vec3(pos.x - epsilon, pos.y, pos.z), dummy )\n        , DistanceField( vec3(pos.x, pos.y + epsilon, pos.z), dummy ) - DistanceField( vec3(pos.x, pos.y - epsilon, pos.z), dummy )\n        , DistanceField( vec3(pos.x, pos.y, pos.z + epsilon), dummy ) - DistanceField( vec3(pos.x, pos.y, pos.z - epsilon), dummy )\n        )\n    );\n}\n\nvoid FishEyeCamera( vec2 screenPos, float ratio, float fovy, mat4 transform, out vec3 position, out vec3 direction )\n{\n    screenPos.y -= 0.2;\n    screenPos *= vec2(PI*0.5,PI*0.5/ratio)/fovy;\n    \n    direction = vec3(\n           sin(screenPos.y+PI*0.5)*sin(screenPos.x)\n        , -cos(screenPos.y+PI*0.5)\n        , sin(screenPos.y+PI*0.5)*cos(screenPos.x)\n    );\n    position = vec3(5.0*sin(time*0.01), 15.0, time);\n}\n\n\nfloat AmbientOcclusion (vec3 point, vec3 normal, float stepDistance, float samples) \n{\n  float occlusion = 1.0;\n  int tempMaterial;\n  \n  for (int i = 0; i < 20; ++i ) \n  {\n    if(--samples < 0.0) break;\n    occlusion -= (samples * stepDistance - (DistanceField( point + normal * samples * stepDistance, tempMaterial))) / pow(2.0, samples);\n  }\n  return occlusion;\n}\n\nvoid main(void)\n{\n    float ratio = resolution.x / resolution.y;\n    // position on the screen\n    vec2 screenPos;\n    screenPos.x = (gl_FragCoord.x/resolution.x - 0.5);\n    screenPos.y = gl_FragCoord.y/resolution.y - 0.5;\n\n    vec3 direction;\n    vec3 position;\n    FishEyeCamera(screenPos, ratio, fovyCoefficient, viewMatrix, position, direction);\n    int material;\n    vec3 hitPosition = RayMarch(position, direction, material);\n\n    if( material == SKY_MTL && direction.y < 0.0 )\n    {\n       material = GROUND_MTL;\n       gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n\n\n    vec3 hitColor;\n    if( material != SKY_MTL ) // has hit something\n    {\n        vec3 lightpos = vec3(50.0 * sin(time*0.01), 10.0 + 40.0 * abs(cos(time*0.01)), (time) + 100.0 );\n        vec3 lightVector = normalize(lightpos - hitPosition);\n        // soft shadows\n        float shadow = Softshadow(hitPosition, lightVector, 0.1, 50.0, shadowHardness);\n        // attenuation due to facing (or not) the light\n        vec3 normal = ComputeNormal(hitPosition, material);\n        float attenuation = clamp(dot(normal, lightVector),0.0,1.0)*0.6 + 0.4;\n        shadow = min(shadow, attenuation);\n        //material color\n        vec3 mtlColor = MaterialColor(material);\n        \n        if(material == BUILDINGS_MTL){\n          mtlColor = mix(shadowColor, mtlColor, clamp(hitPosition.y/7.0, 0.0, 1.0));\n        }\n        hitColor = mix(shadowColor, mtlColor, 0.4+shadow*0.6);\n        vec3 hitNormal = ComputeNormal(hitPosition, 0);\n        float AO = AmbientOcclusion(hitPosition, hitNormal, 0.35, 5.0);\n        hitColor = mix(shadowColor, hitColor, AO);\n        \n        applyFog( length(position-hitPosition), hitColor);\n        gl_FragColor = vec4(hitColor, 1.0);\n    }\n    else // sky\n    {\n        float shade = direction.y;\n        vec3 hitColor = mix(skyColor, vec3(0.3,0.3,0.7), shade);\n        gl_FragColor = vec4(hitColor, 1.0);\n    }\n\n}", "user": "23fbbf7", "parent": null, "id": "32714.0"}