{"code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n#define pi 3.1415927\n\n\n//various primitives, thanks IQ! http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat Sphere( vec3 p, vec3 c, float r )\n{\n\treturn length(p-c) - r;\n}\n\nfloat Box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat BevelBox(vec3 p, vec3 size, float box_r)\n{\n\tvec3 box_edge = size - box_r*0.5;\n\tvec3 dd = abs(p) - box_edge;\n\n\t//in (dd -ve)\n\tfloat maxdd = max(max(dd.x,dd.y),dd.z);\n\t//0 away result if outside\n\tmaxdd = min(maxdd,0.0);\n\t\t\n\t//out (+ve);\n\tdd = max(dd,0.0);\n\tfloat ddd = (length(dd)-box_r);\n\n\t//combine the in & out cases\n\tddd += maxdd;\n\treturn ddd;\n}\n\nfloat CylinderXY( vec3 p, vec3 c ) {\n\treturn length(p.xy-c.xy)-c.z;\n}\n\nfloat CylinderXZ( vec3 p, vec3 c ) {\n\treturn length(p.xz-c.xy)-c.z;\n}\n\nfloat CylinderYZ( vec3 p, vec3 c ) {\n\treturn length(p.yz-c.xy)-c.z;\n}\n\nfloat udHexPrism( vec2 p, float h ) {\n    vec2 q = abs(p);\n    return max(q.x+q.y*0.57735,q.y*1.1547)-h;\n}\n\nvec3 RotX(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x,\n\t\t\t\tp.y*c+p.z*s,\n\t\t\t\t-p.y*s+p.z*c);\n}\n\nvec3 RotY(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.z*s,\n\t\t\t\tp.y,\n\t\t\t\t-p.x*s+p.z*c);\n}\n\nvec3 RotZ(vec3 p, float t) {\n\tfloat c = cos(t); float s = sin(t);\n\treturn vec3(p.x*c+p.y*s,\n\t\t\t\t-p.x*s+p.y*c,\n\t\t\t\tp.z);\n}\n\n//initiate time corridor... (aka begin original work)\n\nfloat Plate(vec3 p, float h)\n{\n\tp = RotX(p,-pi*0.0625);\n\t\n\tfloat hh = 0.25;\n\tfloat w = 0.5 * hh;\n\tfloat bev = 0.02;\n\t\n\tfloat base = BevelBox(p-vec3(0.0,0.0,0),vec3(w,h,w), bev);\n\tfloat scallop = BevelBox(RotX(p,-pi*0.0625)-vec3(0.,-.6*h,0.6*hh),vec3(w,2.*h,w)*0.5, bev);\n\tbase = max(base,-scallop);\n\t\n\tfloat hole_size = 0.03;\n\tfloat hole_off = h * 0.8;\n\t\n\tvec3 reflect_y_p = vec3(p.x,abs(p.y),p.z);\n\t\n//\tfloat hole = CylinderXY( reflect_y_p, vec3(0.,hole_off,hole_size));\t\n//\tbase = max(base,-hole);\n\t\n\tfloat rivet = Sphere( reflect_y_p, vec3(0.,hole_off,w), hole_size );\n\t\t\n\tbase = min(base,rivet);\n\treturn base;\n}\n\nfloat PlateRing(vec3 p, float polar_t, float polar_r)\n{\t\t\n\tfloat h = abs(polar_t) < pi*(3.0/8.) ? 0.25 : 0.5;\n\t\n\tpolar_t = mod(polar_t,pi*(1./8.)) - pi*(1./8.)*0.5;\n\tvec3 q = vec3(polar_r * sin(polar_t), p.y, polar_r*cos(polar_t));\n\tq -= vec3(0.,-(h-0.25),1.0);\n\n\treturn Plate(q,h);\n}\n\nfloat Whisk(vec3 p)\n{\t\n\tp = abs(p);\n\tfloat r = 0.075;\n\tfloat c = min(0.4-p.x,0.1) * r * 12.0;\n\treturn length(p.zy - vec2(c,c)) - r*0.25;\n}\n\nfloat Gun( vec3 p )\n{\n\tp -= vec3(1.7,-.55,-0.70);\n\t\n\tfloat d = Whisk(p);\n\td = min( d, Whisk(RotX(p,pi*0.25)) );\n\tfloat barrel = length(p.zy)-0.05;\n\n\tbarrel = max( barrel, abs(p.x)-0.5); //clip\n\t\n\tbarrel = max( barrel, -(length(p.zy)-0.025));\n\treturn min(d,barrel);\n}\n\nconst float suck_end = 1.0;\n\n\nfloat Plunger(vec3 p )\n{\n\tp -= vec3(1.7,-.55,0.70);\n\tfloat barrel = length(p.zy)-0.075;\n\tbarrel = max( barrel, abs(p.x)-0.75);\t//clip!\n\t\n\tfloat sucker = Sphere(p, vec3(suck_end,0.0,0.0), 0.3);\n\tsucker = max(sucker, -Sphere(p, vec3(suck_end,0.0,0.0), 0.25));\n\tsucker = max(sucker, p.x-0.9); //clip\n\treturn min(barrel,sucker);\t\n}\n\nfloat GunPort(vec3 p)\n{\n\tp.z = abs(p.z);\n\n\tfloat w = 0.225;\n\tfloat d = 0.5;\n\t\n\tvec3 c = vec3(.75-0.25,-.55,0.70);\n\t\n\tfloat s = Sphere(p, c+vec3(.35+0.25,0,0), w * 0.66);\n\t\n\tp.x += 0.2 * p.y;\n\tfloat bev = 0.02;\n\tfloat b = BevelBox(p-c,vec3(d,w,w), bev);\n\t\n\treturn min(b,s);\n}\n\nfloat DarkBits(vec3 p)\n{\n\t//core body\t\n\tfloat b = CylinderXZ(p, vec3(0.,0.,0.8-0.15*p.y));\n\tb = max(b,abs(p.y)-1.2); //clip!\n\t\n\t//sucker\n\tvec3 sucker_p = p - vec3(1.7,-.55,0.70);\n\tfloat sucker = Sphere(sucker_p, vec3(suck_end,0.0,0.0), 0.3);\n\n\t//bulb\n\tvec3 stalk_p = RotZ(p,pi*0.05);\n\tfloat bulb_d = Sphere(stalk_p,vec3(2.4,1.1,0.0),0.2);\t\n\tbulb_d = max(bulb_d,stalk_p.x-2.5); //clip\n\t\n\t//gun ports\n\tp.z = abs(p.z);\n\n\tfloat w = 0.225;\n\tfloat d = 0.5;\n\t\n\tvec3 c = vec3(.75-0.25,-.55,0.70);\n\t\n\tfloat s = Sphere(p, c+vec3(.35+0.25,0,0), w * 0.66);\n\t\n\t\n\treturn min(min(bulb_d,s),min(b,sucker));\t\n}\n\nfloat Balls(vec3 p, float polar_t, float polar_r)\n{\n\tp.y += 2.45;\n\t\n\tfloat ang_reps = 6.;\n\tpolar_t = mod(polar_t,pi*(1./ang_reps)) - pi*(1./ang_reps)*0.5;\n\tvec3 q = vec3(polar_r * sin(polar_t), p.y, polar_r*cos(polar_t));\n\t\t\n\tfloat k = .5;\n\tq.y = mod( q.y, k ) - 0.5 * k;\n\t\n\tfloat balls = Sphere(q,vec3(0.0,0,1.25 - 0.1*floor(p.y*2.)),0.2);\n\t\n\tballs = max(balls,abs(p.y)-1.); //clip!\n\treturn balls;\n}\n\nfloat Body(vec3 p) {\n\tvec3 q = p;\n\tp=RotY(p,pi*1.0/12.0);\n\tfloat taper = 1.0+0.1*p.y;\n\t\n\ttaper -= p.y < -3.5 ? .2 * clamp(-(p.y+3.5),0.,0.1) : 0.;\n\tp.xz *= taper;\n\n\tfloat w = 1.15; ///taper;\n\tfloat d = udHexPrism(p.zx,w);\n\td = max(d, udHexPrism(p.xz,w));\n\n\td /= taper;\n\t\n\tq.y += +2.45;\n\n\td = max(d,abs(q.y)-1.5); //clip!\n\treturn d;\n}\n\nfloat Belt(vec3 p, float polar_t, float polar_r) {\n\t\n\t//belt\n\tfloat r = p.y + 1.05;\n\tfloat d = CylinderXZ(p, vec3(0.,0.,1.25-0.15*r) );\n\tvec3 q = p;\n\tq.y += 1.05;\n\td = max(d,abs(q.y)-0.125); //clip!\n\t\t\n\t//core body\t\n\tfloat b = CylinderXZ(p, vec3(0.,0.,0.8-0.15*p.y));\n\tb = max(b,abs(p.y)-1.2); //clip!\n\n\t//buckle\t\n\td = min(d, BevelBox(p+vec3(-0.8,0.60,0.),vec3(.2,.2,.4+0.2*p.y),0.05) );\n\t\n\td = min(d,b);\n\treturn d;\n}\n\nfloat Grill(vec3 p, float polar_t, float polar_r)\n{\t\n\tp += vec3(0.,-0.5,0.);\n\n\tvec3 c = p;\t\n\tfloat k = .25;\n\tc.y = mod( c.y + 0.1, k ) - 0.5 * k;\n\t\n\tfloat b = CylinderXZ(c,vec3(0.,0.,0.9));\n\tb = max(b,abs(c.y)-0.025); //clip each ring\n\t\n\tb = max(b,abs(p.y)-0.5); //clip the repetitions\n\t\n\tfloat ang_reps = 4.;\n\tpolar_t = mod(polar_t,pi*(1./ang_reps)) - pi*(1./ang_reps)*0.5;\n\tvec3 q = vec3(polar_r * cos(polar_t), p.y, polar_r*sin(polar_t));\n\n\tq = RotZ(q,pi*0.06);\n\t\n\tfloat d = BevelBox(q,vec3(0.8,0.5,.05),.045);\n\treturn min(d,b);\n}\n\nfloat Head(vec3 p)\n{\n\tfloat d = Sphere(p,vec3(0.,0.66,0.),1.0);\n\td = max(d,-p.y+1.0); //clip!\n\treturn d;\n}\n\nfloat Eye(vec3 p)\n{\n\t//stalk\n\tp = RotZ(p,pi*0.05);\n\tfloat d = CylinderYZ(p,vec3(1.1,0.,0.1));\n\td = max(d,-p.x); //clip\n\t\n\t//bulb\n\td = min(d, Sphere(p,vec3(2.4,1.1,0.0),0.2) );\n\t\n\td = max(d,p.x-2.5); //clip\n\n\t//lens\n\td = min(d, Sphere(p,vec3(2.4,1.1,0.0),0.15) );\n\t\n\t//mount\n\td = min(d, BevelBox(p+vec3(-0.9,-1.1,0.),vec3(.2,.2,.4-0.2*p.y),0.05) );\n\treturn d;\n}\n\nfloat Lens(vec3 p)\n{\n\tp = RotZ(p,pi*0.05);\n\treturn Sphere(p,vec3(2.4,1.1,0.0),0.15);\n}\n\nfloat Ears(vec3 p)\n{\n\tp.z = abs(p.z);\n\n\t\n\tp = RotX(p, -pi * 0.25);\n\t\n\tfloat d = CylinderXY(p,vec3(0.0,.5,0.2-0.1*(p.z-0.5)));\n\n\td = max(d,p.z-1.75); //clip\n\t\n\treturn d;\n}\n\nfloat floor_height = -4.0;\n\nfloat sdf( vec3 p )\n{\n\tfloat polar_t = atan(p.z,p.x);\n\tfloat polar_r = length(p.xz);\n\t\n\tfloat d = 1e10;\n\tfloat d_bound = 2.5;\t\n\tif (polar_r < d_bound)\t//optimize away this stuff if far away from bound cylinder\n\t{\t\n\t//\tif (p.y < -1.0)\t//opt?\n\t\t\td = min(d, Balls(p, polar_t, polar_r));\n\t\t\n\t\td = min(d, Belt(p, polar_t, polar_r));\n\n\t\td = min(d, PlateRing(p, polar_t, polar_r));\t\n\t\t\n\t//\tif (p.y > 0.25) //opt?\n\t\t{\n\t\t\td = min(d, Grill(p, polar_t, polar_r));\n\t\t\td = min(d, Head(p));\n\t\t\td = min(d, Ears(p));\n\t\t}\n\t}\n\n//\tif (p.y < -1.0) //opt ?\n\t\td = min(d, Body(p));\n//\telse \t\t\t//opt ? glitches shadows though\n\tif (abs(polar_t) < pi * 0.5) //optimize away this stuff if far away from front\n\t{\n\t\td = min(d, Eye(p));\n\t\td = min(d,GunPort(p));\t\n\t\td = min(d, Gun(p));\n\t\td = min(d, Plunger(p));\n\t}\n\t\n\t//floor!\n\td = min(d,p.y-floor_height);\n\treturn d;\n}\n\n\nvec3 nor(vec3 X)\n{\n\tvec2 e = vec2(0.01,0.0); //fatter filter looks like bevelled edges on hard CSG shapes\n#if 0\t\n\t//guh glitchy on silhouettes!\n\tfloat d = sdf(X);\n\tvec3 N = vec3(sdf(X-e.xyy),sdf(X-e.yxy),sdf(X-e.yyx) - vec3(d,d,d) );\n#else\t\n\tvec3 N = vec3(sdf(X-e.xyy),sdf(X-e.yxy),sdf(X-e.yyx)) -\n\t\t\t vec3(sdf(X+e.xyy),sdf(X+e.yxy),sdf(X+e.yyx));\n#endif\t\n\treturn -normalize(N);\n}\n\nfloat Ao(vec3 p, vec3 n, float d) {\n\tfloat vis = 0.0;\n\tfor (int i=0; i<6; i++)\n\t{\n\t\tfloat d = sdf(p);\n\t\t//this made more sense to me as volume of sphere that is clear of stuff blocking light ??\n\t\tvis += d*d*d * (4.*pi/3.);\t\n\t\tp += n * d;\n\t}\n\treturn pow(clamp(vis,0.,1.),0.2);\n}\n\n//thanks BRDF guys!\n//http://hal.inria.fr/docs/00/70/23/04/PDF/paper.pdf\n\nfloat gamma = //1.8; \n\t\t\t2.2;\n\t//2.0;\nfloat one_pi = 0.31830988618;\nfloat lightIntensity = 8.0;\n\n// gold-paint\n#if 1\nvec3 rho_d = vec3(0.147708, 0.0806975, 0.033172);\nvec3 rho_s = vec3(0.160592, 0.217282, 0.236425);\nvec3 alpha = vec3(0.122506, 0.108069, 0.12187);\nvec3 p = vec3(0.795078, 0.637578, 0.936117);\nvec3 F_0 = vec3(9.16095e-12, 1.81225e-12, 0.0024589);\nvec3 F_1 = vec3(-0.596835, -0.331147, -0.140729);\nvec3 K_ap = vec3(5.98176, 7.35539, 5.29722);\nvec3 sh_lambda = vec3(2.64832, 3.04253, 2.3013);\nvec3 sh_c = vec3(9.3111e-08, 8.80143e-08, 9.65288e-08);\nvec3 sh_k = vec3(24.3593, 24.4037, 25.3623);\nvec3 sh_theta0 = vec3(-0.284195, -0.277297, -0.245352);\n#endif\n\nfloat envAmount = 1.0;\n\nvoid dark_specular_fabric()\n{\n\t// dark-specular-fabric\n\trho_d = vec3(0.0197229, 0.00949167, 0.00798414);\n\trho_s = vec3(0.556218, 0.401495, 0.378651);\n\talpha = vec3(0.140344, 0.106541, 0.166715);\n\tp = vec3(0.249059, 0.177611, 0.434167);\n\tF_0 = vec3(0.0351133, 0.0387177, 0.0370533);\n\tF_1 = vec3(0.0243153, 0.0293178, 0.0264913);\n\tK_ap = vec3(7.60492, 9.81673, 6.19307);\n\tsh_lambda = vec3(3.93869, 4.23097, 4.3775);\n\tsh_c = vec3(0.00122421, 0.00238545, 8.47126e-06);\n\tsh_k = vec3(13.889, 14.5743, 17.2049);\n\tsh_theta0 = vec3(0.114655, 0.210179, -0.227628);\n\tenvAmount = 0.;\n}\n\nvoid gold_paint()\n{\n\trho_d = vec3(0.147708, 0.0806975, 0.033172);\n\trho_s = vec3(0.160592, 0.217282, 0.236425);\n\talpha = vec3(0.122506, 0.108069, 0.12187);\n\tp = vec3(0.795078, 0.637578, 0.936117);\n\tF_0 = vec3(9.16095e-12, 1.81225e-12, 0.0024589);\n\tF_1 = vec3(-0.596835, -0.331147, -0.140729);\n\tK_ap = vec3(5.98176, 7.35539, 5.29722);\n\tsh_lambda = vec3(2.64832, 3.04253, 2.3013);\n\tsh_c = vec3(9.3111e-08, 8.80143e-08, 9.65288e-08);\n\tsh_k = vec3(24.3593, 24.4037, 25.3623);\n\tsh_theta0 = vec3(-0.284195, -0.277297, -0.245352);\n}\n\nvoid two_layer_silver()\n{\n\trho_d = vec3(0.0657916, 0.0595705, 0.0581288);\n\trho_s = vec3(1.55275, 2.00145, 1.93045);\n\talpha = vec3(0.0149977, 0.0201665, 0.0225062);\n\tp = vec3(0.382631, 0.35975, 0.361657);\n\tF_0 = vec3(4.93242e-13, 1.00098e-14, 0.0103259);\n\tF_1 = vec3(-0.0401315, -0.0395054, -0.0312454);\n\tK_ap = vec3(50.1263, 38.8508, 34.9978);\n\tsh_lambda = vec3(3.41873, 3.77545, 3.78138);\n\tsh_c = vec3(6.09709e-08, 1.02036e-07, 1.01016e-07);\n\tsh_k = vec3(46.6236, 40.8229, 39.1812);\n\tsh_theta0 = vec3(0.183797, 0.139103, 0.117092);\t\n}\n\nvoid specular_violet_phenolic()\n{\n\trho_d = vec3(0.0686035, 0.0181856, 0.0210368);\n\trho_s = vec3(0.108459, 0.0471612, 0.171691);\n\talpha = vec3(0.00123271, 0.000443974, 0.00149517);\n\tp = vec3(0.657484, 0.546753, 0.653065);\n\tF_0 = vec3(0.0403569, 0.121081, 0.035323);\n\tF_1 = vec3(-0.0295013, 0.0563904, -0.0275623);\n\tK_ap = vec3(351.208, 1193.45, 294.897);\n\tsh_lambda = vec3(3.17585e-05, 1.3817, 2.44051e-05);\n\tsh_c = vec3(3.02028e-07, 6.19706e-08, 3.40809e-07);\n\tsh_k = vec3(31.3319, 234.879, 28.7237);\n\tsh_theta0 = vec3(-0.168991, 0.500354, -0.252626);\n}\n\nvoid orange_paint()\n{\n\trho_d = vec3(0.368088, 0.147113, 0.00692426);\n\trho_s = vec3(0.524979, 0.116386, 0.199437);\n\talpha = vec3(0.818115, 0.064743, 0.229391);\n\tp = vec3(1.44385, 0.0709512, 0.483597);\n\tF_0 = vec3(6.92565e-13, 0.106161, 0.102279);\n\tF_1 = vec3(-0.174318, 0.0934385, 0.0625648);\n\tK_ap = vec3(4.57466, 16.0185, 4.96427);\n\tsh_lambda = vec3(1.84547, 4.70387, 3.6232);\n\tsh_c = vec3(0.072629, 0.0299825, 0.000333551);\n\tsh_k = vec3(5.96872, 14.9466, 13.2194);\n\tsh_theta0 = vec3(0.222125, 0.438216, -0.0759733);\t\t\n}\n\nvec3 Fresnel(vec3 F0, vec3 F1, float V_H)\n{\n\treturn F0 - V_H * F1  + (1. - F0)*pow(1. - V_H, 5.);\n}\n\nvec3 D(vec3 _alpha, vec3 _p, float cos_h, vec3 _K)\n{\n\tfloat cos2 = cos_h*cos_h;\n\tfloat tan2 = (1.-cos2)/cos2;\n\tvec3 ax = _alpha + tan2/_alpha;\n\t\n\tax = max(ax,0.); //bug?\n\t\n\treturn one_pi * _K * exp(-ax)/(pow(ax,_p) * cos2 * cos2);\n\t// return vec3( 0.0 / (cos2 * cos2));\n}\n\nvec3 G1(float theta)\n{\n\ttheta = clamp(theta,-1.,1.); //bug?\n\treturn 1.0 + sh_lambda * (1. - exp(sh_c * pow(max(acos(theta) - sh_theta0,0.), sh_k)));\n}\n\nvec3 shade(float inLight, float n_h, float n_l, float n_v, float v_h)\n{\n  \treturn  one_pi * inLight * ( n_l * rho_d\t\n\t+ rho_s * D(alpha, p, n_h, K_ap) * G1(n_l) * G1 (n_v) * Fresnel(F_0, F_1, v_h));\n}\n\nvec3 brdf(vec3 lv, vec3 ev, vec3 n)\n{\n\tvec3 halfVector = normalize(lv + ev);\n\t\n\tfloat v_h = dot(ev, halfVector);\n\tfloat n_h = dot(n, halfVector);\n\tfloat n_l = dot(n, lv); \n\tfloat inLight = 1.0;\n\tif (n_l < 0.) inLight = 0.0;\n\tfloat n_v = dot(n, ev); \n\t\n\tvec3 sh = shade(inLight, n_h, n_l, n_v, v_h);\n\tsh = clamp( sh, 0., 1.); //bug?\n\tvec3 retColor = lightIntensity * sh;\n\t\t\n\t\n\treturn retColor;\n}\n\n\nvoid ChooseMat(vec3 p)\n{\t\n\tif (p.y < -3.5 || (DarkBits(p)) < 0.01)\n\t{\n\t//\tblack_soft_plastic();\n\t//\tblue_acrylic();\n\t\tdark_specular_fabric();\n\t}\n\t\n#if 1\t\n\n\tfloat polar_t = atan(p.z,p.x);\n\tfloat polar_r = length(p.xz);\t\n\tif ( abs(Balls(p, polar_t, polar_r)) < 0.01)\n\t{\n//\t\tgold_paint();\n\t\ttwo_layer_silver();\n\t}\n#endif\t\n\t\n\tif (Lens(p)<0.01)\n\t{\n\t\t specular_violet_phenolic();\t\t\n\t}\n\t\n\tif (Ears(p)<0.01)\n\t{\n\t\torange_paint();\n\t\t\n\t\tlightIntensity+=max(sin(time*10.0),0.)*10.0;\n\t}\n}\n\nvoid MakeViewRay(out vec3 viewP, out vec3 viewD)\n{\n\tvec2 xy = gl_FragCoord.xy;\n\txy.y=resolution.y-gl_FragCoord.y;\n\tvec2 filmUv = (xy + vec2(0.5,0.5))/resolution.xy;\n\n\tfloat tx = (2.0*filmUv.x - 1.0)*(resolution.x/resolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\n\tviewP = vec3(0.0, 0.0, 5.0);\n\tviewD = vec3(tx, ty, tz) - viewP;\t\n\t\n\tviewD = normalize(viewD);\n\t\n\tfloat t = pi*0.5 + sin(time);\n\n\tviewD=RotX(viewD,pi*0.1);\n\t\nviewP.y += 4.0;\nviewP.z += 12.0; // - sin(iGlobalTime)*8.0;\n\tviewP = RotY(viewP,t);\n\t\n\tviewD = RotY(viewD,t);\n\t\n}\n\n//thanks again IQ http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat shadow( in vec3 X, in vec3 n, in vec3 L )\n{\n\tfloat mint = 0.001;\n\tfloat maxt = 20.0;\n\t\n\tX += n*.01;\n\t\n\tfloat h=0.2;\n\tfloat sharpness = 25.;\n\tfloat soft=1.0;\n\tfloat t = mint;\n\tfor (int i=0; i<32; i++)\n    {\n        float d = sdf(X + L*t);\n        if( d<-0.1 )\n            return h; //t*h;\n\t\t\n\t\tsoft = min( soft, (sharpness*d)*(1./t));\n\t\t\n\t\tif (t > maxt) break;\n        t += d * 0.9;\n    }\n    return clamp(soft,h,1.0);\n}\n\nvoid main(void)\n{\n\tvec3 viewP, viewD;\n\tMakeViewRay(viewP, viewD);\n\t\n\tfloat t = 0.;\n\tfloat d;\n\n\tfor (int i=0; i<64; i++)\n\t{\n\t\tvec3 X = viewP + viewD * t;\n\t\td = sdf(X);\n\t\tif (abs(d) < 0.00001) break; //near enough surface for normals to look OK.\n\t\n#if 1\t\n\t\tif (t>20.) //too far - won't converge: just go to ground plane.\n\t\t{\n\t\t\tt = (-viewP.y + floor_height) / (viewD.y);\n\t\t\tbreak;\n\t\t}\n#endif\t\t\n\t\tt += d*0.9; //bounding volumes make the distance a bit wrong so slow down\n\t}\n\n\tvec3 X = viewP + viewD * t;\n\tvec3 n = nor(X);\n\t\n//\tvec3 c = vec3(i,i,i)*1.0/32.0;\n//\tvec3 c = vec3(t,t,t);\n//\tvec3 c = n*0.5+0.5;\n\n\tvec3 lightDir = normalize(vec3(3,8,2));\n\n#if 1\t\n\tfloat ao = Ao(X+n*0.03, n, sdf(n*0.03+X));\t\n\tlightIntensity *= ao;\n#endif\n\t\n\tChooseMat(X);\n\t\n\tfloat sha= 0.2;\n//\tif (dot(n,lightDir)>0.) \n\t\tsha = shadow(X,n,lightDir);\n\tlightIntensity *= sha;\n\t\n#if 0\n\tgl_FragColor = vec4(vec3(sha,sha,sha),1.0);\n#else\t\n\t\n\tvec3 c = brdf(lightDir, -viewD, n);\n\n\tlightDir = normalize(vec3(2,8,-3));\n\tif (dot(n,lightDir)>0.)\t\tsha = shadow(X,n,lightDir);\n\tlightIntensity = ao * 4. * sha;\n\t\n\tc += brdf(lightDir, -viewD, n) * vec3(1.,0.,0.7);\n\t\n\tvec3 env = vec3(0.5, 0.5, 0.5);//textureCube(iChannel0,reflect(viewD,n)).xyz;\n\n\n\tc += c * env * envAmount;\n\t\n//\tc = vec3(ao,ao,ao);\n\t\n\tc = pow(c, vec3(1./gamma));\n\t\n//\tc = vec3(sha,sha,sha);\n\n//\tc = n*0.5+0.5;\n\n\tgl_FragColor = vec4(c,1.0);\n#endif\t\n}", "user": "437eb5c", "parent": null, "id": "19868.0"}