{"code": "/*\n * Following iQ live coding tutorial on writing a basic raytracer http://www.youtube.com/watch?v=9g8CdctxmeU\n * @blurspline \n  * ... this forked version mostly just scrunched up to fit in less space without obfuscating too much. \n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// normals(?)\nvec3 nSphere( in vec3 pos, in vec4 sph ) { return ( pos - sph.xyz )/ sph.w; } \nvec3 nPlane( in vec3 pos ) {\treturn vec3 (0.0, 1.0, 0.0); }\nvec4 sph1 = vec4( 0.0, 1.3, 0.0, 1.5); // sphere, w is size\n\n// intersections\nfloat iPlane( in vec3 ro, in vec3 rd ) { return -ro.y / rd.y; }\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera\n\t//float r = 1.0;\n\tfloat b = 2.0*dot( oc, rd );\n\tfloat c = dot(oc, oc) - sph.w * sph.w; // w should be size\n\tfloat h = b*b - 4.5 *c;\n\tif (h<0.0 ) return -1.0;\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\treturn t;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out float resT ) {\n\tresT = 1000.;\n\tfloat id = -1.0;\n\tfloat tmin = -1.0;\n\tfloat tsph = iSphere( ro, rd, sph1 ); \n\tfloat tpla = iPlane( ro, rd ); \n\t\n\tif ( tsph>0.0 ) {\n\t\tid = 1.0;\n\t\tresT = tsph;\n\t}\n\t\n\tif (tpla > 0.0 && tpla <resT ) {\n\t\tid = 2.0;\n\t\tresT = tpla;\n\t}\n\t\t\n\treturn id;\n}\n\n\nvoid main( void ) {\n\tvec3 light = normalize( vec3(0.5,0.6,1.3) );\t\t// ok, here we come, GLSL raytacing!\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy );  // this is the pixel coords\n\tsph1.xz = vec2 ( 0.5 * cos( time ),  0.8 * sin( time )); // move sphere around\n\t\n\tvec3 ro = vec3( -.1, 1.5, 3.0 ); //ray origin\n\tvec3 rd = normalize( vec3( -1. + 1.5*uv* vec2(resolution.x/resolution.y, 1.0), -1.0 ) ); // ray destination\n \t\n\tfloat t;\n\tfloat id = intersect( ro, rd, t ); // we intersect ray with 3d scene\n\tvec3 col = vec3(0.65 * tan(rd*2.0*tan(time/50.0)));\n\t\n\tif ( id>0.5 && id<1.5 ) {\n\t\t// sphere\t\t\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = nSphere( pos, sph1 );\n\t\tfloat dif = clamp( dot( nor, light ), 0.0, 1.0); // diffuse light\n\t\tfloat ao = 0.5 + 0.5 * nor.y;\n\t\tcol = vec3( 0.8, 0.8, 0.6) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;\n\t} else if ( id>1.5 ) {\n\t\t// plane\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = nPlane( pos );\n\t\tfloat dif = clamp( dot(nor, light), 0.0, 1.0 );\n\t\tfloat amb = smoothstep( 0.0, sph1.w * 2.0, length(pos.xz - sph1.xz) ); // shadows under the sphere\n\t\tcol = vec3 (amb * 0.9);\n\t}\n\t\t\n\t//col = sqrt(col);\n\t//float f = (mod(gl_FragCoord.x * 5.0 + gl_FragCoord.y, 8.0) < col.r * 8.0) ? 1.0 : 0.0;\n\t//float f = (mod(gl_FragCoord.x * 5.0 + gl_FragCoord.y, 8.0) < col.r * 8.0) ? 1.0 : 0.0;\n\t\n\tfloat layers = 8.0;\n\tfloat layersInv = 1.0 / layers;\n\t\n\tfloat r = mod(floor(col.r * layers) * layersInv, 1.0);\n\t\n\t// add horizontal lines\n\tr = r * mod(gl_FragCoord.y * 2.0, 4.0);\n\t\n\tgl_FragColor = vec4( r, r, r, 1.0 );\n\t//gl_FragColor = vec4(col, 1.0;\n}", "user": "5e9acfa", "parent": "/e#1914.1", "id": "2027.0"}