{"code": "\n//---------------------------------------------------------\n// Shader:   SierpinskiPyramide.glsl  \n// original: created by inigo quilez - iq/2013-10-26\n//           https://www.shadertoy.com/view/4dl3Wl\n//           License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// tags:     sierpinski, pyramide, raymarcher, spheres\n//---------------------------------------------------------\n\n#ifdef GL_ES\n  precision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define ITERATIONS 7\n#define ROTATE true\n\n//---------------------------------------------------------\n\nconst vec3 va = vec3(  0.0,  0.57735,  0.0 );\nconst vec3 vb = vec3(  0.0, -1.0,  1.15470 );\nconst vec3 vc = vec3(  1.0, -1.0, -0.57735 );\nconst vec3 vd = vec3( -1.0, -1.0, -0.57735 );\n\n//---------------------------------------------------------\n// return distance of sierpinksi pyramide\nvec2 map( vec3 p )                 \n{\n  float a = 0.0;\n  float s = 1.0;\n  float r = 1.0;\n  float dm;\n  vec3 v;\n  for( int i=0; i<ITERATIONS; i++ )\n  {\n    float d, t;\n    d = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n    d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n    d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n    d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n    p = v + 2.0*(p - v); r*= 2.0;\n    a = t + 4.0*a; s*= 4.0;\n  }\n  return vec2( (sqrt(dm)-1.0)/r, a/s );\n}\n//---------------------------------------------------------\nconst float precis = 0.0002;\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n  vec3 res = vec3( 1e20, 0.0, 0.0 );\n\t\n  float maxd = 5.0;\n\n  // sierpinski\n  float h = 1.0;\n  float t = 0.5;\n  float m = 0.0;\n  vec2 r;\n  for( int i=0; i<100; i++ )\n  {\n    r = map( ro+rd*t );\n    if( r.x<precis || t>maxd ) break;\n    m = r.y;\n    t += r.x;\n  }\n\n  if( t<maxd && r.x<precis )\n    res = vec3( t, 2.0, m );\n  return res;\n}\n//---------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3(precis,0.0,0.0);\n  return normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n}\n//---------------------------------------------------------\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n  float ao = 0.0;\n  float sca = 1.0;\n  for( int i=0; i<8; i++ )\n  {\n    float h = 0.001 + 0.5*pow(float(i)/7.0,1.5);\n    float d = map( pos + h*nor ).x;\n    ao += -(d-h)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 0.8*ao, 0.0, 1.0 );\n}\n//---------------------------------------------------------\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n//---------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{\n  vec3 col = vec3(0.0);\n\n  // raymarch\n  vec3 tm = intersect(ro,rd);\n  if( tm.y>0.5 )\n  {\n    // geometry\n    vec3 pos = ro + tm.x*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 maa = vec3( 0.0 );\n\t\t\n    maa = 0.5 + 0.5*cos( 6.2831*tm.z + vec3(0.0,1.0,2.0) );\n\n    float occ = calcOcclusion( pos, nor );\n\n    // lighting\n    float amb = (0.5 + 0.5*nor.y);\n    float dif = max(dot(nor,lig),0.0);\n\n    // lights\n    vec3 lin = 1.5*amb*vec3(1.0) * occ;\n\n    // surface-light interacion\n    col = maa * lin;    \n  }\n\n  // gamma\n  col = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n  return col;\n}\n//---------------------------------------------------------\nvec3 rotx(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n//---------------------------------------------------------\nvec3 roty(vec3 p, float a)\n{\n    float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z);\n}\n//---------------------------------------------------------\nvoid main( )\n{\n  vec2 p = gl_FragCoord.xy / resolution.xy * 2.0 - 1.0;\n  float ratio = resolution.x / resolution.y;\n  p.x *= ratio;\n  vec2 mo = mouse.xy ; /// resolution.xy*0.5 -0.75;\n\n  // camera\n  vec3 ro = vec3(0.0, 0.0,-4.5 + mouse.y);\n  vec3 rd = vec3(p, 1.2);\n  mo.x *= ratio;\n  ro = roty(ro, +mo.x * 0.2);\n  ro = rotx(ro, -mo.y * 0.1); \n\n  vec3 col = render( ro + vec3(0.0,-0.1,2.0), rd );\n    \n  gl_FragColor = vec4( col, 1.0 );\n}\n", "user": "5e1d1fd", "parent": null, "id": "25895.0"}