{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n               -0.80,  0.36, -0.48,\n               -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m3*p*2.02;\n    f += 0.2500*noise( p ); p = m3*p*2.03;\n    f += 0.1250*noise( p ); p = m3*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\n\n\nfloat dbox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat freqs[4];\n\nvec3 map( in vec3 pos )\n{\n\n\tvec2 fpos = fract( pos.xz ); \n\tvec2 ipos = floor( pos.xz );\n\t\n\t//ipos.x += floor(10.0*sin( iGlobalTime + 0.1*ipos.y));\n\t\n    float f = 0.0;\t\n\tfloat id = hash( ipos.x + ipos.y*57.0 );\n\t#if 1\n\tf  = freqs[0] * clamp(1.0 - abs(id-0.20)/0.30, 0.0, 1.0 );\n\tf += freqs[1] * clamp(1.0 - abs(id-0.40)/0.30, 0.0, 1.0 );\n\tf += freqs[2] * clamp(1.0 - abs(id-0.60)/0.30, 0.0, 1.0 );\n\tf += freqs[3] * clamp(1.0 - abs(id-0.80)/0.30, 0.0, 1.0 );\n\tf = pow( clamp( f*0.75, 0.0, 1.0 ), 2.0 );\n\t#endif\n    float h = 0.01 + 4.0*f;\n\tfloat dis = dbox( vec3(fpos.x-0.5,pos.y-0.5*h,fpos.y-0.5), vec3(0.3,h*0.5,0.3), 0.1 );\n\n    return vec3( dis,id, f );\n}\n\n\nconst float surface = 0.001;\n\nvec3 trace( in vec3 ro, in vec3 rd, in float startf, in float maxd )\n{ \n    float s = surface*2.0;\n    float t = startf;\n\n    float sid = -1.0;\n\tfloat alt = 0.0;\n    for( int i=0; i<128; i++ )\n    {\n        if( s<surface || t>maxd ) break;\n        t += 0.15*s;\n\t    vec3 res = map( ro + rd*t );\n        s   = res.x;\n\t    sid = res.y;\n\t\talt = res.z;\n    }\n    if( t>maxd ) sid = -1.0;\n    return vec3( t, sid, alt );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n    float res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += max( 0.05, dt );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(surface*0.5,0.0,0.0);\n\tvec3 nor;\n\tnor.x = map(pos+eps.xyy).x - map(pos-eps.xyy).x;\n\tnor.y = map(pos+eps.yxy).x - map(pos-eps.yxy).x;\n\tnor.z = map(pos+eps.yyx).x - map(pos-eps.yyx).x;\n\treturn normalize(nor);\n}\n\n\nvoid main( void )\n{\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\n    xy.x *= resolution.x/resolution.y;\n\t\n    float gtime = 5.0 + 0.2*time + 20.0*mouse.x/resolution.x;\n\nfreqs[0] = sin(time);\nfreqs[1] = cos(time*2.);;\nfreqs[2] = sin(time*.5);\nfreqs[3] = cos(time*5.5);\n\t\n\t\n    // camera\t\n\tvec3 ro = vec3( 8.5*cos(0.2+.33*gtime), 5.0+2.0*cos(0.1*time), 8.5*sin(0.1+0.37*gtime) );\n\tvec3 ta = vec3( -2.5+3.0*cos(1.2+.41*gtime), 0.0, 2.0+3.0*sin(2.0+0.38*gtime) );\n\tfloat roll = 0.2*sin(0.1*gtime);\n\t\n\t// camera tx\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.75*cw );\n\t\n    // image\n    vec3 col = vec3( 0.0 );\n\t\n    vec3 res = trace( ro, rd, 0.025, 40.0 );\n    float t = res.x;\n    float sid = res.y;\n\n\n\tvec3 light1 = vec3(  0.577, 0.577, -0.577 );\n    vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n    vec3 lpos = vec3(0.0) + 6.0*light1;\n\t\n    if (sid>-0.5)\n    {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\t    \n\t  \n    // lighting\n    vec3  ldif = pos - lpos;\n    float llen = length( ldif );\n    ldif /= llen;\n\tfloat con = dot(-light1,ldif);\n\tfloat occ = mix( clamp( pos.y/4.0, 0.0, 1.0 ), 1.0, max(0.0,nor.y) );\n\tfloat sha =  softshadow( pos, -ldif, 0.01, 5.0, 32.0 );;\n\t\t\n    float bb = smoothstep( 0.5, 0.8, con );\n    float lkey = clamp( dot(nor,-ldif), 0.0, 1.0 );\n\tvec3  lkat = vec3(1.0);\n          lkat *= vec3(bb*bb*0.6+0.4*bb,bb*0.5+0.5*bb*bb,bb).zyx;\n          lkat /= 1.0+0.25*llen*llen;\t\t\n\t\t  lkat *= 25.0;\n          lkat *= sha;\n    float lbac = clamp( 0.1 + 0.9*dot( light2, nor ), 0.0, 1.0 );\n          lbac *= smoothstep( 0.0, 0.8, con );\n\t\t  lbac /= 1.0+0.2*llen*llen;\t\t\n\t\t  lbac *= 4.0;\n\tfloat lamb = 1.0 - 0.5*nor.y;\n          lamb *= 1.0-smoothstep( 10.0, 25.0, length(pos.xz) );\n\t\t  lamb *= 0.25 + 0.75*smoothstep( 0.0, 0.8, con );\n\t\t  lamb *= 0.25;\n\t\t\n    vec3 lin  = 1.0*vec3(0.20,0.05,0.02)*lamb*occ;\n         lin += 1.0*vec3(1.60,0.70,0.30)*lkey*lkat*(0.5+0.5*occ);\n         lin += 1.0*vec3(0.70,0.20,0.08)*lbac*occ;\n         lin *= vec3(1.3,1.1,1.0);\n\n\t\t\n    // material\t\n\tcol = 0.5 + 0.5*vec3( cos(0.0+6.2831*sid),\t\t\n                          cos(0.4+6.2831*sid),\n                          cos(0.8+6.2831*sid) );\n    float ff = fbm( 10.0*vec3(pos.x,4.0*res.z-pos.y,pos.z)*vec3(1.0,0.1,1.0) );\t\n    col *= 0.2 + 0.8*ff;\n\t\t\n\tcol = col*lin;\n\n    vec3 spe = vec3(1.0)*occ*lkat*pow( clamp(dot( reflect(rd,nor), -ldif  ),0.0,1.0), 4.0 );\n\tcol += (0.5+0.5*ff)*0.5*spe*vec3(1.0,0.9,0.7);\n    }\n\n\t\n\tcol = sqrt( col );\n\t\n\n    // vigneting\n\tvec2 q = gl_FragCoord.xy/resolution.xy;\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n    gl_FragColor=vec4( col, 1.0 );\n}", "user": "41a3f24", "parent": null, "id": "20674.0"}