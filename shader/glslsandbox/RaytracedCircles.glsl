{"code": "#ifdef GL_ES\nprecision mediump float; \n#endif\n\n//circle tracer mk. 3 - added cone tracer support\n//sphinx\n\nuniform float \t\ttime;\nuniform vec2 \t\tmouse;\nuniform vec2 \t\tresolution;\nuniform sampler2D \trenderbuffer;\n\n#define aspect    (resolution.x/resolution.y)\n#define pi        (4.*atan(1.))\n#define phi       .01\n#define epsilon   .01\n#define farplane  2.\n\n//#define conetrace\n#define reflection\n#define refraction\n\n#define rays 3\n#define maxsteps 32\n\n#define origin vec2(-1.,  0.)\n\n//#define mapcircle\n#define maplens\n//#define mapnoise\n\nstruct ray\n{\n    vec2 o, p, d;  //origin, position, direction\n    float e;       //energy\n    bool h;        //hit\n};\n\nstruct graph\n{\n    vec3 c;                  //color\n    float r, e, f, i, s, h;  //ray, energy, field, isosurface, hit, steps\n};    \n  \nvec2\ttoworld(vec2 p);\nfloat   map(in vec2 p);\nvec2    derive(in vec2 rp, in vec2 p, inout graph g);\n\nvoid    emit(inout ray r, inout graph g, in vec2 p, const in int it);\nvoid    emitcone(inout ray r, inout graph g, in vec2 p, const in int it);\nvoid    absorb(inout ray r, inout graph g, in vec2 p,  in float a, in float s, const in int it);\n\nvec2    scatter(vec2 d, in float s);\n\ngraph   graphray(in ray r, in vec2 p, graph g);\ngraph   graphcone(in ray r, in vec2 p, in float c, graph g);\ngraph   graphnormal(in vec2 rp, in vec2 n, in vec2 p, graph g);\ngraph   graphintersect(in ray r, in vec2 p, graph g);\ngraph   graphmap(in vec2 p, graph g);\n\nfloat\tline(in vec2 p, in vec2 a, in vec2 b, in float w);\nfloat   ring(in vec2 p, in float r, in float w);\nfloat   circle(in vec2 p, in float r, in float w);\nvec3    hsv(in float h, in float s, in float v);\n\nfloat   hash(float u);\nvec4    hash(vec4 v);\nfloat   smooth(float u);\nvec2    smooth(vec2 uv);\nfloat   blend(in vec4 l, in vec4 v);\nvoid    lattice(in vec2 uv, out vec4 l, out vec4 v);\nfloat   noise(in vec2 uv);\nfloat   fbm(float a, vec2 f, vec2 p, vec2 uv);\n\nmat2    rmat(float t);\n\nfloat pixelSize;\nfloat raycone(float t);\n\n\nvoid main( void ) {\n\tvec2 uv = gl_FragCoord.xy/resolution.xy;\n\tvec2 p\t= toworld(uv);\n\t\n    ray r;\n   \n    graph g;\n    g.c = vec3(0.);\n    g.r = 0.;\n    g.e = 0.;\n    g.f = 0.;\n    g.i = 0.;\n    g.s = 0.;\n    g.h = 0.;\n    \n    vec2 m   = toworld(mouse);\n    \n    float fov   = .5;\n    float t     = -fov/float(rays);\n    \n    float e = map(origin);\n    for(int i = 0; i < rays; i++)\n    {\n        r.o    = origin;\n        r.p    = r.o;\n        r.d    = normalize(m-r.o*rmat(t*(float(i)+.5-float(rays)*.5)));\n        r.e    = e;\n        r.h    = false;\n        \n        g.s    = 0.;\n        if(i < rays)\n        {\n            #ifdef conetrace\n            emitcone(r, g, p, 8);\n            #else\n            emit(r, g, p, 8);\n            #endif\n            if(r.h)\n            {\n                vec2 hp = r.p;\n                \n                \n                #ifdef reflection\n                r.d    = reflect(r.d, derive(hp, p, g));\n                r.p    = r.o;\n                r.e    = .1;\n                r.h    = false;\n                emit(r, g, p, 6);\n                #endif\n            \n                #ifdef refraction\n                float ri   = .5;\n                float t    = .95; //transmission\n                float s    = .01; //internal scattering\n                r.d        = refract(derive(hp, p, g), r.d, ri);\n                r.o        = hp+r.d*phi;\n                r.p        = r.o;\n                r.e        = .1;\n                r.h        = false;\n                absorb(r, g, p, t, s, 8);\n                \n                if(r.h)\n                {\n                    vec2 n     = derive(r.p, p, g);\n                    \n                    r.d        = refract(r.d, -n, ri);\n                    r.o        = r.o+r.d*phi;\n                    r.e        = .1;\n                    r.h        = false;\n                    emit(r, g, p, 8);\n                }\n                #endif\n            }\n        }\n    }\n    \n    g = graphmap(p, g);\n    \n    vec4 result = vec4(g.c, 1.);\n\n    gl_FragColor = result;\n}//sphinx\n\nvec2 toworld(vec2 p)\n{\n\tp = p * 2. - 1.;\n\tp.x *= aspect;\n\treturn p;\n}\n\nfloat map(vec2 p)\n{\n    vec2 o      = vec2(.75, 0.);\n    float r     = farplane;\n\n    //circle\n    #ifdef mapcircle\n    vec2 cp     = p-o;\n    float c    = length(cp)-.5;\n    r           = min(r, c);\n    #endif\n    \n    //noisy circle\n    #ifdef mapnoise\n    vec2 np     = (p-o);// * rmat(time*.01);\n    float nc    = length(np)-.5;;\n    float ns    = .25;\n    float n     = clamp(fbm(.5, vec2(8.), np, np - vec2(2., 0.)), 0., 1.)*ns-ns*.75;\n    nc          = min(max(-nc+ns, nc), nc-n);\n    r           = min(r, nc);\n    #endif\n    \n    //lenses\n    #ifdef maplens\n    vec2 cp     = p-o;\n    float c     = length(cp)-.5;\n    vec2 l0p    = abs((p-o)*vec2(1., .75));\n    float l0    = length(l0p+vec2(.5, 0.))-.6;\n    vec2 l1p    = abs((p-o)*vec2(1., .75))-vec2(.75, 0.);\n    float l1    = max(-length(l1p)+.5, length(p-o)-.65);\n    float l     = max(c, mix(l0, l1, cos(time)*.5+.5));\n    r           = min(r, l);\n    #endif\n   \n    return r;\n}\n\n\nfloat focalDistance= 1., aperature=0.05, fudgeFactor=1., fudgeFactor2=.25, jitter=.0, focal = 4.;\nfloat FieldHalfWidth=2.;\n\nvec3 mcol;\nfloat CE(vec2 z0){\n\tfloat d=map(z0);\n\tif (d==z0.y+0.25) mcol+=vec3(.8);\telse \n\t\tmcol+=vec3(0.7)+vec3(sin(z0.xy*5.0)*0.5,0.25)*0.5;\n\treturn d;\n}\n\nfloat bell(float a, float b, float t){\n\tt=2.*clamp((t-a)/(b-a),0.,1.)-1.;\n\treturn 1.-t*t;\n}\n\nvoid emitcone(inout ray r, inout graph g, in vec2 p, const in int m)\n{\n    vec2 uv = gl_FragCoord.xy/resolution.xy;\n\tuv\t= toworld(uv);\n    \n\tfloat cor = focal/length(r.d);\n\t\n    vec2 L    = normalize(vec2(5.,5.));\n\t\n    float a   = 0.;//accumulator\n\tfloat t   = 0.;\n\n\tfor(int i = 1; i < maxsteps; i++){\n        if(i == m || t > farplane*2.)\n        {    \n            break;//bail if we hit a surface or go out of bounds\n        }\n        \n        \n        g.s++;\n        \n        float c = raycone(t*cor);//calc the radius of cone\n\t\t\n        r.e    = map(r.p);\n\t\t\n        if(abs(r.e)<c){//if we are inside add its contribution\n\t\t\tvec2 v  = vec2(c*0.01,0.0);//use normal deltas based on cone radius\n\t\t\tvec2 n  = normalize(vec2(-map(r.p-v.xy)+map(r.p+v.xy),-map(r.p-v.yx)+map(r.p+v.yx)));\n            a       += bell(-c, c, r.e);\n            g       = graphnormal(r.p, n*.0125, uv, g);     \n\t\t}\n        \n\t    t     += r.e;\n    \tg     = graphcone(r, p, c, g); \n\t\n        if(a > 1.)\n        {\n            r.h  = true;\n            r.o  = r.p;\n            g    = graphintersect(r, p, g);\n            break;\n        }\n        \n        r.p   += r.e * r.d;//march\n    \n\t}\n}\n\nvoid emit(inout ray r, inout graph g, in vec2 p, const in int m)\n{   \n    float pe   = r.e;\n    vec2 pp    = r.p;\n    float ephi = phi;\n    float e    = r.e;\n    for(int i = 0; i < maxsteps; i++)\n    {\n        if(i == m)\n        {\n             break;\n        }\n        g.s++;\n        if(r.e < farplane)\n        {\n            if(phi > r.e)\n            {\n                r.h = true;\n                g = graphintersect(r, p, g);\n                break;\n            }\n            \n            r.p        = r.o + r.d * r.e;            \n    \n            g = graphray(r, p, g);     \n            \n            \n            r.e = map(r.p); \n\n//            #define dampen\n            #ifdef dampen\n            ephi *= 1.03;\n            r.e = e * .8;\n            #endif\n            \n            #define reverse\n            #ifdef reverse\n            bool overshoot = r.e * pe < 0.;\n            r.p = overshoot ? mix(r.p, pp, -r.e/(.5*(pe-r.e))) : r.p;\n            pp  = r.p;\n            pe  = r.e;\n\t\n\t    if(overshoot)\n\t    {\n\t\tg = graphray(r, p, g);\n\t    }\n            #endif\n\n            \n            r.o = r.p;  \n\n        }\n    }\n    g = graphray(r, p, g);      \n}\n\nvoid absorb(inout ray r, inout graph g, in vec2 p, in float a, in float s, const in int m)\n{    \n    float e = 1.;\n    vec2 o = r.o;\n    for(int i = 0; i < maxsteps; i++)\n    {\n        if(i == m || e < phi)\n        {\n             break;\n        }\n        g.s++;        \n        if(r.e < farplane)\n        {\n            r.d = scatter(r.d,s*r.e);\n            r.p = r.o + r.d * r.e;\n            g = graphray(r, p, g);     \n            if(2.*phi > r.e)\n            {\n                r.h = true;\n                r.e = distance(o, r.p)*a;\n                g = graphintersect(r, p, g);\n                break;\n            }\n            r.e = map(r.p); \n            r.e = max(.01-r.e, r.e);\t\n            r.o = r.p;\n            e *= a;\n        }\n    }\n    g = graphray(r, p, g); \n}\n\nvec2 scatter(vec2 d, in float s){\n     d += (vec2(hash(d.x),hash(d.y))-.5)*s;\n     return normalize(d);   \n}\n\nfloat raycone(float t)\n{\n\treturn max(abs(focalDistance-t)-FieldHalfWidth,0.)*aperature+pixelSize*t;\n}\n\ngraph graphnormal(in vec2 rp, in vec2 n, in vec2 p, graph g)\n{\n    float w = 8.;\n    g.c.x += line(p, rp, rp+vec2(n.x*w,0.), .0075);\n    g.c.y += line(p, rp, rp+vec2(0.,n.y*w), .0075);\n    g.c.xy += line(p, rp, rp+n*w, .0075);\n    return g;\n}\n\nvec2 derive(in vec2 rp, in vec2 p, inout graph g){\n\tvec2 e = vec2(0., epsilon);\n    vec2 n;\n\tn.x = map(rp+e.yx)-map(rp-e.yx);\n\tn.y = map(rp+e.xy)-map(rp-e.xy);\n    \n    g = graphnormal(rp, n, p, g);\n    return normalize(n);\n}\n\ngraph graphray(in ray r, in vec2 p, graph g)\n{\n    float gr = line(p,  r.o, r.p, .0075);\n    gr       = max(gr, circle(p-r.o, .01, .0025));\n    \n\n    float ge = ring(r.o - p, r.e, .025);\n    \n    g.r      = max(g.r, gr); \n    g.e      = max(g.e, ge);\n    \n    g.c      = max(g.c, (gr + ge) * hsv(.65-g.s*.1, 1., 1.));\n    return g;\n}\n\ngraph graphcone(in ray r, in vec2 p, in float c, graph g)\n{\n    float gr  = line(p,  r.o, r.p, .0075);\n\n    float gc  = line(p,  r.p-r.d.yx*vec2(-c, c), r.p+r.d.yx*vec2(-c, c), .0075);\n    gr        = max(gr, gc) * .5;\n    gr        = max(gr, circle(p-r.o, .01, .0025));\n    \n\n    float ge = ring(r.p - p, r.e, .025);\n    \n    g.r      = max(g.r, gr); \n    g.e      = max(g.e, ge);\n    \n    g.c      = max(g.c, (gr + ge) * hsv(.65-g.s*.1, 1., 1.));\n    return g;\n}\n\ngraph graphintersect(in ray r, in vec2 p, graph g)\n{\n    float c  = circle(p - r.p, .025, .15);\n    float f  = map(p);\n    c        *= float(abs(f) < phi);\n  \n    g.h      = max(g.h, c);\n\n    g.c      = max(g.c, .75 * c * hsv(.65-g.s*.1, 1., 1.));\n\n    return g;\n}\n\ngraph graphmap(in vec2 p, graph g)\n{\n    g.f     = map(p);\n    g.c.rg  += g.f < phi && g.f+phi > phi? .25 : 0.;\n    \n    float a = g.f > phi ? fract(g.f*4.) : 0.;\n    float w = .025;\n    a       = 1.-max(smoothstep(a-w, w, w-a),smoothstep(-a+w, w, a));\n    \n    g.i     = g.f > phi ? min(1., a * 32.) : abs(.5-g.f)-a;\n    g.i     *= .75;\n    \n    g.c     = max(g.c, g.f * vec3(0., 0., .25+a));\n    g.c     = max(g.c, g.i * vec3(.0, .5, .0));\n    return g;\n}\n\nfloat circle(vec2 p, float r, float w)\n{\n\treturn smoothstep(w, 0., length(p)-r);\n}\n\nfloat ring(vec2 p, float r, float w)\n{\n    float l = length(p)-r+w*.5;\n    l = 1.-max(smoothstep(l-w, w, w-l),smoothstep(-l+w, w, l));\n\treturn clamp(l, 0., 1.);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float w)\n{\n\tif(a==b)return(0.);\n\tfloat d = distance(a, b);\n\tvec2  n = normalize(b - a);\n    vec2  l = vec2(0.);\n\tl.x = max(abs(dot(p - a, n.yx * vec2(-1.0, 1.0))), 0.0);\n\tl.y = max(abs(dot(p - a, n) - d * 0.5) - d * 0.5, 0.0);\n\treturn clamp(smoothstep(w, 0., l.x+l.y), 0., 1.);\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat hash(float v)\n{\n    return fract(fract(v/1e4)*v-1e6);\n}\n\nfloat noise(in vec2 uv)\n{\n    const float k = 257.;\n    vec4 l  = vec4(floor(uv),fract(uv));\n    float u = l.x + l.y * k;\n    vec4 v  = vec4(u, u+1.,u+k, u+k+1.);\n    v       = fract(fract(1.23456789*v)*v/.987654321);\n    l.zw    = l.zw*l.zw*(3.-2.*l.zw);\n    l.x     = mix(v.x, v.y, l.z);\n    l.y     = mix(v.z, v.w, l.z);\n    return    mix(l.x, l.y, l.w);\n}\n \n#define octaves 3\nfloat fbm(float a, vec2 f, vec2 p, vec2 uv)\n{\n    float n = 0.;\n    uv += 31.;\n    float s = -1.;\n    for(int i = 0; i < octaves; i++)\n    {\n        n += noise(uv*f+p)*a;\n        a *= .5;\n        f *= 2.;\n        p -= p/f;\n    }\n    return n;\n}\n\nmat2 rmat(float t)\n{\n    float c = cos(t);\n    float s = sin(t);   \n    return mat2(c,s,-s,c);\n}\n", "user": "728c712", "parent": "/e#21262.0", "id": "26775.0"}