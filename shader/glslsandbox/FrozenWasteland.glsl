{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Frozen wasteland\n// https://www.shadertoy.com/view/Xls3D2\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// By Dave Hoskins\n\n#define ITR 90\n#define FAR 60.\n//#define time iGlobalTime\n#define MOD3 vec3(.16532,.17369,.15787)\n#define SUN_COLOUR  vec3(1., .9, .7)\n\nfloat height(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    h -= sin(h*10.0)*.1;\n    return h;\n}\n\nfloat camHeight(in vec2 p)\n{\n    float h = sin(p.x*.1+p.y*.2)+sin(p.y*.1-p.x*.2)*.5;\n    h += sin(p.x*.04+p.y*.01+3.0)*4.;\n    return h;\n}\n\nfloat smin( float a, float b)\n{\n\tconst float k = 2.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.5625+1.3)*3.5-.5;\n    p.x += cos(p.z*.4575)*1.;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h*1.4 -sin(p.z*3.+sin(p.x*7.)*0.5)*0.1;\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<= 2.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.3;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\nfloat map(vec3 p)\n{\n    p.y += height(p.zx);\n    float d = p.y+.5;\n    \n    d = smin(d, vine(p+vec3(.8,0.,0),30.,3.3) );\n    d = smin(d, vine(p.zyx+vec3(0.,0,17.),33.,1.4) );\n    d += triNoise3d(p*.05)*(p.y*1.2);\n    p.xz *=.2;\n    d+= triNoise3d(p*.3);\n    return d;\n}\nfloat fogmap(in vec3 p, in float d)\n{\n    p.xz -= time*7.;\n    p.y -= time*.5;\n    return (max(triNoise3d(p*.008+.1)-.1,0.0)*triNoise3d(p*.1))*.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd, out float f, in vec2 scUV)\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    float d = hash12(scUV);\n    f = 0.0;\n    float fd = hash12(scUV*1.3);\n    for( int i=0; i<ITR; i++ )\n    {\n        vec3 p = ro+rd*d;\n        if( h<precis || d > FAR) break;\n        h = map(p);\n        if (d > fd) f +=  (1.0-f) * fogmap(p, fd);\n        d += h*.65 + d * .002;   \n        fd += .1;\n\t }\n\treturn d;\n}\n\nvec3 normal( in vec3 pos, in float d )\n{\n\tvec2 eps = vec2( d *d* .003+.01, 0.0);\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy) - map(pos-eps.xyy),\n\t    map(pos+eps.yxy) - map(pos-eps.yxy),\n\t    map(pos+eps.yyx) - map(pos-eps.yyx) );\n\treturn normalize(nor);\n}\n\nfloat bnoise(in vec3 p)\n{\n    p.xz*=.4;\n    float n = triNoise3d(p*3.)*0.4;\n    n += triNoise3d(p*1.5)*0.2;\n    return n*n*.2;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    p.xz *= .4;\n    //p *= 1.0;\n    vec2 e = vec2(.01,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*10./(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<12; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.1, 1.5 );\n            }\n    return clamp( res, 0.2, 1.0 );\n}\n\nvec3 Clouds(vec3 sky, vec3 rd)\n{\n    float v = (200.0)/rd.y;\n\n    rd.y = v;\n    rd.xz = rd.xz * v - time*24.0;\n\trd.xz *= .0004;\n\tfloat f = triNoise3d(rd.xzz*.5) + triNoise3d(rd.zzx*3.)*.5;\n    return  mix(sky, vec3(1, .8, .5), max(f-.3, 0.0));\n}\n\n\nvec3 Sky(vec3 rd, vec3 ligt)\n{\n    vec3 sky = mix(vec3(1.), vec3(.05, .2, .3), pow(abs(rd.y+.04), .5));\n    return  mix(sky, SUN_COLOUR, min(pow(max(dot(rd,ligt), 0.0), 4.5)*1.2, 1.0));\n}\n\n\nvoid main()\n{\t\n\tvec2 p = gl_FragCoord.xy/resolution.xy-0.5;\n    vec2 q = gl_FragCoord.xy/resolution.xy;\n\tp.x*=resolution.x/resolution.y;\n    vec2 mo = vec2(0);\n\t\n\tvec3 ro = vec3(0.+smoothstep(0.,1.,tri(time*.6)*2.)*0.1, smoothstep(0.,1.,tri(time*3.)*3.)*0.08, -time*3.5-140.0);\n    ro.y -= camHeight(ro.zx)-.4;\n    mo.x += smoothstep(0.7,1.,sin(time*.35))*.5-1.5 - smoothstep(-.7,-1.,sin(time*.35))*.5;\n \n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.+sin(time*.5)*0.1,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\t\n    vec3 ligt = normalize( vec3(1.5, .9, -.5) );\n    float fg;\n\tfloat rz = march(ro,rd, fg, gl_FragCoord.xy);\n\tvec3 sky = Sky(rd, ligt);\n    \n    vec3 col = sky;\n   \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos, rz);\n        float d = distance(pos,ro);\n        nor = bump(pos,nor,d);\n        float shd = (shadow(pos,ligt,.04));\n        \n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),8.)*2.5;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2. );\n        col = vec3(.8);\n\t    col = col*dif*shd + spe*fre*shd*SUN_COLOUR +abs(nor.y)*vec3(.1, .1, .2);\n        col = mix(col, sky, smoothstep(FAR-10.,FAR,rz));\n    }else\n    {\n        col = Clouds(col, rd);\n    }\n\n    // Fog mix...\n    col = mix(col, vec3(0.6, .62, .7), fg);\n  \n    // Post...\n\tcol = min(pow(col*1.1,vec3(0.6)), 1.0);\n\t//col = smoothstep(0., 1., col);\n    \n    // Borders...\n    float f = smoothstep(0.0, 3.0, time)*.5;\n    col *= f+f*pow(70. *q.x*q.y*(1.0-q.x)*(1.0-q.y), .2);\n    \n    gl_FragColor = vec4( col, 1.0 );\n}\n", "user": "237457b", "parent": "/e#23398.0", "id": "24091.0"}