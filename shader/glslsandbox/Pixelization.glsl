{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define RIGHT_HALF gl_FragCoord.x > resolution.x * .5\n#define PIXELATION 0.066\n#define Pi 3.1415926\nvec2 toEuclidean( vec2 uv ) \n{\n\tfloat l = uv.y;\n\tfloat a = uv.x * Pi;\n\tuv = vec2( sin( a ), cos( a ) );\n\t\n\treturn uv * l;\n}\nbool checker( vec2 uv )\n{\n\treturn( mod( uv.x, 0.625 ) < 0.3125 ) ^^\n\t      ( mod( uv.y, 0.625 ) < 0.3125 ) ;\n}\n\nfloat pixelate( inout vec2 uv )\n{\n\tvec2 pix = mod( uv, PIXELATION );\n\tif( RIGHT_HALF ) uv -= pix - PIXELATION * .5;\n\tpix -= PIXELATION * .5;\n\treturn smoothstep( PIXELATION, 0., length(pix) );\n}\n\nvoid main( void ) {\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2. - 1.;\n\tvec4 background = vec4(smoothstep(2.,-4.,uv.y) );\n\tuv.x *= resolution.x/resolution.y;\n\t\n\tfloat shade_pixel = pixelate( uv );\n\t\n\tuv = uv * .5 + .5;\n\tif( uv.y > 0.3125 )\n\tuv = toEuclidean ( uv - vec2( 0., 0.3125 ) );\n\tuv.x += .1 * time;\n\tvec2 p = uv;\n\tp = mod(p*8., 2.5)-1.25; \n\t\n\tvec2 wob = vec2( cos(time), sin(time) );\n\tif( checker( uv ) )\n\t\tp += .25 * wob * sin(time*3.);\n\telse\n\t\tp *= .825 + .025 * sin( (-sin(p.x+time)+cos(p.y+time)) * 20.);\n\t\n\tvec3 n = vec3( p, cos(length(p)*3.1415926*.5) );\n\tn = normalize(n);\n\tvec3 light = 8. * vec3(sin(time*3.)+sin(time*4.)+.1*time+.5,sin(time*.2)+.5,sin(time)+1.5);\n\tvec3 light_n = light - n - 8.*vec3(uv, 0.0);\n\tlight_n = normalize( light_n );\n\n\tfloat intensity = dot( light_n, n);\n\tvec4 c1 = vec4( 1.5- clamp(pow(.25,intensity), 0., 1.) );\n\tvec4 c2 = vec4( n.x*.5+.5,n.y*.5+.5,n.z*.5+.5,1.);\n\tgl_FragColor = (c1*c2);\n\tgl_FragColor = mix( gl_FragColor, background, \n\t\t\t   \t\tsmoothstep(.9,1.0,length(p))\n\t\t\t  );\n\tif( RIGHT_HALF ) gl_FragColor *= shade_pixel;\n}", "user": "aefc2ec", "parent": "/e#26341.5", "id": "26413.7"}