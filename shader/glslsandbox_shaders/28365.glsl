{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat bound(float x)\n{\n    return max(x, pow(2., -23.));\n}\n\nfloat fold(in float x)\n{\n    return bound(abs(fract(x)-.5));\n}\n\nvec3 fold(in vec3 p)\n{\n    return vec3(fold(p.x), fold(p.y), fold(p.z));\n}\n\nfloat tf(in vec3 p, in float f, in float a)\n{\n    float n = 0.;\n    float q = 8.85;\n\n    for(int i = 0; i < 6; i++)\n    {\n        vec3 tp     = p * f;\n        tp          += fold(tp.zzy+fold(tp.yxx*-2.));\n        float fl    = fold(tp.z*2.+fold(tp.x+fold(tp.y)))/.125-.05;\n        n           = abs(a-n-fl*a);\n        a           *= .125;\n        f           *= q;\n        q           -= .25;\n    }\n    return n;\n}\n\nfloat hash(vec2 uv)\n{\n    return fract(cos(uv.x+sin(uv.y))*12345.6789);\n}\n\nvec2 neighbor_offset(float i)\n{\n\tfloat x = floor(i/3.);\n\tfloat y = mod(i, 3.);\n\treturn vec2(x,y)-1.;\n}\n\nfloat voronoi (vec2 p) \n{\n\tvec2 g = floor(p);\n\tvec2 f = fract(p);\n\tfloat res = 1.;\n\tvec2 bb = vec2(0.);\n\t\n\tfor(int i = 0; i < 9; i++) \n\t{\n\t\tvec2 b \t= neighbor_offset(float(i));\n\t\tfloat h = distance(hash(g+b)+b, f);\n\t\tres \t= min(res, h);\n\t}\n\treturn res;\n}\n\n\nfloat map(vec3 position)\n{\n\tposition\t*= 1.75;\n\n\tfloat v \t= 0.;\n\tfloat f \t= .33;\n\tfloat a \t= .33;\n\tfor(int i = 0; i < 4; i++)\n\t{\n\t\tv += voronoi(v + position.xz * f) * a;\n\t\tf *= 2.;\n\t\ta *= .5;\n\t}\n\t\n\tv = abs(.5-v);\n\tv += tf(position + vec3(sin(v), v, cos(v)), v, .125) * .0625;\n\treturn position.y + v * 2.;\n}\n\n\nfloat shadow(vec3 p, vec3 d)\n{\n\tconst int iterations\t= 8;\n \tfloat e       \t\t= .075;\n\tconst float u\t\t= .25;  \t\t   \n    \tfloat s \t\t= 1.;         \n    \tfor( int i=0; i < iterations; i++ )\n    \t{\n    \t\tfloat l = map(p + d * e);\n\t\tl \t= l < 0. ? l - l * .5 : l;\n\t\t\n    \t\ts \t= min(s, u*l/e);\n    \t    \te \t+= .00025;\n    \t}\n\treturn clamp(s, 0.125, 1.);\n}\n\nfloat occlusion( in vec3 p, in vec3 n )\n{\n\t\n  \tfloat occ = 0.0;\n  \tfloat sca = 1.;\n  \tfor ( int i=0; i < 8; i++ )\n  \t{\n  \t\tfloat hr = 0.125 * sca * float(i);\n    \t\tfloat dd = map(n * hr + p);\n    \t\tocc += -(dd-hr)*sca;\n    \t\tsca *= 0.5;\n  \t}\n  \treturn clamp( 1.0 - 3.0 * occ, 0.75, 1.0 );\n}\n\nvec3 derive(in vec3 position, in float range)\n{\n\tvec2 offset     = vec2(0., range);\n\tvec3 normal     = vec3(0.);\n\tnormal.x    \t= map(position+offset.yxx)-map(position-offset.yxx);\n\tnormal.y    \t= map(position+offset.xyx)-map(position-offset.xyx);\n\tnormal.z    \t= map(position+offset.xxy)-map(position-offset.xxy);\n\treturn normalize(normal);\n}\n\n\nvoid main( void ) \n{\n\tvec2 aspect\t\t= resolution.xy/resolution.yy;\n\t\n\tvec2 uv \t\t= gl_FragCoord.xy/resolution.xy;\n\tuv \t\t\t= (uv - .5) * aspect;\n\t\n\tvec2 m\t\t\t= (mouse-.5) * aspect;\n\t\n\t\n\t\n\tvec3 direction  \t= normalize(vec3(uv, 1.));\n\t\n\tdirection.xz \t\t*= rmat(mouse.x*6.28);\n\tdirection.y \t\t+= (mouse.y-.5) * .5;\n\tvec3 origin\t\t= vec3(0.);\n\tvec3 position\t\t= origin;\n\t\n\t\n\t\n\t//raytrace\n\tfloat range\t\t= 0.;\n\tfloat total_range\t= 0.;\n\tfloat minimum_range\t= .0001;\n\tfloat max_range\t\t= 6.;\n\tfloat closest_range\t= max_range;\n\tfloat edge\t\t= 0.;\n\tfor(int count = 0; count < 64; count++)\n\t{\n\t\trange \t\t= map(position);\n\t\trange \t\t= range < 0. ? range - range * .5 : range;\n\t\t\t\n\t\t\n\t\trange\t \t*= .8;\t\t//slow down ray\n\t\tminimum_range\t*= 1.03;\t//relax surface\n\t\t\n\t\ttotal_range\t+= range;\n\t\t\n\t\tposition \t= origin + direction * total_range;\t\n\t\t\n\t\tif(closest_range > range)\n\t\t{\n\t\t\tedge += 1./64.;\t\n\t\t}\n\t\t\n\t\tclosest_range\t= min(closest_range, abs(range));\n\t\t\n\t\t\n\t\tif(range < minimum_range || total_range > max_range)\n\t\t{\n\t\t\tbreak;\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\n\t//shade\n\tvec3 background_color \t= vec3(.275, .275, .45) - uv.y * .5;\n\tvec3 material_color\t= vec3(.8, .45, .25) * 1.5;\n\t\n\tvec3 color \t\t= background_color;\n\tif(total_range < max_range)\n\t{\n\t\tvec3 normal\t \t= derive(position, minimum_range);\n\t\n\t\tvec3 light_position \t= vec3(2.,4., 3.);\n\t\tvec3 light_direction\t= normalize(light_position-position);\n\t\t\n\t\tfloat light\t\t= max(dot(normal, light_direction), 0.);\n\t\t\n\t\t\n\t\tcolor \t\t\t+= material_color * light;\n\t\tcolor \t\t\t+= max(material_color/total_range, .25);\n\t\tcolor\t\t\t*= shadow(position, light_direction);\n\t\tcolor \t\t\t*= occlusion(position, normal);\n\t\tcolor \t\t\t-= 3. * edge * background_color;\n\t}\n\telse\n\t{\n\t\tcolor += material_color * edge;\t\n\t}\n\t\t\n\t\n\tgl_FragColor \t\t= vec4(color, 1.);\n}//sphinx", "user": "637c8c1", "parent": null, "id": "28365.0"}