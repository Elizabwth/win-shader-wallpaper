{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nvarying vec3 positionSurface;\nvarying vec3 positionSize;\n\nfloat  iGlobalTime() { return (time-60.); }\n\n//Cubic Entanglement by eiffie\n//Inspired by this little StructureSynth video http://www.youtube.com/watch?v=1uusQday0Z4\n//I had to dumb this down to get it to compile but you get the point.\n\n//Visually inspect the cubes for intersections then test yourself by undefining...\n\n//#define SHOW_INTERSECTIONS\n//#define SHOW_MORE_CONFIGURATIONS\n#ifdef SHOW_INTERSECTIONS\n\tint ints=0;\n#endif\n\n#define time iGlobalTime()\n#define size iResolution\nmat3 matPyr(vec3 rot){vec3 c=cos(rot),s=sin(rot);//orient the mat3 (pitch yaw roll)\n\treturn mat3(c.z*c.y+s.z*s.x*s.y,s.z*c.x,-c.z*s.y+s.z*s.x*c.y,-s.z*c.y+c.z*s.x*s.y,c.z*c.x,s.z*s.y+c.z*s.x*c.y,c.x*s.y,-s.x,c.x*c.y);\n}\n\nstruct configuration{mat3 rmx; vec3 offset;}cfg;\n\nconfiguration config(float i){\n\tvec3 rot=vec3(0.0),offset=vec3(0.0,-1.0,-0.56);\n   #ifdef SHOW_MORE_CONFIGURATIONS\n    i=mod(i,10.0);\n\tif(i<1.0){rot.x=0.52;offset.y=-0.94;}\n\telse if(i<2.0){rot.xy=vec2(0.52,0.21);offset.xy=vec2(-0.04,-0.94);}\n\telse if(i<3.0){rot.xy=vec2(0.52,-0.44);offset.xz=vec2(-0.15,-0.31);}\n\telse if(i<4.0){rot.xy=vec2(0.58,0.7);offset.x=-0.15;}\n\telse if(i<5.0){rot=vec3(0.64,0.97,0.08);offset.x=0.06;}\n\telse if(i<6.0){rot.xy=vec2(0.64,-0.94);offset.x=0.06;}\n\telse if(i<7.0){rot.y=-0.63;offset=vec3(0.4,-0.36,0.05);}\n\telse if(i<8.0){rot.xy=vec2(0.61,0.85);offset.xy=vec2(0.09,-0.98);}\n\telse if(i<9.0){rot.xy=vec2(0.46,-0.47);offset=vec3(0.34,-0.34,0.03);}\n\telse{rot.xy=vec2(0.7,-0.63);offset.xy=vec2(-0.02,-0.72);}\n   #else\n    i=mod(i,4.0);\n    if(i<2.0){rot.xy=vec2(0.58,0.7);offset.x=-0.15;}\n    else{rot.xy=vec2(0.7,-0.63);offset.xy=vec2(-0.02,-0.72);}\n    if(mod(i,2.0)<1.0){rot.y=-rot.y;offset.x-=offset.x;}\n   #endif\n\treturn configuration(matPyr(rot)*1.25,offset);\n}\n\nfloat cbox(vec3 p){\n\tp=abs(p);//there must be a more efficient way\n\treturn max(max(p.x,max(p.y,p.z))-1.0,-min(max(p.x,p.y),min(max(p.y,p.z),max(p.z,p.x)))+0.9);\n}\nfloat id=0.0,lastConfig=-100.0;\nfloat DE(in vec3 p){\n\tvec2 c=floor(p.xz*0.2);\n\tfloat fig=c.x+c.y*8.0;\n\tif(lastConfig!=fig){cfg=config(fig);lastConfig=fig;}\n\tp.xz=mod(p.xz,5.0)-2.5;\n\tc=abs(p.xz)-2.5;\n\tfloat b=min(p.y+1.0,max(p.y-2.0,0.5-max(c.x,c.y)));\n\tp.x+=cfg.rmx[2].x*0.5;\n\tfloat d=cbox(p),dr=1.0;\n\tfor(int i=0;i<8;i++){\n\t\tp=p*cfg.rmx;\n\t\tp+=cfg.offset;\n\t\tdr*=0.8;\n\t\tfloat d2=cbox(p)*dr;\n\t\t#ifdef SHOW_INTERSECTIONS\n\t\t\tif(d2<0.0)ints++;\n\t\t#endif\n\t\td=min(d,d2);\n\t}\n\tif(id<0.0){if(b<d)id=0.0;else id=1.0;}\n\treturn min(b,d);\n}\n\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(){\n\treturn 0.5+0.5*rnd(gl_FragCoord.xy+vec2(time*217.0));\n}\nfloat shadao(vec3 ro, vec3 rd, float px){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=2.0*px*rndStart();\n\tfor(int i=0;i<12;i++){\n\t\td=max(px,DE(ro+rd*t)*1.5);\n\t\tt+=d;\n\t\tres=min(res,d/t+t*0.1);\n\t}\n\treturn res;\n}\nvec3 Sky(vec3 rd){//what sky??\n\treturn vec3(max(0.0,rd.y)*(0.5+0.5*abs(sin(rd.x*10.0))));\n}\nvec3 L;\nvec3 Color(vec3 ro, vec3 rd, float t, float px, vec3 col, bool bFill){\n\tro+=rd*t;\n\tid=-1.0;\n\tfloat d=DE(ro);\n\tvec2 e=vec2(px*t,0.0);\n\tvec3 dn=vec3(DE(ro-e.xyy),DE(ro-e.yxy),DE(ro-e.yyx));\n\tvec3 dp=vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\tvec3 R=reflect(rd,N);\n\tvec3 lc=vec3(1.0,0.9,0.8),sc,rc=Sky(R);\n\tif(id==0.0){//floor\n\t\tsc=vec3(0.5)-abs(fract(ro*0.7)-vec3(0.5));\n\t\tsc=vec3(mix(0.3,0.5+0.05*sin((sc.x+sc.z)*50.0),smoothstep(0.0,1.6*px*t,min(sc.x,sc.z))));\n\t}else{//box\n\t\tsc=vec3(0.9,0.5,0.4);\n\t}\n\tfloat sh=clamp(shadao(ro,L,px*t)+0.2,0.0,1.0);\n\tsh=sh*(0.5+0.5*dot(N,L))*exp(-t*0.125);\n\tvec3 scol=sh*lc*(sc+rc*pow(max(0.0,dot(R,L)),4.0));\n\tif(bFill)d*=0.1;\n\tcol=mix(scol,col,clamp(d/(px*t),0.0,1.0));\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nfloat saw(float t){\n\tfloat d=abs(fract(t)-0.5);\n\tif(mod(t,4.0)>3.0)d=1.0-d;\n\treturn d;\n}\nvec3 path(float t){\n\tfloat tx=100.0+abs(mod(t,12.0)-6.0)-3.0;\n\treturn vec3(2.5+tx+saw(tx),0.5,t+saw(t+0.5))*5.0;\n}\nvoid main() {\n\tvec3 iResolution = vec3(resolution, 1.0);\n\tfloat px=0.5/size.y;\n\tL=normalize(vec3(0.4,0.8,-0.6));\n\tfloat tim=time*0.1;\n\tvec3 ro=(path(tim)+path(tim+0.1)+path(tim+0.3))/3.0;\n\tvec3 ta=(ro+path(tim+0.66)+path(tim+0.84))/3.0-ro;ta.y-=dot(ta,ta)*0.13;\n\t\n\tvec3 rd=lookat(ta)*normalize(vec3((2.0*gl_FragCoord.xy-size.xy)/size.y,3.0));\n\t//ro=eye*10.0;rd=normalize(dir);\n\tfloat t=DE(ro)*rndStart(),d=0.0,od=10.0;\n\tvec3 edge=vec3(-1.0);\n\tbool bGrab=false;\n\tvec3 col=Sky(rd);\n\tfor(int i=0;i<64;i++){\n\t\tt+=d;\n\t\td=DE(ro+rd*t);\n\t\tif(d>od){\n\t\t\tif(bGrab && od<px*t && edge.x<0.0){\n\t\t\t\tedge=vec3(edge.yz,t-od);\n\t\t\t\tbGrab=false;\n\t\t\t}\n\t\t}else bGrab=true;\n\t\tod=d;\n\t\t#ifdef SHOW_INTERSECTIONS\n\t\t\td=max(d,0.01);\n\t\t\tif(ints>1){gl_FragColor = vec4(1.0,0.0,0.0,1.0);return;}\n\t\t\tints=0;\n\t\t#endif\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tbool bFill=false;\n\td*=0.1;\n\tif(d<px*t && t<1000.0){\n\t\tif(edge.x>0.0)edge=edge.zxy;\n\t\tedge=vec3(edge.yz,t);\n\t\tbFill=true;\n\t}\n\tfor(int i=0;i<3;i++){\n\t\tif(edge.z>0.0)col=Color(ro,rd,edge.z,px,col,bFill);\n\t\tedge=edge.zxy;\n\t\tbFill=false;\n\t}\n\tgl_FragColor = vec4(4.0*col,1.0);\n}\n", "user": "5182efd", "parent": "/e#22833.0", "id": "22864.3"}