{"code": "// Mandelbrot mountain by Kabuto\n\n// Set quality to 1 (or even 0.5)\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst int MAX_ITER = 60;\n\nconst float ANTIALIAS = .5;\n\nconst float depth = 10.;\n\nfloat point(vec2 s) {\n\tvec4 a = vec4(s,1,0);\n\tvec4 c = vec4(s,1,0);\n\t\n\tfor(int iter = 0; iter < MAX_ITER; iter++) {\t\n\t\t// Testing every 4th iteration is enough for not getting float overflow and makes this routine much faster\n\t\ta = a.x*a*vec4(1,1,2,2)+a.y*a.yxwz*vec4(-1,1,-2,2)+c;\n\t\ta = a.x*a*vec4(1,1,2,2)+a.y*a.yxwz*vec4(-1,1,-2,2)+c;\n\t\ta = a.x*a*vec4(1,1,2,2)+a.y*a.yxwz*vec4(-1,1,-2,2)+c;\n\t\ta = a.x*a*vec4(1,1,2,2)+a.y*a.yxwz*vec4(-1,1,-2,2)+c;\n\t\tif(a.x*a.x+a.y*a.y > 16.) {\n\t\t\treturn length(a.zw)/length(a.xy)/log(length(a.xy));\n\t\t}\n\t}\n\treturn 1e10;\n\n}\n \nvoid main( void ) {\n\tfloat zoom = .05*exp(-sin(time*.3)*4.0-1.1)*2.;\n\t\n\tfloat yd = 1.;\n\tfloat z;\n\t\n\tconst vec2 perspective = vec2(0,.7);\n\t\n\tvec2 ct = ( gl_FragCoord.xy/ resolution.xy - vec2(.5,.5)+perspective)*vec2(resolution.x/resolution.y, 2.);\n\tfor (int i = 0; i < 14; i++) {\n\t\tvec2 p = (ct*yd -2.*perspective) * zoom + vec2(-.799,-.179);\n\t\tz = max(0.,1.0/(point(p)*zoom/resolution.y)-ANTIALIAS);\n\t\tfloat dd = (z*depth/resolution.y +1./yd-1.)*.5 / depth * (1./length(ct));\n\t\tyd += dd;\n\t\tif (dd*resolution.y < .1 || yd > resolution.y*3.) break;\n\t}\n\t\n\tgl_FragColor = sqrt(vec4(1.-1./(1.+z*vec3(0.01,.1,.5)), 1.));\n}\n", "user": "e5c6f9b", "parent": "/e#1609.0", "id": "1615.3"}