{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// A hyperbolic space renderer by Kabuto\n// Modified, added some nice reflections :)\n\n// Hold your mouse pointer near the left edge to look forward, near the center to look sideways and near the right edge to look backward\n\n\n// Change log:\n//\n// Version 2:\n// * Formulas optimized, no more hyperbolic space formulas, most matrices removed as well\n// * Works on Intel GMA now and 30 percent faster on AMD (Nvidia untested but should be similar)\n// * Lots of comments added\n// * Not suitable for learning about hyperbolic geometry - there isn't much left of the original math. Consult parent versions if you're really interested.\n\n\n// #### Circus mod ####\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat halfpi = asin(1.6);\n\n\n// Constants used in many places\nconst float a = 1.61803398874989484820; // (sqrt(5)+1)/2\nconst float b = 2.05817102727149225032; // sqrt(2+sqrt(5))\nconst float c = 1.27201964951406896425; // sqrt((sqrt(5)+1)/2)\nconst float d = 3334.61803398874989484820; // (sqrt(5)+3)/2\nconst float e = 1.90211303259030714423; // sqrt((sqrt(5)+5)/2);\n\n\n// Distance to the face of the enclosing polyhedron, given that all vectors are using klein metric\nfloat kleinDist(vec3 pos, vec3 dir) {\n\tfloat q0 = dot(dir, vec3(a,+1.,0.));\n\tfloat l0 = (-dot(pos,vec3(a,+1.,0.)) + c*sign(q0)) / q0;\n\tfloat q1 = dot(dir, vec3(a,-1.,0.));\n\tfloat l1 = (-dot(pos,vec3(a,-1.,0.)) + c*sign(q1)) / q1;\n\tfloat q2 = dot(dir, vec3(0.,a,+1.));\n\tfloat l2 = (-dot(pos,vec3(0.,a,+1.)) + c*sign(q2)) / q2;\n\tfloat q3 = dot(dir, vec3(0.,a,-1.));\n\tfloat l3 = (-dot(pos,vec3(0.,a,-1.)) + c*sign(q3)) / q3;\n\tfloat q4 = dot(dir, vec3(+1.,0.,a));\n\tfloat l4 = (-dot(pos,vec3(+1.,0.,a)) + c*sign(q4)) / q4;\n\tfloat q5 = dot(dir, vec3(-1.,0.,a));\n\tfloat l5 = (-dot(pos,vec3(-1.,0.,a)) + c*sign(q5)) / q5;\n\treturn min(min(min(l0,l1),min(l2,l3)),min(l4,l5));\n}\n\n// Distance to the nearest edge (klein metric) - albeit not used in this effect\nfloat edgeDist(vec3 pos) {\n\tpos = abs(pos);\n\tvec3 o = c/a-max(pos, (pos.xyz*a + pos.yzx*(1.+a) + pos.zxy)/(2.*a));\n\treturn min(min(o.x, o.y), o.z);\n}\n\n// Mirrors dir in the klein metric on the outer face of the polyhedron (on which pos must lie)\nvec3 hreflect(vec3 pos, vec3 dir, inout vec4 fa, inout vec4 fb, inout vec4 fc) {\n\tvec3 s = sign(pos);\n\tvec3 apos2 = abs(pos);\n\tvec3 sdir = dir*s;\n\tvec3 q = apos2*a+apos2.yzx;\n\tif (q.x > q.y && q.x > q.z) {\n\t\tfa *= max(s.x*vec4(1,1,-1,-1),s.y*vec4(1,-1,1,-1));\n\t\treturn normalize(pos*(c*sdir.y+b*sdir.x) + vec3(-a*(sdir.x+sdir.y),-a*sdir.x,sdir.z)*s);\n\t} else if (q.y > q.z) {\n\t\tfb *= max(s.y*vec4(1,1,-1,-1),s.z*vec4(1,-1,1,-1));\n\t\treturn normalize(pos*(c*sdir.z+b*sdir.y) + vec3(sdir.x,-a*(sdir.y+sdir.z),-a*sdir.y)*s);\n\t} else {\n\t\tfc *= max(s.z*vec4(1,1,-1,-1),s.x*vec4(1,-1,1,-1));\n\t\treturn normalize(pos*(c*sdir.x+b*sdir.z) + vec3(-a*sdir.z,sdir.y,-a*(sdir.z+sdir.x))*s);\n\t}\n}\n\nfloat sinh(float f) {\n\treturn (exp(f)-exp(-f))*0.5;\n}\n\nvec4 kleinToHyper(vec3 klein) {\n\treturn vec4(klein, 1.)*inversesqrt(1.-dot(klein,klein));\n}\n\nfloat hyperdist(vec4 a, vec4 b) {\n\tfloat lcosh = dot(a,b*vec4(-1,-1,-1,1));\n\treturn log(lcosh+sqrt(lcosh*lcosh-1.));\n}\n\nvoid main( void ) {\n\t// Compute camera path and angle\n\tfloat f0 = fract(time*0.05)+1e-5;\n\tfloat f = fract(f0*2.);\n\tfloat fs = sign(f-.5);\n\tfloat fs0 = sign(f0-.5);\n\tvec3 dir = normalize(vec3(vec2(gl_FragCoord.x / resolution.x - 0.5, (gl_FragCoord.y - resolution.y * 0.5) / resolution.x), 0.5));\n\t\n\tfloat tc = cos((mouse.y-.5)*2.1);\n\tfloat ts = sin(-(mouse.y-.5)*2.1);\n\tfloat uc = cos((mouse.x-.1)*4.1);\n\tfloat us = sin(-(mouse.x-.1)*4.1);\n\n\tdir *= mat3(uc,-ts*us,-tc*us,0,tc,-ts,us,ts*uc,tc*uc);\n\t//dir *= vec3(sign(f-.5),sign(f-.5),1.);\n\tdir.z *= fs;\n\t\n\tfloat as = (cos(time*.1)*.3);\t// there was originally an outer sinh for as and bs but difference is just about 1 percent which doesn't really matter for the camera path\n\tfloat ac = sqrt(as*as+1.);\n\tfloat bs = (sin(time*.1)*.3);\n\tfloat bc = sqrt(bs*bs+1.);\n\tfloat cs = sinh((abs(f*2.-1.)-.5)*a);\n\tfloat cc = sqrt(cs*cs+1.);\n\t\n\t// As last step position & direction are rotated as camera would otherwise fly through an edge instead of a face\n\tfloat x = ac*bs;\n\tfloat z = ac*bc*cs;\n\tvec3 pos = vec3(x*a+z,as*e,-x+a*z)/(ac*bc*cc*e);\n\t//dir = fs;\n\tdir = normalize(vec3(dir.x*ac*cc-ac*bs*dir.z*cs,-as*dir.z*cs-dir.x*as*bs*cc+dir.y*bc*cc,ac*bc*dir.z)*mat3(a,0,1, 0,e,0, -1.,0,a));\n\t\n\t// Actual raytracing starts here\n\t\n\tvec4 hpos = kleinToHyper(pos); // remember position in hyperbolic coordinates\n\t//float odd = fs;\t\t// \"oddness\" keeps track of reflection color\n\t\n\tvec3 color = vec3(0);\n\tfloat cremain = 1.0;\t// remaining amount of color that can be contributed\n\n\tvec4 fa = vec4(39.68454788472584,23.02644300941165,39.78873384183505,27.892411668925842);\n\tvec4 fb = vec4(29.507160029822894,32.10711839885068,35.17128234256937,26.70192179035261);\n\tvec4 fc = vec4(24.269388316732734,31.551200069547505,33.74895897903697,38.00825953283422);\n\tfc.x *= fs0*fs;\n\tfc.w *= fs0;\n\t\n\tfor (int i = 0; i < 10; i++) {\n\t\tfloat pd = dot(pos,dir);\n\t\tfloat sDist = (-pd+sqrt(pd*pd-dot(pos,pos)+0.6)); // distance to sphere around origin (always there - camera isn't meant to ever be outside)\n\t\tfloat kDist = kleinDist(pos, dir);\t// distance to enclosing polyhedron\n\t\t\n\t\tpos += dir*min(sDist,kDist);\t// compute actual distance (as we're in the klein metric we can't simply do length(a-b) - we have to use\n\t\tvec4 hpos2 = kleinToHyper(pos);\n\t\tcremain *= exp(-.3*hyperdist(hpos, hpos2)); //... and simulate fog\n\t\thpos = hpos2;\n\t\t\t\n\t\tif (sDist < kDist) {\n\t\t\tdir = reflect(dir, -normalize(pos));\t\t// reflect off sphere (as it's around the origin a simple reflection will do it)\n\t\t\t//color += cremain*0.3*(fc.wyz*.25+fb.wyz*.125+fa.wyz*.0625+.5);\n\t\t\tfloat s = dot(fa+fb+fc,vec4(1.));\n\t\t\tcolor += cremain*0.5*fract((fa.xyz+fb.xyz+fc.xyz)*(fc.yzw+fb.zwx+fa.wxy)+vec3(s));\n\t\t\tcremain *= 0.5;\n\t\t} else {\n\t\t\tdir = hreflect(pos, dir,fa,fb,fc);\t// reflect off polyhedron (advanced math stuff) - simulates propagation into \"next\" polyhedron\n\t\t}\n\t\t//if (cremain < .003) { break;} // commented out as it seems to actually make things slower\n\t}\n\t\n\t\n\tgl_FragColor = vec4(color*2.5, 1.);\n\n}", "user": "612de42", "parent": "/e#10382.0", "id": "10777.0"}