{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/XljSWw\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n#define resolution  stemu_resolution\n\n// --------[ Original ShaderToy begins here ]---------- //\nvec3 hash33(vec3 p){     \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n); \n}\n\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p); // \"p -= g;\" works on some GPUs, but not all, for some annoying reason.\n\tfloat d = 1.; \n\n    for(float j = -1.; j < 1.01; j++) {\n\t    for(float i = -1.; i < 1.01; i++) {\n    \t\t\n\t\t    b = vec3(i, j, -1.);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n    \t\t\t\n\t    }\n\t}\n\t\n\treturn d; // Range: [0, 1]\n}\n\nvec3 hsv2rgb (in float h, in float s, in float v) {\n\treturn v * (1.0 + 0.5 * s * (cos (2.0 * 3.1415926535898 * (h + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\n\nfloat noiseLayers(in vec3 p) {\n    vec3 t = vec3(0., 0., p.z+sin(iTime*.25));\n\n    const int iter = 5; // Just five layers is enough.\n    float tot = 0., sum = 0., amp = 1.; // Total, sum, amplitude.\n\n    for (int i = 0; i < iter; i++) {\n        tot += voronoi(p + t) * amp; // Add the layer to the total.\n        p *= 2.0; // Position multiplied by two.\n        t *= 1.5; // Time multiplied by less than two.\n        sum += amp; // Sum of amplitudes.\n        amp *= 0.5; // Decrease successive layer amplitude, as normal.\n    }\n    \n    return tot/sum; // Range: [0, 1].\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n\t//uv.y *= iResolution.x/iResolution.y;\n\t\n    float light = smoothstep (-0.7, 0.7, cos (cos(iTime*1.2)));\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 3.1415926535898/8.));\n\n    float cs = cos(iTime*0.125), si = sin(iTime*0.125);\n\trd.xy *= mat2(cs, -si, si, cs);\n\t\n    float c = noiseLayers(rd*.7);\n\n\tc *= sqrt(c*(1.-length(uv)))+sin(1.-length(uv))*2.;\n\tvec3 col = vec3(c);\n\t\n    vec3 col2 =  hsv2rgb(length(uv) * 0.6 + iTime * .5, 0.9, light);\n\tcol = mix(col, col.xyz*.3+c*.86, (rd.x*rd.y)*.45);\n\tcol *= mix(col, col2, 1.-length(uv));\n    \n\tfragColor = vec4(clamp(col, 0., 1.), 1.);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n#undef resolution\n\nvoid main(void)\n{\n  iTime = time;\n  iResolution = vec3(resolution, 0.0);\n\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "67f354", "parent": null, "id": "45630.0"}