{"code": "// \"Wet stone\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Mahmud Yuldashev modification mahmud9935@gmail.com\n// Gold Nugget modifications by I.G.P. - 12/2014\n\n#ifdef GL_ES\n  precision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.8);\nconst vec2 CORNER_PARAM = vec2(0.2, 20.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD   = 0.1;\nconst float EPSILON   = 1e-4;\nconst float LIGHT_INTENSITY = 0.2;\nconst vec3 RED    = vec3(1.0, 0.70, 0.3) * LIGHT_INTENSITY;\nconst vec3 ORANGE = vec3(1.0, 0.67, 0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE   = vec3(0.54, 0.77, 1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE  = vec3(1.2, 1.07, 0.98) * LIGHT_INTENSITY;\nconst float DISPLACEMENT = 0.1;\nconst float PI = 3.1415;\nconst int NUM_STEPS = 40;\n\n// math\nmat3 fromEuler(vec3 ang)\n{\n  vec2 a1 = vec2(sin(ang.x), cos(ang.x));\n  vec2 a2 = vec2(sin(ang.y), cos(ang.y));\n  vec2 a3 = vec2(sin(ang.z), cos(ang.z));\n  mat3 m;\n  m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);\n  m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);\n  m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);\n  return m;\n}\nfloat hash11(float p)\n{ return fract(sin(p * 727.1)*43758.5453123);\n}\nfloat hash12(vec2 p)\n{ float h = dot(p, vec2(127.1, 311.7));  \n  return fract(sin(h)*43758.5453123);\n}\nvec3 hash31(float p)\n{ vec3 h = vec3(1275.231, 4461.7, 7182.423) * p;  \n  return fract(sin(h)*43758.543123);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p)\n{\n  //p += 123.0;\n  vec3 i = floor(p);\n  vec3 f = fract(p);  \n  vec3 u = f*f*(3.0-2.0*f);\n\n  vec2 ii = i.xy + i.z * vec2(5.0);\n  float a = hash12( ii + vec2(0.0, 0.0) );\n  float b = hash12( ii + vec2(1.0, 0.0) );    \n  float c = hash12( ii + vec2(0.0, 1.0) );\n  float d = hash12( ii + vec2(1.0, 1.0) ); \n  float v1 = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n\n  ii += vec2(5.0);\n  a = hash12( ii + vec2(0.0, 0.0) );\n  b = hash12( ii + vec2(1.0, 0.0) );    \n  c = hash12( ii + vec2(0.0, 1.0) );\n  d = hash12( ii + vec2(1.0, 1.0) );\n  float v2 = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n\n  return max(mix(v1, v2, u.z), 0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) \n{\n  return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f)\n{\n  float ret = 0.0;    \n  float amp = 1.0;\n  float frq = 1.0;\n  for (int i = 0; i < 4; i++) {\n    float n = pow(noise_3(p * frq), 2.0);\n    ret += n * amp;\n    frq *= f;\n    amp *= a * (pow(n, 0.2));\n  }\n  return ret;\n}\n\n// lighting\nfloat diffuse(vec3 n, vec3 l, float p)\n{ \n  return pow(max(dot(n, l), 0.0), p);\n}\nfloat specular(vec3 n, vec3 l, vec3 e, float s)\n{    \n  float nrm = (s + 8.0) / (3.1415 * 4.0);\n  return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n  return dot(p.xyz, gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p, float r) {\n  return length(p)-r;\n}\nfloat capsule(vec3 p, float r, float h) {\n  p.y -= clamp(p.y, -h, h);\n  return length(p)-r;\n}\nfloat cylinder(vec3 p, float r, float h) {\n  return max(abs(p.y/h), capsule(p, r, h));\n}\nfloat box(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return max(max(p.x, p.y), p.z);\n}\nfloat rbox(vec3 p, vec3 s) {\n  p = abs(p)-s;\n  return length(p-min(p, 0.0));\n}\nfloat quad(vec3 p, vec2 s) {\n  p = abs(p) - vec3(s.x, 0.0, s.y);\n  return max(max(p.x, p.y), p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a, float b)     { return min(a, b); }\nfloat boolIntersect(float a, float b) { return max(a, b); }\nfloat boolSub(float a, float b)       { return max(a, -b); }\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k) \n{\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(a, b, h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k)\n{\n  return boolSmoothIntersect(a, -b, k);\n}  \n\n// world\nfloat rock(vec3 p)\n{    \n  float d = sphere(p, 1.0);    \n  for (int i = 0; i < 9; i++)\n  {\n    float ii = float(i);\n    float r = 2.0 + hash11(ii);\n    vec3 v = normalize(hash31(ii) * 2.10 - 1.0);\n    #ifdef SMOOTH\n      d = boolSmoothSub(d, sphere(p+v*r, r * 0.8), 0.03);\n    #else\n      d = boolSub(d, sphere(p+v*r, r * 0.8));\n    #endif\n  }\n  return d;\n}\n\nfloat map(vec3 p)\n{\n  float d = rock(p) + fbm3(p*4.0, 0.4, 2.96) * DISPLACEMENT;\n  d = boolUnion(d, plane(p, vec4(0.0, 1.0, 0.0, 1.0)));\n  return d;\n}\n\nfloat map_detailed(vec3 p)\n{\n  float d = rock(p) + fbm3_high(p*4.0, 0.4, 2.96) * DISPLACEMENT;\n  d = boolUnion(d, plane(p, vec4(0.0, 1.0, 0.0, 1.0)));\n  return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens)\n{\n  vec3 n;\n  n.x = map_detailed(vec3(p.x+EPSILON, p.y, p.z));\n  n.y = map_detailed(vec3(p.x, p.y+EPSILON, p.z));\n  n.z = map_detailed(vec3(p.x, p.y, p.z+EPSILON));\n  return normalize(n-map_detailed(p));\n}\n\nvec2 getOcclusion(vec3 p, vec3 n) \n{\n  vec2 r = vec2(0.0);\n  for (int i = 0; i < AO_SAMPLES; i++)\n  {\n    float f = float(i)*INV_AO_SAMPLES;\n    float hao = 0.01+f*AO_PARAM.x;\n    float hc = 0.01+f*CORNER_PARAM.x;\n    float dao = map(p + n * hao) - TRESHOLD;\n    float dc = map(p - n * hc) - TRESHOLD;\n    r.x += clamp(hao-dao, 0.0, 1.0) * (1.0-f);\n    r.y += clamp(hc+dc, 0.0, 1.0) * (1.0-f);\n  }    \n  r.x = pow(clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y, 0.0, 1.0), 0.5);\n  r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y, 0.0, 1.0);\n  return r;\n}\n\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) \n{\n  vec2 td = vec2(0.0);\n  for (int i = 0; i < NUM_STEPS; i++)\n  {\n    p = ori + dir * td.x;\n    td.y = map(p);\n    if (td.y < TRESHOLD) break;\n    td.x += (td.y-TRESHOLD) * 0.9;\n  }\n  return td;\n}\n\n// stone\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) \n{\n  c = min(c + pow(noise_3(vec3(p.x*20.0, 0.0, p.z*20.0)), 70.0) * 8.0, 1.0);\n  float ic = pow(1.0-c, 0.5);\n  vec3 base = vec3(0.42, 0.36, 0.14)*0.8;\n  vec3 sand = vec3(0.44, 0.38, 0.2)*0.8;\n  vec3 color = mix(base, sand, c);\n\n  float f = pow(1.0 - max(dot(n, -e), 0.0), 1.5) * 0.75 * ic;\n  color = mix(color, vec3(1.0), f);    \n  color += vec3(diffuse(n, l, 0.5) * RED);\n  color += vec3(specular(n, l, e, 8.0) * RED * 1.5 * ic);\n  n = normalize(n - normalize(p) * 0.4);    \n  color += vec3(specular(n, l, e, 8.0) * RED * 1.5 * ic);    \n  return color;\n}\n\n// main\nvoid main(void) \n{\n  vec2 iuv = gl_FragCoord.xy / resolution.xy * 2.0 - 1.0;\n  vec2 uv = iuv;\n  uv.x *= resolution.x / resolution.y;    \n\n  // ray\n  vec3 ang = vec3(0.0, clamp(2.0-mouse.y*2.0, -PI, PI), mouse.x*4.0 + time*0.03);\n  mat3 rot = fromEuler(ang);\n\n  vec3 ori = vec3(0.0, 0.0, 2.8);\n  vec3 dir = normalize(vec3(uv.xy, -2.0));    \n  ori = ori * rot;\n  dir = dir * rot;\n\n  // tracing\n  vec3 p;\n  vec2 td = spheretracing(ori, dir, p);\n  vec3 n = getNormal(p, td.y);\n  vec2 occ = getOcclusion(p, n);\n  vec3 light = normalize(vec3(0.0, 1.0, 0.0)); \n\n  // color\n  vec3 color = vec3(0.5);    \n  if (td.x < 3.5 && p.y > -0.89) \n    color = getStoneColor(p, occ.y, light, n, dir);\n  color *= occ.x;\n\n  // background\n//  color = mix(vec3(1.0), color, step(td.y, 1.0));\n\n  // post\n  float vgn = smoothstep(1.2, 0.7, abs(iuv.y)) * smoothstep(1.1, 0.8, abs(iuv.x));\n  color *= 1.0 - (1.0 - vgn) * 0.15;  \n  gl_FragColor = vec4(color, 1.0);\n}\n", "user": "bd397b0", "parent": "/e#22126.0", "id": "22455.0"}