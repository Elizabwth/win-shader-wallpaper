{"code": "// fucking instruction limit\n// i dont really even like star wars\n// - sphinx\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform float time;\n\n#define ASPECT               \tresolution.x/resolution.y\n#define PHI                  \t.0001\n#define EPSILON                 .00002\n#define FOV                     2.\n#define FARPLANE                12.\n#define ITERATIONS              128\n\n#define OCCLUSION_ITERATIONS    24\n#define OCCLUSION_SCALE         .001\n\n#define SHADOW_ITERATIONS       16\n#define SHADOW_DISTANCE         2\n#define SHADOW_PENUMBRA         16.\n\n#define PI                  \t(4.*atan(1.))       \n#define TAU                 \t(8.*atan(1.))   \n\nstruct ray\n{\n\tvec3 origin;\n\tvec3 position;\n\tvec3 direction;\n\tvec2 material_range;\n\tfloat steps;\n}; \n\nstruct surface\n{\n\tvec4 color;\n\tvec3 normal;\n\tfloat range;\n};  \n\nstruct light\n{\n\tvec3 color;\n\tvec3 position;\n\tvec3 direction;\n\tvec3 ambient;\n};  \n\nstruct material\n{\n\tvec3  color;\n\tfloat refractive_index;\n\tfloat roughness;\n\tfloat transparency;\n};  \n\nray         view(in vec2 uv);   \nray         emit(ray r);\nray         absorb(ray r);\nvec2        map(in vec3 position);\nvec3        derive(in vec3 p);\n\nmaterial    assign_material(in float material_index, in vec3 position);\nvec3        hsv(in float h, in float s, in float v);\n\nsurface     shade(in ray r, in surface s,  in material m, in light l);\nfloat       fresnel(in float i, in float hdl);  \nfloat       geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl);\nfloat       distribution(in float r, in float ndh);\nvec2        ambient_occlusion(vec3 p, vec3 n);\nfloat       shadow(vec3 p, vec3 d, float e);\nvec3        facet(vec3 n, vec3 p, float r);\nvec3        flare(ray r, light l, float e);\nsurface     caustic(in ray r, in surface s,  in material m, in light l);\n\nvec3        sphericalharmonic(vec3 n, in vec4 c[7]);\nvoid        shcday(out vec4 c[7]);\n\nfloat       smoothmin(float a, float b, float k);\nfloat       cross(float x);\nfloat       convolute(float x);\nvec3        convolute(vec3 x);\n\nfloat       sphere(vec3 position, float radius);\nfloat       cube(vec3 position, vec3 scale);\nfloat       torus( vec3 p, vec2 t );\nfloat       cylinder(vec3 p, float l, float r);\nfloat       cone(vec3 p, float l, vec2 r);\nfloat       icosahedral(vec3 p, float e, float r);\nfloat       partition_noise(vec2 uv);\n\nfloat       hash(float x);\nvec2        hash(vec2 v);\n\nmat2        rmat(in float r);\n\nvec2        format_to_screen(vec2 uv);\n\n//// SCENES\nvec3 g_position         = vec3(0.);\nfloat g_light           = 0.;\nfloat g_accumulation    = 0.;\n\n//overly complex viewing system for modeling\n#define SCREEN_LEFT gl_FragCoord.x < resolution.x * .5\n#define SCREEN_BOTTOM   gl_FragCoord.y < resolution.y * .5\n#define MOUSE_LEFT  mouse.x < .5\n#define MOUSE_BOTTOM    mouse.y < .5\n#define VIEW_SWITCH mouse.x > .02   \n#define PANEL_LEFT  (VIEW_SWITCH ? MOUSE_LEFT : SCREEN_LEFT)\n#define PANEL_BOTTOM    (VIEW_SWITCH ? MOUSE_BOTTOM : SCREEN_BOTTOM)\n#define UV      VIEW_SWITCH ? (gl_FragCoord.xy/resolution.xy) : fract(2.*(gl_FragCoord.xy/resolution.xy))\n#define TOP         vec3(0., 7., .49)\n#define TOP_V       vec3(0., 0., .5001)\n#define BOTTOM      vec3(0., -7., .49)\n#define BOTTOM_V    vec3(0., 0., .5001)\n#define SIDE        vec3(4.5, 0., 0.5)\n#define SIDE_V      vec3(0., 0., 0.5)\n#define BACK        vec3(0., 0., 6.)\n#define BACK_V      vec3(0., 0., 0.001)\n#define QUARTER     vec3(-2.5, 2.5, -2.75)\n#define ORIGIN_V    vec3(0., 0., 0.001)\n#define TURRET\t    vec3(1.5, 0.4, 2.5)\n#define TURRET_V    vec3(0., 0., 0.5)\n\n\n#define VIEWPOSITION    (PANEL_LEFT ? PANEL_BOTTOM ? TOP   : BACK   : PANEL_BOTTOM ? SIDE   : QUARTER)\n#define VIEWTARGET      (PANEL_LEFT ? PANEL_BOTTOM ? TOP_V : BACK_V : PANEL_BOTTOM ? SIDE_V : ORIGIN_V)\n\n//#define VIEWPOSITION      SIDE + vec3(0., 0., 2.)\n//#define VIEWTARGET        SIDE_V  + vec3(0., 0., -2.)\n//#define VIEWPOSITION      TURRET\n//#define VIEWTARGET        TURRET_V\n//#define VIEWPOSITION      BOTTOM\n//#define VIEWTARGET        BOTTOM_V\n\n#define LIGHTPOSITION   vec3(12.,6.5, -22.)\n//#define LIGHTPOSITION     VIEWTARGET+VIEWPOSITION*1.5+vec3(-4.,3.,4.)\n//#define LIGHTPOSITION     vec3(vec2(-7.,7.)*rmat(time),6.).xzy\n#define LIGHTCOLOR  vec3(.95, 0.95,  0.86)\n\n\n\nvec2 map(in vec3 position)\n{    \n\t//panel aware view rotations\n\tif(true){\n\t\tif(PANEL_BOTTOM && PANEL_LEFT)\n\t\t{\n\t\t\tposition.zy *= rmat(mouse.x*12.56);\n\t\t}\n\t\telse\n\t\t{ \n\t\t\tposition.xz *= rmat(mouse.x*12.56);\n\t\t}\n\t}\n\tposition.z                  \t+= 1.5;\n\t\n\tfloat ship                  \t= FARPLANE;\n\t\n\n\t//main hulls\n\tvec3 hull_position          \t= position;\n\thull_position.x             \t= max(abs(position.x),.04);\n\t\n\t//laterial insets \n\thull_position.x             \t*= hull_position.z > .1     \n\t&& hull_position.z < 1.1 \n\t? 1.05 : 1.;\n\n\thull_position.x             \t*= hull_position.z > 1.85   \n\t&& hull_position.z < 2. \n\t? 1.025 : 1.;\n\t\n\thull_position.y             \t= abs(hull_position.y)*.75+position.z*.001;\n\t\n\t\n\tvec3 hull_scale             \t= vec3(1.);\n\thull_scale.x                \t= position.z*.3+.45, \n\thull_scale.y                \t= position.z*.05+.085;\n\thull_scale.y               \t+= -abs(max(abs(position.x*.87),position.z*.025)*.187);\n\thull_scale.z               \t= min(hull_position.y+4., 4.);\n\thull_scale.z               \t+= abs(position.y);\n\t\n\t\n\t//inner hull\n\tvec3 hull_inner_scale           = hull_scale;\n\thull_inner_scale.x          \t+= abs(position.x)*.03-.01-position.z * .0005;\n\thull_inner_scale.y          \t= position.z < 4.1 ? .05 : hull_inner_scale.y;\n\thull_inner_scale.z          \t+= abs(position.x)*.012 + .15;\n\t\n\tvec3 hull_inner_position        = hull_position;    \n\thull_inner_position.y           = abs(position.y)<abs(hull_position.y) ? position.y : hull_position.y; //delete?\n\n\tfloat hull_inner        \t= cube(hull_inner_position, hull_inner_scale);\n\t\n\t\n\tvec3 hull_outer_scale           = hull_scale * vec3(1.05,1.05, 1.031);\n\thull_outer_scale.y         \t+= position.y > .5 ? -position.z * .025 : 0.;\n\t\n\thull_position.y             \t= abs(hull_position.y-.05+position.z*.0025);\n\t\n\tfloat hull_outer            \t= cube(hull_position, hull_outer_scale);\n\n\thull_outer                  \t= max(hull_outer, -hull_inner);\n\tship                        \t= min(hull_outer, ship);    \n\n\tbool inner_hull             \t= hull_inner < hull_outer;\n\tbool outer_hull             \t= hull_inner > hull_outer;\n\t\n\tbool engines            \t= false;\n\tbool bridge_tower\t        = false;\n\tbool aft \t\t\t= false;\n\tbool domes \t\t\t= false;\n\t\n\t//hull details\n\tfloat forward_partitions        = partition_noise(floor(position.z*8.)/8.+position.yx*8.);\n\tfloat deck_partitions\t\t= partition_noise(floor(position.x*8.)/8.+position.yz*8.);\n\t\n\tfloat hull_plating          \t= partition_noise\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.xz*31.)/31.\n\t\t\t\t\t+floor(position.xz*63.)/63.\n\t\t\t\t\t+position.xz*2.5-.41\n\t\t\t\t\t+abs(position.z)*.2\n\t\t\t\t\t);\n\t\n\tfloat hull_panels       \t= max(hull_plating, .85) * 4.; \n\tfloat forward_panels       \t= max(forward_partitions, .85);\n\t\n\tfloat z_floor_noise        \t= hash\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.z*13.+position.z)/8.\n\t\t\t\t\t+floor(position.z*5.)/3.\n\t\t\t\t\t);\n\t\n\tz_floor_noise         \t\t= floor(z_floor_noise*8.)/8.;\n\t\n\tfloat outboard_partitions\t= partition_noise\n\t\t\t\t\t(\n\t\t\t\t\tfloor(position.x*16.)/8. +\n\t\t\t\t\tz_floor_noise +\n\t\t\t\t\tposition.yz * 8.*\n\t\t\t\t\tvec2(3.5, 1.2*(1.+hull_plating*.05))\n\t\t\t\t\t);\n\n\t\n\t//aft hull && engines\n\tif(inner_hull && hull_position.z > 4.0 && hull_position.y < .375)\n\t{   \n\t\t//aft structures\n\t\taft                 \t\t= true;\n\t\t\n\t\thull_inner\t\t\t= max(hull_inner-.05, -hull_outer);\n\t\tvec2 absxy\t\t\t= abs(position.xy*1.1);\n\t\tbool columns\t\t\t= mod(absxy.x-.25, .85) > .3625;\n\t\tbool spars\t\t\t= mod(absxy.x+absxy.y, .25) > .025 ^^ mod(absxy.x-absxy.y, .25) > .025;\n\n\t\thull_inner_scale.z\t\t+= columns || spars ? .00 : -.0125;     \n\n\t\thull_inner\t\t\t= cube(hull_inner_position, hull_inner_scale);\n\t\thull_inner\t\t\t+= columns && !spars ? -.05 : -0.;\n\t\thull_inner\t\t\t+= !columns && !spars ? fract((absxy.x-absxy.y)*16.+.9)*0.01 : 0.;\n\t\thull_inner\t\t\t+= spars ? 0.01 : 0.05;\n\t\thull_inner\t\t\t+= !spars && columns ? forward_panels*.005 : 0.;\n\t\thull_outer\t\t\t= max(hull_outer,-hull_inner);\n\n\t\t//main engines\n\t\tvec3 engine_position    \t= position.yzx;\n\t\tengine_position.z       \t= abs(engine_position.z) < .4 ? engine_position.z : abs(engine_position.z)-.8;\n\t\n\t\tengine_position         \t+= -vec3(0.,4.1,0.);\n\t\tfloat engine_angle      \t= atan(engine_position.x, engine_position.z)/TAU;\n\t\t\t\n\t\tfloat engine_contour    \t= clamp(engine_position.y*.5,.05,.15);\n\t\tengine_contour          \t= engine_position.y > .35 ? .2 : engine_contour;\n\t\t\t\n\t\tvec2 radii          \t\t= vec2(engine_contour, .25);\n\t\tfloat depth         \t\t= .21;\n\t\tfloat engine           \t \t= cone(engine_position, depth, radii);\n\t\n\t\tengine              \t\t+= fract(engine_position.y*8.)>.2 ? .01 : 0.;\n\t\tengine              \t\t+= fract(engine_angle*16.)>.1 ? .01 : 0.;\n\t\tengine_position.y      \t \t+= -.125;\n\t\tfloat engine_mask      \t \t= cone(engine_position, depth, radii);\n\t\tengine_mask            \t \t+= fract(engine_position.y*8.)>.2 ? .01 : 0.;\n\t\tengine              \t\t= max(engine, -engine_mask);    \n\t\t\n\t\t//booster engines\n\t\tvec3 booster_position   \t= position.yzx;\n\t\tbooster_position.x      \t= abs(booster_position.x)-.165;\n\t\tbooster_position.z      \t= abs(booster_position.z)-.4;\n\t\tbooster_position        \t+= vec3(0.,-4.15,0.);\n\t\tfloat booster_radius    \t= length(booster_position.xz);\n\t\tfloat booster_angle     \t= atan(booster_position.x, booster_position.z)/TAU;\n\t\tfloat booster_contour   \t= booster_position.y > .1 ? .115 : .15;\n\t\tfloat booster_length    \t= booster_radius < .065 ? .12  : .195 - booster_radius * booster_position.y;\n\t\tfloat booster           \t= cylinder(booster_position, booster_length , booster_contour);\n\t\t\n\t\tbooster             \t\t+= fract(booster_position.y*8.)>.8 ? .01 : 0.;\n\t\tbooster            \t\t+= fract(booster_angle*16.)>.1 ? .01 : 0.;\n\n\t\tfloat engines         \t\t= min(engine, booster);\n\t\tship               \t\t= min(engines, ship);\n\t}\n\t\n\t//conning tower\n\tfloat tower = FARPLANE;\n\tif(position.y > 0.)\n\t{                   \n\t\t//bridge\n\t\tvec3 bridge_position            = hull_position;\n\t\tbridge_position.y       \t+= -hull_position.z * .05 - .46;\n\t\tbridge_position.z          \t+= -3.8;\n\t\t\n\t\tvec3 bridge_scale          \t= vec3(1.);\n\t\tbridge_scale.x             \t= -bridge_position.z*.05+.8;\n\t\tbridge_scale.x             \t+= abs(bridge_position.y) < .035 ? outboard_partitions*-.025 : 0.;\n\t\tbridge_scale.y\t\t\t= -abs(bridge_position.x)*.1+.125;\n\t\tbridge_scale.z\t\t\t= -bridge_position.z*.01-abs(bridge_position.x)*.15+.25;\n\t\t\n\t\tfloat bridge\t\t\t= cube(bridge_position, bridge_scale);\n\t\t\n\t\tvec2 bridge_detail\t\t= hash(floor(hull_position.xy*8.)+floor(hull_position.xy*18.))+.25;\n\t\t\n\t\tvec3 bridge_decks_position      = bridge_position;\n\t\tbridge_decks_position.z         = mod(bridge_position.z, .0625)-.00375;\n\t\tbridge_decks_position.z         = max(abs(bridge_decks_position.z)*2., abs(bridge_position.z)-bridge_detail.x*.1)+.05;\n\t\tfloat bridge_decks          \t= cube(bridge_decks_position, bridge_scale);\n\t\tbridge_decks                \t+= -forward_panels*.001;\n\t\t\n\t\t//sensor bar\n\t\tvec3 sensor_bar_position        = bridge_position;\n\t\tsensor_bar_position.y           += -.22;\n\t\tsensor_bar_position.z           += -.07;\n\t\t\n\t\tvec3 sensor_bar_scale           = vec3(1.);\n\t\tsensor_bar_scale.x          \t= .4;\n\t\tsensor_bar_scale.y          \t= sensor_bar_position.z*.01+.015;\n\t\tsensor_bar_scale.z          \t= -abs(position.x)*.025+.075;\n\t\n\t\tfloat sensor_bar            \t= cube(sensor_bar_position, sensor_bar_scale);\n\t\tsensor_bar                  \t+= fract(sensor_bar_position.x*8.-.1)>.8 ? -.0025 : 0.;\n\t\tsensor_bar                  \t+= fract(sensor_bar_position.z*8.-.3)>.4 ? .0035 : 0.;\n\t\t\n\t\t\n\t\tvec3 sensor_bar_base_position   = sensor_bar_position;\n\t\tsensor_bar_base_position.y      += .08;\n\t\tsensor_bar_base_position.z      += -.02;\n\t\t\n\t\tvec3 sensor_bar_base_scale      = vec3(1.);\n\t\tsensor_bar_base_scale.x         = -sensor_bar_position.y*.5-sensor_bar_position.z*.6-abs(sensor_bar_position.x)*.25+.05;\n\t\tsensor_bar_base_scale.y         = .074;\n\t\tsensor_bar_base_scale.z         = .08+sensor_bar_position.y*-.5;\n\t\tsensor_bar_base_scale.z         += abs(sensor_bar_base_position.x)<.1\n\t\t\t\t\t\t&& abs(sensor_bar_base_position.y-.025)<.015            \n\t\t\t\t\t\t&& sensor_bar_base_position.z<-.1\n\t\t? -.005 : 0.;       \n\t\t\n\t\tfloat sensor_bar_base           = cube(sensor_bar_base_position, sensor_bar_base_scale);        \n\t\t\n\t\tsensor_bar                  \t= min(sensor_bar, sensor_bar_base);\n\t\t\n\t\t//ray domes\n\t\tvec3 ray_dome_position          = bridge_position;  \n\t\tray_dome_position.z         \t+= .06;\n\t\tray_dome_position.y         \t+= -.16;\n\t\tray_dome_position.y         \t*= 1.3;\n\t\tray_dome_position.x         \t= abs(ray_dome_position.x)-.625;\n\t\t\t\n\t\tfloat ray_domes             \t= icosahedral(ray_dome_position*1.1, 24., .11);\n\t\t\t\n\t\tvec3 support_position       \t= ray_dome_position;\n\t\tsupport_position.y          \t+= .07;\n\t\tfloat support               \t= cube(support_position, vec3(.06));        \n\t\tfloat support_mask          \t= cube(support_position, vec3(.065,.1,.065));       \n\t\t\t\n\t\tvec3 absp                   \t= abs(support_position);\n\t\tbool struts                 \t= absp.x<.06 ^^ absp.z>.06; \n\t\tbool spars                  \t=  fract(abs(absp.x-absp.y))>.02\n\t\t\t\t\t\t&& fract(abs(absp.z-absp.y))>.02;\n\t\t\n\t\tsupport                     \t+= spars && !struts ? .01 : -.015;\n\t\n\t\tsupport                     \t= max(support, -support_mask);\n\t\t\t\n\t\t//tower \t\n\t\tvec3 tower_position         \t= hull_position;\n\t\ttower_position.z            \t+= -4.045;\n\t\ttower_position.z            \t+= tower_position.z > 4. ? tower_position.y * .3 : 0.;\n\t\ttower_position.y        \t+= -.51;\n\t\t\n\t\tvec3 tower_scale            \t= vec3(1.);\n\t\ttower_scale.x               \t= -tower_position.y*.1+.15;\n\t\ttower_scale.y               \t= .2;\n\t\ttower_scale.z               \t= tower_position.z*.05;\n\t\ttower_scale.z               \t+= tower_position.z > .2 ? -tower_position.y*.6+.4 : tower_position.y*.25+.3;\n\t\ttower_scale.x               \t+= fract(tower_position.y*16.-z_floor_noise-.3) > .6 - z_floor_noise * .05 \n\t\t\t\t\t\t&& tower_position.z + tower_position.y * .5 - z_floor_noise * .15 < .15\n\t\t\t\t\t\t&& tower_position.y < .14\n\t\t\t\t\t\t? outboard_partitions * -.015 : 0.;\n\t\t\n\t\tfloat tower                 \t= cube(tower_position, tower_scale);\n\t\t\t\n\t\t\t\n\t\tvec3 tower_base_position    \t= tower_position;\n\t\ttower_base_position.y       \t+= .15;\n\t\ttower_base_position.z       \t+= .05;\n\t\t\t\n\t\tvec3 tower_base_scale       \t= tower_scale;\n\t\ttower_base_scale.x          \t= -tower_position.y*.13+.19;\n\t\ttower_base_scale.z          \t+= -.1;\n\t\ttower_base_scale.y          \t= tower_position.z*.05+.1;\n\t\t\t\n\t\tfloat tower_base            \t= cube(tower_base_position, tower_base_scale);\n\t\t\n\t\tfloat tower_vents       \t= position.z > 3.8 ? fract(position.y*32.)*.05 : 0.;\n\t\t\n\t\ttower                       \t+= abs(position.x) < .25-position.y*.1-.07 \n\t\t&& position.y < .93\n\t\t? tower_vents : 0.;\n\t\t\t\n\t\t//compositing\n\t\ttower                   \t= min(tower, tower_base);       \n\t\tbridge_decks               \t= min(bridge-.01, bridge_decks+.01);    \n\t\tbridge_decks               \t= min(bridge_decks, support);\n\t\tray_domes                  \t= min(ray_domes, sensor_bar);\n\t\tdomes                      \t= ray_domes < bridge;\n\t\ttower                      \t= min(tower, bridge_decks);\n\t\tbridge                     \t= min(bridge, ray_domes); \n\t\ttower                      \t= min(bridge,tower);\n\t\tbridge_tower               \t= tower < ship;\n\t\t\n\t\tship                \t\t= min(tower, ship);\n\t}\n\thull_inner              \t= max(hull_inner, -tower);\n\thull_inner             \t\t= max(hull_inner, -tower);\n\tship                \t\t= min(ship, hull_inner);\n\n\n\t//solar collector (round thing on the bottom)\n\tvec3 collector_position     \t= position;\n\tcollector_position.z        \t+= -2.8;\n\tcollector_position.xz       \t*= rmat(3.14/4.);\n\tcollector_position.y        \t+= abs(collector_position.x)-.0125 < 0. \n\t\t\t\t\t|| abs(collector_position.z)-.0125 < 0.\n\t\t\t\t\t? -.05 : 0.;\n\n\tcollector_position.y \t\t*= 2.;\n\tcollector_position.y    \t+= -hull_plating * .005 + .45;\n\t\n\tfloat collector_scale       \t= position.y < -hull_scale.y ? .45 : 0.;\n\t\n\tfloat collector             \t= sphere(collector_position, collector_scale);\n\tbool solar_collector        \t= collector < ship;\n\t\n\t\n\t//super structure for upper decks\n\tvec3 deck_position      \t= hull_position;\n\tvec2 absxz              \t= abs(position.xz*3.);\n\tif(position.y > 0. && !inner_hull)\n\t{\n\t\tbool indents    \t= fract(absxz.y*.35 + .2)>.1;\n\t\t\n\t\t//outboard offset\n\t\tdeck_position.x \t+= deck_position.z - deck_position.x * .06 > 1. + deck_position.x * .15    \n\t\t\t\t\t&& deck_position.z < 3.91 - deck_position.x * .985\n\t\t\t\t\t&& deck_position.x - deck_position.z * .135 < .2\n\t\t\t\t\t? -.3 : 0.;\n\t\n\t\t//lower decks\t\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x > 1.75 \n\t\t\t\t\t&& deck_position.z > 1.285\n\t\t\t\t\t&& deck_position.z + deck_position.x *.3 < 4.45   \n\t\t\t\t\t&& deck_position.x < .4 + deck_position.z * .15\n\t\t\t\t\t? -.025 : 0.;\n\t\t\t\n\t\t//gun decks\t\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x > 1.65 \n\t\t\t\t\t&& deck_position.z > 2.5\n\t\t\t\t\t&& deck_position.z + deck_position.x *.5 < 4.38\n\t\t\t\t\t&& deck_position.x < deck_position.z * .25 +.4\n\t\t\t\t\t? -.015 : 0.;\n\n\t\t//turrets\n\t\tvec3 turret_position    = hull_position - vec3(position.z * .2-.15,.045+hull_position.z*.01, 3.23);\n\t\t\n\t\tturret_position.z   \t= abs(abs(abs(turret_position.z)-.125)-.125)-.125;\n\t\tturret_position.x   \t= abs(turret_position.x)-.5;\n\t\t\t\n\t\n\t\tvec2 turret_radius  \t= vec2(.02, .02);\n\t\tturret_radius.x     \t= turret_position.y > .01 ? .04 : .01;\n\t\tturret_radius.y     \t= abs(turret_position.z) > .015 \n\t\t\t\t\t|| turret_position.x > .0025 \n\t\t\t\t\t? .001 : turret_radius.y+.005;\n\t\t\n\t\tfloat turret_depth  \t= .025;\n\t\t\n\t\tfloat turret        \t= cone(turret_position, turret_depth, turret_radius);\n\t\tvec3 barrel_position    = turret_position;\n\t\tbarrel_position.y   \t+= -.045;\n\n\t\t\n\t\tfloat barrel       \t= cube(barrel_position, vec3(.03,0.005,.005));\n\t\tturret          \t= min(turret, barrel);\n\n\t\tdeck_position.y     \t+= turret < .05 ? .01 : 0.;   \n\t\tship            \t= position.y > 0. ? min(ship, turret) : ship;\n\t\t\n\t\t\n\t\t//mid decks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > 2.25 \n\t\t\t\t\t&& deck_position.z + deck_position.x *.4    < 4. \n\t\t\t\t\t&& deck_position.x + deck_position.z * .1   > .26    \n\t\t\t\t\t&& deck_position.x < .5 \n\t\t\t\t\t? -.05 : 0.;\n\t\t\n\t\t\n\t\t//upper decks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .125 > 2.9\n\t\t\t\t\t&& deck_position.z + deck_position.x *.4    < 3.9 \n\t\t\t\t\t&& deck_position.x              \t    < .3 \n\t\t\t\t\t? -.02 : 0.;\n\t\t\n\t\t//midship deck\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .3   > .75\n\t\t\t\t\t&& deck_position.z + deck_position.x        < 2.19\n\t\t\t\t\t&& deck_position.x < .6 \n\t\t\t\t\t&& deck_position.x > -.25\n\t\t\t\t\t? -.01 : 0.;\n\t\t\n\t\t//midship hatches\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .3   > .85\n\t\t\t\t\t&& deck_position.z + deck_position.x        < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .25\n\t\t\t\t\t? -.01 : 0.;\n\t\n\t\n\t\t//bulwarks\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > .092\n\t\t\t\t\t&& deck_position.x - deck_position.z *.283  < .5\n\t\t\t\t\t&& deck_position.z  < 4.\n\t\t\t\t\t&& deck_position.x-deck_position.z*.25  > -.25\n\t\t\t\t\t&& indents\n\t\t\t\t\t? -.005 * hull_position.x : 0.;\n\t\t\n\t\t\n\t\t//sensor deck\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .5   > -.48  \n\t\t\t\t\t&& deck_position.z + deck_position.x        < .34   \n\t\t\t\t\t&& deck_position.x              < .28\n\t\t\t\t\t? -.014  : 0.;\n\t\t\n\t\t\n\t\t//forecastle\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * 5.5   > -1.45  \n\t\t\t\t\t&& deck_position.z + deck_position.x * 2.    < -.54   \n\t\t\t\t\t? -.01  : 0.;\n\t\n\t\t//upper deck superstructure\n\t\tvec3 deck_upper_position= hull_position;\n\t\tdeck_upper_position.y   = hull_position.y- .15 - deck_position.y*.05;\n\t\tdeck_upper_position.z   += -3.16;\n\t\t\n\t\tvec3 deck_upper_scale   = vec3(1.);\n\t\tdeck_upper_scale.x      = hull_scale.x-deck_position.x-.8;\n\t\tdeck_upper_scale.x      += deck_position.z < 2.7 ? deck_upper_position.z : 0.;\n\t\tdeck_upper_scale.x      += deck_position.z > 3.9 ? -deck_upper_position.z*2.7+2. : 0.;\n\t\tdeck_upper_scale.x      += deck_partitions*.025;\n\t\tdeck_upper_scale.y      = hull_scale.y;\n\t\tdeck_upper_scale.z      = .55 - forward_partitions*.015;\n\t\tdeck_upper_scale.z      += deck_position.z > 3. ? .4 : 0.;\n\t\t\n\t\tbool upper_deck_bounds  = deck_position.z - deck_position.x * .3   > .5\n\t\t\t\t\t&& deck_position.z + deck_position.x            < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .15;\n\t\t\n\t\tdeck_upper_scale.x  \t*= !upper_deck_bounds ? 1. : 2.4;\n\t\t\n\t\tfloat deck_upper    \t= cube(deck_upper_position, deck_upper_scale);\n\t\t\n\t\t\n\t\t//mid deck superstructure\n\t\tvec3 deck_mid_position  = hull_position;\n\t\tdeck_mid_position.y     = hull_position.y - .1;\n\t\tdeck_mid_position.z     -= 3.16;\n\t\t\n\t\n\t\t\n\t\tvec3 deck_mid_scale     = vec3(1.);\n\t\tdeck_mid_scale.x        = hull_scale.x-deck_position.x;\n\t\tdeck_mid_scale.x        += deck_position.z < 2.7 ? deck_mid_position.z : 0.;\n\t\tdeck_mid_scale.x        += deck_position.z > 3.9 ? -deck_mid_position.z*2.7+2. : 0.;\n\t\tdeck_mid_scale.x        += deck_partitions*.025;        \n\t\tdeck_mid_scale.y        = hull_scale.y;        \n\t\tdeck_mid_scale.z        = .93 - forward_partitions*.015;\n\t\t\n\t\tbool mid_deck_bounds    = deck_position.z - deck_position.x * .3   > .5\n\t\t\t\t\t&& deck_position.z + deck_position.x            < 1.9\n\t\t\t\t\t&& deck_position.x < .55 \n\t\t\t\t\t&& deck_position.x > .15;\n\t\t\n\t\tdeck_mid_scale.x\t*= !mid_deck_bounds ? 1. : 2.4;\n\t\n\t\tfloat deck_mid          = cube(deck_mid_position, deck_mid_scale);\n\t\n\t\tship                    = min(ship, deck_upper);\n\t\tship                    = min(ship, deck_mid);\n\t}\n\telse\n\t{\n\t\n\t\t//solar collector berth\n\t\tdeck_position.y \t*= deck_position.z - deck_position.x    > 1.9\n\t\t\t\t\t&& deck_position.z + deck_position.x    < 3.65\n\t\t\t\t\t&& deck_position.x                      < deck_position.z * .23 \n\t\t\t\t\t? .9 : 1.;\n\t\t\n\t\tdeck_position.y \t+= length(collector_position)-.55 < 0. ? .05 : 0.;\n\t\t\t\n\t\tvec2 absxz      \t= abs(position.xz*8.);\n\t\tbool indents    \t= fract(absxz.y*.35+.5)>.1;\n\t\tbool columns    \t= mod(absxz.y-.25-position.y, 1.) > .5 && abs(position.x) > .10;\n\t\tbool spars      \t= mod(absxz.x+absxz.y, 1.25) > .025 ^^ mod(absxz.x-absxz.y, 1.25) > .025;\n\t\t\n\t\t\n\t\t//fighter bays\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x        > .92\n\t\t\t\t\t&& deck_position.x - deck_position.z *.25   < .3\n\t\t\t\t\t&& deck_position.x -deck_position.z*.25     > .15\n\t\t\t\t\t&& deck_position.z                          < 4.\n\t\t\t\t\t&& indents && !spars\n\t\t\t\t\t? .01 * hull_position.x : 0.;\n\t\t\n\t\t\n\t\t//forward bay\n\t\tdeck_position.y \t+= deck_position.z - deck_position.x * .5   > -.7   \n\t\t\t\t\t&& deck_position.x          < .2     \n\t\t\t\t\t&& deck_position.z          < -.3    \n\t\t\t\t\t? -.0125 - hull_plating * .0025 : 0.;      \n\t\t\n\t\t//main docking bay border\n\t\tdeck_position.y \t+= deck_position.z  > .25\n\t\t\t\t\t&& deck_position.z  < 1.25\n\t\t\t\t\t&& deck_position.x  < .45\n\t\t\t\t\t? -.01 : 0.;\n\t\t\n\t\t//main docking bay\n\t\tbool bay_area \t\t= deck_position.z   > .2\n\t\t\t\t\t&& deck_position.z  < 1.2\n\t\t\t\t\t&& deck_position.x  < .4;\n\t\t\n\t\t\n\t\tdeck_position.y \t+= bay_area ? -hull_position.x*0.25+.1 : 0.;\n\n\t\tdeck_position.y \t+= bay_area\n\t\t\t\t\t&& columns\n\t\t\t\t\t? -.01 : .0;\n\t\t\n\t\tdeck_position.y \t+= bay_area\n\t\t\t\t\t&& spars\n\t\t\t\t\t&& !columns\n\t\t\t\t\t? -0.004 : 0.;\n\t\t\t\n\t\t\t\t\t//main docking bay border\n\t\tdeck_position.y \t+= deck_position.z  > .75\n\t\t\t\t\t&& deck_position.z  < 1.95\n\t\t\t\t\t&& deck_position.x  < .45\n\t\t\t\t\t&& !spars\n\t\t\t\t\t? -abs(position.x)*.001 : 0.;   \n\t}\n\tdeck_position   \t\t+= -.005;\n\tship                    \t= min(ship, hull_inner);\n\t\n\tbool upper_decks        \t= hull_position.y != deck_position.y \n\t\t\t\t\t|| hull_position.x != deck_position.x \n\t\t\t\t\t|| hull_position.z != deck_position.z; \n\t\n\t\t\n\tvec3 deck_scale         \t= hull_scale;\n\t\n\tdeck_scale              \t*= position.y > 0. && position.z < 4. && upper_decks ? 1.01 : 1.;\n\tfloat decks             \t= cube(deck_position, deck_scale);\n\t\t\n\tship                    \t= position.y < -.075 && position.z < 4. ? max(hull_inner,decks) : ship;\n\tship                    \t= min(decks, ship);\n\tship                    \t= min(collector, ship);\n\t\n\t\n\t//border around the edge of the main hull\n\tvec3 border_mask_position   \t= abs(hull_scale);\n\tborder_mask_position.x      \t*= -abs(hull_position.x*1.5)+hull_position.z*.5+1.25;\n\tborder_mask_position.y      \t*= 1.1;\n\tborder_mask_position.z      \t+= position.z-hull_position.x*.1 < 4.5 ? .05 : 0.;\n\t\t\n\tfloat hull_border_mask      \t= cube(hull_position, border_mask_position);\n\t\n\tfloat hull_border           \t= abs(fract((hull_position.x*2.+hull_position.z*8.)*4.)-.5)*2.;\n\thull_border                 \t= min(hull_border, .1)*.005-.0035;\n\t\t\n\tbool border                 \t= hull_border_mask > hull_outer && !inner_hull && !upper_decks;\n\t\n\t\n\t\n\thull_border                 \t+= outboard_partitions * .00015;\n\toutboard_partitions         \t+= max(outboard_partitions, .85)*4.;    \n\t\t\n\tvec2 xz_floor_noise                \t= hash(floor(hull_position.xz*8.+deck_scale.y*4.+abs(8.-hull_position.zx*1.5)*vec2(32., 23.)));\n\txz_floor_noise                 \t= max(floor(xz_floor_noise*32.)-25., .0)*.025*(.25-position.x)*xz_floor_noise;\n\n\n\t//outboard hangar bays\n\tvec3 bay_positions         \t= position;\n\tbay_positions.z            \t+= -3.15;\n\tbay_positions.z            \t= mod(bay_positions.z+mod(bay_positions.z, 3. + bay_positions.z * .5), 3.4)-.5525;\n\tbay_positions.y           \t+= z_floor_noise * .025 + xz_floor_noise.y * .005 - .01;\n\t\n\tvec3 bay_scale             \t= vec3(1.);\n\tbay_scale.x             \t= 4.;\n\tbay_scale.y             \t= .0175 - (xz_floor_noise.x - xz_floor_noise.y) * hull_scale.x * .035 + z_floor_noise*position.x*.0025;\n\tbay_scale.y             \t+= position.z < 0.1 ? xz_floor_noise.x * .4 -.01 : 0.;\n\tbay_scale.y             \t+= abs(position.x) < .05 ? -.04 : 0.;\n\tbay_scale.z             \t= position.z*.095+.1+abs(position.x)*.1;\n\t\n\tfloat hangar_bays           \t= cube(bay_positions, bay_scale);\n\n\t\n\t\n\t//composite details\n\tbool wake_line          \t= abs(position.y)<.055;\n\t\n\thull_panels             \t*= border || bridge_tower ? .5 : 1.;\n\thull_panels             \t*= upper_decks ? .75 : 1.;\n\t\n\n\tfloat hull_inner_detail     \t= wake_line\n\t\t\t\t\t&& hangar_bays > 0.\n\t\t\t\t\t&& outboard_partitions<3.95\n\t\t\t\t\t? .01 : outboard_partitions *.001;\n\n\tfloat hull_detail_floor\t\t= floor(8.*cross(position.z+cross(position.z*5.)+cross(position.y*3.))/3.);\n\thull_inner_detail       \t+= wake_line && hangar_bays > 0.\n\t\t\t\t\t&& outboard_partitions<3.95\n\t\t\t\t\t&& position.z > -1.4\n\t\t\t\t\t? -min(hull_detail_floor,.75)*.02 : 0.;\n\t\n\t//detailing\n\tship               \t\t+= wake_line ? (z_floor_noise < .1 ? -.0075 : 0.) : 0.;                  \n\tship               \t\t= max(ship, -hangar_bays);\n\tship               \t\t= border ? ship + hull_border : ship+ hull_border ;\n\tship               \t\t= bridge_tower || upper_decks ? ship + outboard_partitions *.0001 : ship;\n\tship               \t\t= (bridge_tower || outer_hull) && !border ? ship + hull_panels * .0025 : ship;  \n\tship               \t\t= !aft && !bridge_tower && inner_hull ? ship + hull_inner_detail: ship; \n\t\n\n\t//return distance and materials\n\tvec2 material_range         \t= vec2(0.);\n\tfloat l                     \t= length(position-LIGHTPOSITION);   \n\tg_light                     \t= l > g_light ? l : g_light;    \n\tmaterial_range.y            \t= ship;\n\t\n\t/*\n\tmaterial_range.y        =  ship;\n\n\t\t//assign materials\n\tmaterial_range.x        = 5.;\n\t\tmaterial_range.x        = border        ? 0. : material_range.x;\n\t\tmaterial_range.x        = aft           ? 1. : material_range.x;\n\t\tmaterial_range.x        = upper_decks       ? 2. : material_range.x;\n\t\tmaterial_range.x        = bridge_tower      ? 4. : material_range.x;\n\tmaterial_range.x        = 5.;\n\t//material_range.x  = inner_hull        ? 99. : material_range.x;\n\t*/\n\tmaterial_range.x        \t= 5.;\n\treturn material_range;\n}\n//// SCENES\n\n////MATERIALS\nmaterial assign_material(in float material_index, in vec3 position)\n{\n\tmaterial m;\n\tif(true)//material_index == 0.)\n\t{\n\t\tm.color             = vec3(1.,.5,.5);\n\t\tm.refractive_index  = .125;\n\t\tm.roughness         = .01;\n\t\tm.transparency      = 0.;\n\t}\n\treturn m;\n}\n////\n\nvoid main( void ) \n{\n\tvec2 uv         = UV;\n\tray r           = view(uv);\n\n\tr               = emit(r);\n\n\tvec4 result     = vec4(0.);\n\n\tfloat distanceFog   = clamp(r.material_range.y/FARPLANE, 0., 1.);\n\tfloat stepFog       = clamp(r.steps/float(ITERATIONS), 0., 1.);\n\tstepFog         = r.steps < 1. ? 1. : stepFog;\n\t\n\t/*\n\tvec4 c[7];\n\tshcday(c);\n\n\n\tlight l         = light(vec3(0.), vec3(0.), vec3(0.), vec3(0.));\n\tl.color         = LIGHTCOLOR;   \n\tl.position      = LIGHTPOSITION;\n\tl.direction     = normalize(l.position - r.position);\n\n\tvec3 fog        = sphericalharmonic(normalize(r.position), c);\n\tfog     = (fog * fog + .5 * .5) * .125;\n\n\tvec3 lf         = flare(r, l, g_light);\n\tif(r.material_range.y != FARPLANE && fract(r.material_range.x) != 0.)\n\t{               \n\t\tsurface s   = surface(vec4(0.), vec3(0.), 0.);\n\t\ts.color     = result;\n\t\ts.range     = distance(r.position, r.origin);\n\t\ts.normal    = derive(r.position);\n\n\t\tmaterial m  = assign_material(floor(r.material_range.x), g_position);\n\t\t\n\t\tl.direction = normalize(l.position-r.position);\n\t\tl.ambient   = sphericalharmonic(s.normal, c);\n\t\ts       = shade(r, s, m, l);\n\t\tresult      = s.color;\n\t\t\n\t\t\tresult.xyz  += fog * .5;\n\t\t\tresult      *= s.color;\n\t\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresult.xyz *=0.;//= 0.vec3(.5, .55, .65)*uv.y;// fog;\n\t\tresult.xyz -= stepFog*.25;\n\t\t}\n\t\t\n\t\tresult.xyz += lf+stepFog*.5;\n\n\t\tresult.xyz = pow(result.xyz * .75,vec3(1.15));\n\t  \n\t\tresult.w = 1.;\n\n\t\t*/\n\t\t\n\n\t\t#define DEBUG\n\t\t#ifdef DEBUG\n\t\tresult          = pow(stepFog, .5) * vec4(1., 1.5, 1.,1.);\n\t\tresult.r        += r.steps > float(ITERATIONS - ITERATIONS/4) ? 1. : 0.;\n\t\tresult      = pow(result,vec4(2.));\n\t\tresult      -= r.material_range.y*.012;\n\t\tresult.w    = 1.;\n\t\t#endif\n\n\t\tgl_FragColor = result;\n}// sphinx\n\n//// TRACE\n//emit rays to map the scene, stepping along the direction of the ray by the  of the nearest object until it hits or goes to far\nray emit(ray r)\n{\n\tfloat total_range       = r.material_range.y;\n\tfloat threshold     = PHI;\n\t\n\tfor(int i = 1; i < ITERATIONS; i++)\n\t{\n\t\tif(total_range < FARPLANE)\n\t\t{\n\t\t\tif(r.material_range.y < threshold && r.material_range.y > 0.)\n\t\t\t{\n\t\t\t\tr.material_range.x += r.material_range.y;\n\t\t\t\tr.material_range.y = total_range;\n\t\t\t\tr.steps            = float(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tthreshold          *= 1.04;\n\t\t\tr.position         += r.direction * r.material_range.y * .8;\n\t\t\tr.material_range   = map(r.position);\n\t\t\t\n\t\t\tif(r.material_range.y < 0.)\n\t\t\t{\n\t\t\t\tr.material_range.y -= threshold;\n\t\t\t\tthreshold *= float(i);\n\t\t\t}\n\t\t\ttotal_range        += r.material_range.y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tr.material_range.y = 1.+length(r.origin + r.direction * FARPLANE);\n\t\t\tr.material_range.x = 0.;\n\t\t\tr.steps            = float(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn r;\n}\n\nvec2 format_to_screen(vec2 uv)\n{\n\tuv = uv * 2. - 1.;\n\tuv.x *= ASPECT;\n\treturn uv;\n}\n\n\n//transform the pixel positions into rays \nray view(in vec2 uv)\n{ \n\tuv = format_to_screen(uv);\n\n\tvec3 w          = normalize(VIEWTARGET-VIEWPOSITION);\n\tvec3 u          = normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v          = normalize(cross(u,w));\n\n\tray r           = ray(vec3(0.), vec3(0.), vec3(0.), vec2(0.), 0.);\n\tr.origin        = VIEWPOSITION;\n\tr.position      = VIEWPOSITION;\n\tr.direction     = normalize(uv.x*u + uv.y*v + FOV*w);;\n\tr.material_range    = vec2(0.);\n\tr.steps             = 0.;\n\n\treturn r;\n}   \n\n\n//find the normal by comparing offset samples on each axis as a partial derivative\nvec3 derive(in vec3 p)\n{\n\tvec2 offset     = vec2(0., EPSILON);\n\n\tvec3 normal     = vec3(0.);\n\tnormal.x    = map(p+offset.yxx).y-map(p-offset.yxx).y;\n\tnormal.y    = map(p+offset.xyx).y-map(p-offset.xyx).y;\n\tnormal.z    = map(p+offset.xxy).y-map(p-offset.xxy).y;\n\n\treturn normalize(normal);\n}\n//// END TRACE\n\n\n\n//// SHADING\nsurface shade(in ray r, in surface s,  in material m, in light l)\n{\n\t//http://simonstechblog.blogspot.com/2011/12/microfacet-brdf.html\n\n\t//view and light vectors\n\tvec3 view_direction\t= normalize(r.origin-r.position);           //direction into the view\n\tvec3 half_direction\t= normalize(l.position-r.position);         //direction halfway between view and light\n\n\t//exposure coefficients\n\tfloat light_exposure\t= dot(s.normal, l.direction);               //ndl\n\tfloat view_exposure\t= dot(s.normal, view_direction);            //ndv\n\n\tfloat half_view\t\t= dot(half_direction, view_direction);      //hdn\n\tfloat half_normal\t= dot(half_direction, s.normal);            //hdv\n\tfloat half_light\t= dot(half_direction, l.direction);         //hdl\n\n\t//microfacet lighting components\n\tfloat d\t\t\t= distribution(m.roughness, min(light_exposure, half_normal));\n\tfloat g\t\t\t= geometry(m.roughness, light_exposure, view_exposure, half_normal, half_view, half_light);\n\tfloat f\t\t\t= fresnel(m.refractive_index, light_exposure);\n\tfloat n\t\t\t= clamp(1. - fresnel(f, light_exposure), 0., 1.);\n\n\t//bidrectional reflective distribution function\n\tfloat brdf\t\t= (g*d*f)/(view_exposure*light_exposure*4.);\n\n\t//shadow and occlusion projections\n\tfloat shadows\t\t= shadow(r.position, l.direction, distance(l.position, r.position));\n\tvec2 occlusion          \t= ambient_occlusion(r.position, s.normal);\n\t\n\t// compositing\n\ts.color.xyz\t\t= light_exposure * m.color * n + brdf * l.color + m.color * m.transparency;\n\ts.color.xyz\t\t*= shadows * max(occlusion.x, .5);\n\ts.color.xyz\t\t+= (m.refractive_index * (1.-light_exposure) * occlusion.y) * m.transparency * m.color  * l.color * f;\n\ts.color.xyz\t\t+= l.ambient * m.roughness * m.color * l.color;\n\ts.color.w\t\t= (1.-view_exposure)*f;\n\treturn s;   \n}\n\nfloat fresnel(in float i, in float hdl)\n{   \n\thdl = 1.-max(hdl, 0.);\n\tfloat h = hdl * hdl;\n\treturn i + (1.-i) * (h * h * hdl);\n}\n\nfloat geometry(in float i, in float ndl, in float ndv, in float hdn, in float hdv, in float hdl)\n{\n\t//#define WALTER\n\t#ifdef WALTER\n\tfloat a         = 1./(i*tan(acos(max(ndv, 0.))));\n\tfloat a2        = a * a;\n\tfloat ak        = a > 1.6 ? (3.535 * a + 2.181 * a2)/(1. + 2.276 * a + 2.577 * a2) : 1.;\n\treturn (step(0.0, hdl/ndl) * ak)*( step(0., hdv/ndv) * ak);\n\t#endif\n\n\t//    #define COOKTORRENCE\n\t#ifdef COOKTORRENCE\n\treturn min(min(2. * hdn * max(ndv, 0.) / hdv, 2. * hdn * max(ndl, 0.) / hdv), 1.);\n\t#endif\n\t\n\t#define SCHLICK\n\t#ifdef SCHLICK\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(2./PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n\t#endif\n}\n\nfloat distribution(in float r, in float ndh)\n{  \n\t//#define BLINNPHONG\n\t#ifdef BLINNPHONG\n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(ndh, m)*.5;\n\t#endif\n\n\t#define BECKMAN\n\t#ifdef BECKMAN\n\tfloat r2    = r * r;\n\tfloat ndh2  = max(ndh, 0.0);\n\tndh2        = ndh2 * ndh2;\n\treturn exp((ndh2 - 1.)/(r2*ndh2)) / (PI * r2 * ndh2 * ndh2) * 2.;\n\t#endif\n}\n\nvec2 ambient_occlusion(vec3 p, vec3 n)\n{\n\tvec2 a      = vec2(1., -.5);\n\tconst float s   = OCCLUSION_SCALE;\n\n\tfloat d     = 1.-s/float(OCCLUSION_ITERATIONS);\n\t\n\tfor(int i = 0; i < OCCLUSION_ITERATIONS; i++ )\n\t{\n\t\tfloat h  = s + s * float(i);\n\t\tvec3  op = n * h + p;\n\t\tvec3  sp = n * -h + p;\n\t\ta.x      += (map(op).y-h) * d;\n\t\ta.y      -= (map(op).y-h) * d;\n\t\td        *= d;\n\t}\n\treturn clamp(a, 0., 1.);\n}\n\nfloat shadow(vec3 p, vec3 d, float e)\n{\n\t//http://glslsandbox.com/e#20224.0 < adapted from here\n\tfloat s = 1.;\n\tfloat t = EPSILON;\n\tfloat k = SHADOW_PENUMBRA;\n\tfloat h = 0.;\n\n\te *= t;\n\te += EPSILON;\n\tfor(int i = 0; i < SHADOW_ITERATIONS; i++)\n\t{\n\t\tif(t < k)\n\t\t{\n\t\t\tif(h < 0.){s = 0.; break;}\n\t\t\th = map(p + d * t).y;\n\t\t\th = h < k ? h - EPSILON : h ;\n\t\t\ts = max(min(s, k * h / t), e);\n\t\t\tt += h + h;\n\t\t}\n\t}\n\treturn max(0., s);\n}\n\nvec3 flare(in ray r, in light l, in float e)\n{\n\t//http://glslsandbox.com/e#16045.0 - @P_Malin \n\tfloat f \t= dot(l.position - r.origin, r.direction);\n\tf \t\t= clamp(f, 0.0, e*2.);\n\tvec3 p \t\t= r.origin + r.direction * f;\n\tf \t\t= length(p - l.position);\n\treturn  clamp(l.color * 0.001 / (f * f), 0., 1.);\n}\n\n\nvec3 sphericalharmonic(vec3 n, in vec4 c[7])\n{     \n\tvec4 p \t= vec4(n, 1.);\n\n\tvec3 l1 \t= vec3(0.);\n\tl1.r \t\t= dot(c[0], p);\n\tl1.g \t\t= dot(c[1], p);\n\tl1.b \t\t= dot(c[2], p);\n\t\n\tvec4 m2 \t= p.xyzz * p.yzzx;\n\tvec3 l2 \t= vec3(0.);\n\tl2.r \t\t= dot(c[3], m2);\n\tl2.g \t\t= dot(c[4], m2);\n\tl2.b \t\t= dot(c[5], m2);\n\n\tfloat m3\t= p.x*p.x - p.y*p.y;\n\tvec3 l3\t\t= vec3(0.);\n\tl3 \t\t= c[6].xyz * m3;\n\n\tvec3 sh \t= vec3(l1 + l2 + l3);\n\n\treturn clamp(sh, 0., 1.);\n}\n\nvoid shcday(out vec4 c[7])\n{\n\tc[0] = vec4(0.0, 0.5, 0.0, 0.4);\n\tc[1] = vec4(0.0, 0.3, .05, .45);\n\tc[2] = vec4(0.0, 0.3, -.3, .85);\n\tc[3] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[4] = vec4(0.0, 0.2, 0.1, 0.0);\n\tc[5] = vec4(0.1, 0.1, 0.1, 0.0);\n\tc[6] = vec4(0.0, 0.0, 0.0, 0.0);   \n}\n\nvec3 hsv(in float h, in float s, in float v){\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n//// END SHADING\n\n\n//// DISTANCE FIELD FUNCTIONS\nfloat sphere(vec3 position, float radius)\n{\n\treturn length(position)-radius; \n}\n\nfloat cube(vec3 p, vec3 s)\n{\n\tvec3 d = (abs(p) - s);\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n\tvec2 q = vec2(length(p.xz)-t.x, p.y);\n\treturn length(q)-t.y;\n}\n\nfloat cylinder(vec3 p, float l, float r)\n{\n\treturn max(abs(p.y-l)-l, length(p.xz)-r);\n}\n\nfloat cone(vec3 p, float l, vec2 r)\n{\n\tfloat m = 1.-(p.y*.5)/l;\n\treturn max(length(p.xz)-mix(r.y, r.x, m), abs(p.y-l)-l);\n}\n\nfloat icosahedral(vec3 p, float e, float r)\n{\n\tvec2 n = vec2(.577, -.577);\n\tfloat a = .357;\n\tfloat b = .934;\n\tfloat s = pow(abs(dot(p,n.yyy)),e);\n\ts += pow(abs(dot(p,n.yxx)),e);\n\ts += pow(abs(dot(p,n.xyx)),e);\n\ts += pow(abs(dot(p,n.xxy)),e);\n\ts += pow(abs(dot(p,vec3( 0.,a,b))),e);\n\ts += pow(abs(dot(p,vec3(0.,-a,b))),e);\n\ts += pow(abs(dot(p,vec3( b,0.,a))),e);\n\ts += pow(abs(dot(p,vec3(-b,0.,a))),e);\n\ts += pow(abs(dot(p,vec3( a,b,0.))),e);\n\ts += pow(abs(dot(p,vec3(-a,b,0.))),e);\n\ts = pow(s, 1./e);\n\treturn s-r;\n}\n//// END DISTANCE FIELD FUNCTIONS\n\n\n//// NOISE\n//via http://glsl.herokuapp.com/e#4841.11\nfloat partition_noise(vec2 p) \n{\n\tvec2 id;\n\t\n\tid = floor(floor(p)-.5);\n\t\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\t\n\tp.yx *= floor(hash(id) * 3.)-4.;\n\tid -= floor(p);\n\n\tp *= floor(hash(id) * 2.)+1.;\n\tid = floor(p);\n\n\tp -= id;\n\n\tvec2 u = abs(p - .5) * 2.;\n\n\treturn max(u.x, u.y);\n}\n//// END NOISE\n\n//// CURVES\nfloat hash(float v)\n{\n\treturn fract(fract(v*1234.5678)*(v+v)*12345.678);\n}\n\nvec2 hash(vec2 v) \n{\n\tvec2 n;\n\tn.x=fract(cos(v.y-v.x*841.0508)*(v.y+v.x)*3456.7821);\n\tn.y=fract(sin(v.x+v.y*804.2048)*(v.x-v.y)*5349.2627);\n\treturn n;\n}\n\nfloat smoothmin(float a, float b, float x)\n{\n\treturn -(log(exp(x*-a)+exp(x*-b))/x);\n}\nfloat cross(float x)\n{\n\treturn abs(fract(x-.5)-.5)*2.;  \n}\n\nfloat convolute(float x)\n{\n\tx = 4. * (x * (1.-x));\n\treturn x*x;\n}\n\nvec3 convolute(vec3 x)\n{\n\tx = 4. * (x * (1.-x));\n\treturn x*x;\n}\n//// END CURVES\n\n//// ROTATION MATRICES\nmat2 rmat(in float r)\n{\n\tfloat c = cos(r);\n\tfloat s = sin(r);\n\treturn mat2(c, s, -s, c);\n}\n//// END ROTATION MATRICES\n", "user": "e6bdb4", "parent": null, "id": "24863.3"}