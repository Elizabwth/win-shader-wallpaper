{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Written by David Hoskins.\n// Copying the Shadertoy error message.\n\n// First posted on *** https://www.shadertoy.com/view/ldsGR7 ***\n\n// 96 x 12 bitmap embedded into 16 bit hexadecimal numbers.\n\nfloat corrupt = 16.0;\nfloat rand( float n )\n{\n    return fract(sin(n)*23758.5453);\n}\n\n\nfloat GetBinary(vec2 coord)\n{\n\tint x = int(coord.x);\n\tint y = int(coord.y);\n\tint col[6];\n\tif (x < 1 || x > 95) return 0.0;\n\tif (y < 1 || y > 12) return 0.0;\n\ty = 12-y;// Upside down! Oh well. :)\n\tif (y == 0)\n\t{\n\t\tcol[0] = 0x60f8;\n\t\tcol[1] = 0x0;\n\t\tcol[2] = 0x60;\n\t\tcol[3] = 0xf800;\n\t\tcol[4] = 0xf;\n\t\tcol[5] = 0x0;\n\t}\n\telse\n\tif (y == 1)\n\t{\n\t\tcol[0] = 0x61fc;\n\t\tcol[1] = 0x0;\n\t\tcol[2] = 0x60;\n\t\tcol[3] = 0xf800;\n\t\tcol[4] = 0xf;\n\t\tcol[5] = 0x0;\n\t}\n\telse\n\tif (y == 2)\n\t{\n\t\tcol[0] = 0x638e;\n\t\tcol[1] = 0x0;\n\t\tcol[2] = 0x60;\n\t\tcol[3] = 0x1800;\n\t\tcol[4] = 0x00;\n\t\tcol[5] = 0x00;\n\t}\n\telse\n\tif (y == 3)\n\t{\n\t\tcol[0] = 0x6306;\n\t\tcol[1] = 0xf87;\n\t\tcol[2] = 0x3e6e;\n\t\tcol[3] = 0x1836;\n\t\tcol[4] = 0xdb60;\n\t\tcol[5] = 0xd87c;\n\t}\n\telse\n\tif (y == 4)\n\t{\n\t\tcol[0] = 0xf01e;\n\t\tcol[1] = 0x9fcf;\n\t\tcol[2] = 0x7f3f;\n\t\tcol[3] = 0x1c3e;\n\t\tcol[4] = 0xfbe0;\n\t\tcol[5] = 0xf8fe;\n\t}\n\telse\n\tif (y == 5)\n\t{\n\t\tcol[0] = 0x707c;\n\t\tcol[1] = 0x98cc;\n\t\tcol[2] = 0x6339;\n\t\tcol[3] = 0xfc0e;\n\t\tcol[4] = 0x38e7;\n\t\tcol[5] = 0x39c6;\n\t}\n\telse\n\tif (y == 6)\n\t{\n\t\tcol[0] = 0x30f0;\n\t\tcol[1] = 0xdc0e;\n\t\tcol[2] = 0x63b0;\n\t\tcol[3] = 0xfc06;\n\t\tcol[4] = 0x1867;\n\t\tcol[5] = 0x1987;\n\t}\n\telse\n\tif (y == 7)\n\t{\n\t\tcol[0] = 0x31c0;\n\t\tcol[1] = 0xdfc6;\n\t\tcol[2] = 0x7fb0;\n\t\tcol[3] = 0xc07;\n\t\tcol[4] = 0x1c70;\n\t\tcol[5] = 0x1d83;\n\t}\n\telse\n\tif (y == 8)\n\t{\n\t\tcol[0] = 0x3983;\n\t\tcol[1] = 0xcce6;\n\t\tcol[2] = 0x1b8;\n\t\tcol[3] = 0xc03;\n\t\tcol[4] = 0xc30;\n\t\tcol[5] = 0xcc3;\n\t}\n\telse\n\tif (y == 9)\n\t{\n\t\tcol[0] = 0x19c7;\n\t\tcol[1] = 0xcc66;\n\t\tcol[2] = 0x3399;\n\t\tcol[3] = 0xe03;\n\t\tcol[4] = 0xc30;\n\t\tcol[5] = 0xce7;\n\t}\n\telse\n\tif (y == 10)\n\t{\n\t\tcol[0] = 0x18fe;\n\t\tcol[1] = 0xcfe7;\n\t\tcol[2] = 0x3f1f;\n\t\tcol[3] = 0xfe03;\n\t\tcol[4] = 0xc33;\n\t\tcol[5] = 0xc7e;\n\t}\n\telse\n\tif (y == 11)\n\t{\n\t\tcol[0] = 0x187c;\n\t\tcol[1] = 0x8dc3;\n\t\tcol[2] = 0x1e1b;\n\t\tcol[3] = 0xfe03;\n\t\tcol[4] = 0xc33;\n\t\tcol[5] = 0xc3c;\n\t}\n\t\n\tint binary = 0;\n\tx = x/16;\n\t// I can't use an indices in arrays!...\n\tif (x == 0)\tbinary = col[0];\n\telse\n\tif (x == 1)\tbinary = col[1];\n\telse\n\tif (x == 2)\tbinary = col[2];\n\telse\n\tif (x == 3)\tbinary = col[3];\n\telse\n\tif (x == 4)\tbinary = col[4];\n\telse  binary = col[5];\n\t// Get the correct bit from the 16 bit integer...\n\treturn mod(floor(float(binary) / pow(2.0, floor(mod(coord.x, corrupt)))), 2.0);\n}\n\nvoid main(void)\n{\n\tfloat time2 = time+1.5;\n\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec2 xy = uv * vec2(212.0, 160.0);\n\t\n\t// Adjust to centre...\n\txy.x += -56.0;\n\n\tfloat blur = .5;\n\tfloat tick, t;\n\n \t// Spread blur...\t\n\ttick = mod(time2, 3.0);\n\tt = step(2.0, tick);\n\tt -= step(2.1, tick);\n\tblur += t*2.0;\n\n\t// Bend it...\n\ttick = mod(time2, 4.0);\n\tt = smoothstep(3.0, 3.1, tick);\n\tt -= smoothstep(3.25, 3.3, tick);\n\tt = t*.02;\n\tt = t * (xy.x*3.0-xy.y*2.0-time2*30.0);\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 mat = mat2(co, si, -si,co);\n\txy = mat * xy;\n\t\n\t// Vertical judder...\n\ttick = mod(time2, 5.0);\n\tt = smoothstep(4.0, 4.3, tick);\n\tt -= smoothstep(4.3, 4.5, tick);\n\tt = t*4.0 + sin (t * 64.0);\n\txy.x -= t*.25;\n\txy.y += t;\n\t\n\t// Roll...\n\ttick = mod(time2, 7.0);\n\tt = smoothstep(5.0, 6.5, tick);\n\tt -= smoothstep(6.5, 7.0, tick);\n\tt = smoothstep(-.15, .15, sin (t * time2)) * t*5.0;\n\txy.y *= 1.0+t;\n\t\n\t// Corrupt...\n\ttick = mod(time2, 9.0);\n\tt = smoothstep(7.5, 8.0, tick);\n\tt -= smoothstep(8.0, 8.3, tick);\n\tcorrupt = 16.0 - t*4.0 + sin (t * 20.0)*t;\n\n\t\n\txy.y += -67.0;\t\n\t// Find intensity...\n\t\n\tfloat intensity = GetBinary(xy) * .35\n\t\t\t\t\t+ GetBinary(xy+vec2(blur, blur))*.25\n\t\t \t\t\t+ GetBinary(xy+vec2(-blur, blur))*.25\n\t\t \t\t\t+ GetBinary(xy+vec2(-blur, -blur))*.25\n\t\t \t\t\t+ GetBinary(xy+vec2(blur, -blur))*.25;\n\t// Noise...\n\ttick = mod(time2, 20.0);\n\tt = smoothstep(11.0, 13.0, tick);\n\tt -= smoothstep(16.0, 19.0, tick);\n\tt = t *.55+ t*sin(time2*43.0) * .06;\n\tvec3 noise = vec3(t, t, t);\n\tnoise += rand(floor(xy.y*20.0)+floor(time2*9.0))*t*.2;\n\tnoise += rand(floor(xy.y*2.0+xy.x)+time2)*t*.1;\n\t// Vertical hold out of sync bar...\n\tnoise *= noise + (1.0-pow(abs(mod(time2, 2.0)-1.0-uv.y), .27)) * .65;\n\t// Vignetting...\n\tnoise *= pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.3 );\n\t// Tint...\n\tvec3 rgb = noise * vec3(1.0, .9, .8);\n\n\trgb.r = mix(rgb.r, 1.0, min(1.0, intensity));\n\tgl_FragColor = vec4(rgb, 1.0);\n}\n", "user": "70cd41", "parent": null, "id": "8292.2"}