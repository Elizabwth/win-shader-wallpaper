{"code": "/**\n * Whoever you are, you better be at Revision 2017 for Shader Showdown :)\n * LJ\n */\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat smin(in float a, in float b, float k) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    \treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tri(in float x) {\n\treturn abs(fract(x)-.5);\n}\n\nfloat square(in float x) {\n\treturn fract(x) > 0.5 ? 1.0 : 0.0;\n}\n\nvec3 tri3(in vec3 p) {\n\treturn vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));\n}\n\nvec3 sin3(vec3 p) {\n\treturn abs(vec3(sin(p.z + sin(p.y)), sin(p.z + sin(p.x)), sin(p.y + sin(p.x)) ));\n}\n\nfloat sineNoise3d(in vec3 p, in float spd) {\n\tfloat z = 1.4;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ ) {\n        \tvec3 dg = sin3(bp*2.);\n        \tp += (dg+time*spd);\n\n        \tbp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \t\n        \trz += (tri(p.z+tri(p.x+tri(p.y))))/z;\n        \tbp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat triNoise3d(in vec3 p, in float spd) {\n\tfloat z = 1.4;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ ) {\n        \tvec3 dg = tri3(bp*2.);\n        \tp += (dg+time*spd);\n\n        \tbp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \t\n        \trz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        \tbp += 0.14;\n\t}\n\treturn rz;\n}\n\nvec3 tri33(in vec3 x){return abs(x-floor(x)-.5);} \nfloat surfFunc(in vec3 p){\n\treturn dot(tri33(p*0.5 + tri33(p*0.25).yzx), vec3(0.666));\n}\n\nvec2 path(in float z){ float s = sin(z/8.)*cos(z/12.); return vec2(s*12., 0.); }\n\nfloat map(vec3 p) {\n\t\n\t/*\n\tfloat d = p.y;\n\t//vec3 bp = p + tri3(p * 3.0) * 0.1;\n\tfloat a = length(p - vec3(0.0, 0.25, 0.0)) - 0.5;\n\ta += sineNoise3d(p * 2.0, 0.01) * 0.05;\n\td = min(d, a);\n\treturn d;\n\t*/\n\t\n\tvec2 tun = abs(p.xy - path(p.z))*vec2(0.5, 0.7071);\n\tfloat n = 1.- max(tun.x, tun.y) + (0.5-surfFunc(p));\n\tfloat k = triNoise3d(p * 0.1, 0.1) * 0.15;\n\treturn min(n - k*(sin(time)*0.5+0.5), p.y + 1.0 + k);\n\t\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(-1.0, 1.0) * 0.01;\n    return normalize(\n        e.xyy * map(p + e.xyy) +\n        e.yxy * map(p + e.yxy) +\n        e.yyx * map(p + e.yyx) +\n        e.xxx * map(p + e.xxx)\n    );\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float t = mint;\n    float res = 1.0;\n    for(int i = 0; i < 30; i++) {\n        if(t > maxt) continue;\n        float h = map(ro + rd * t);\n        t += h;\n        res = min(res, k * h / t);\n    }\n    return res;\n}\n\nvoid main() {\n\tfloat time = time * 0.2;\n/*\t\n  vec2 p = gl_FragCoord.xy / resolution;\n  p = 2.0 * p - 1.0;\n  p.x *= resolution.x / resolution.y;\n  \n  vec3 ro = vec3(0.0, 0.0, 5.0 + time);\n  vec3 target = ro + vec3(0.0, 0.1, -0.5);\n  target.xy += path(target.z);\n  ro.xy += path(ro.z);\n\t\n  vec3 cw = normalize(target - ro);\n  vec3 cup = vec3(0.0, 1.0, 0.0);\n  vec3 cu = normalize(cross(cw, cup));\n  vec3 cv = normalize(cross(cu, cw));\n  vec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n*/\t\n\t// Screen coordinates.\n\tvec2 uv = (gl_FragCoord.xy - resolution.xy*0.5)/resolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lookAt = vec3(0.0, 0.0, time*5.);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n\t\n\t// Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n\tvec3 light_pos = camPos + vec3(0.0, 0.125, -0.125);// Put it a bit in front of the camera.\n\tvec3 light_pos2 = camPos + vec3(0.0, 0.0, 6.0);// Put it a bit in front of the camera.\n\t\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\tlight_pos2.xy += path(light_pos2.z);\n\t\n\t// Using the above to produce the unit ray-direction vector.\n\tfloat FOV = 3.141592/3.; // FOV - Field of view.\n\tvec3 forward = normalize(lookAt-camPos);\n\tvec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n\tvec3 up = cross(forward, right);\n\t\n\t// rd - Ray direction.\n\tvec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\t\n\t// Swiveling the camera from left to right when turning corners.\n\t//rd.xy = rot2( path(lookAt.z).x/32. )*rd.xy;\n\t\t\n\t\n  \n  float t = 0.0;\n  float e = 0.01;\n  float h = e * 2.0;\n  for(int i = 0; i < 60; i++) {\n      if(h < e || t > 20.0) continue;\n      h = map(camPos + rd * t);\n      t += h;\n  }\n  \n  float col = 0.0;\n  vec3 color = vec3(0.0);\n  if(h < e) {\n    vec3 pos = camPos + rd * t;\n    vec3 ligPos = camPos + vec3(0.0, 0.0, 0.0);\n    vec3 lig = normalize(light_pos2 - pos);\n    vec3 nor = calcNormal(pos);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float fre = 1.0 + dot(rd, nor);\n    float spe = pow(clamp(dot(rd, reflect(lig, nor)), 0.0, 1.0), 32.0);\n    float sh = shadow(pos, lig, 0.01, 20.0, 6.0) * 0.3 + 0.5;\n    col = ((dif + spe) * sh + fre * 0.5);\n  \n    col *= pow(1.0 - t / 20.0, 2.0);\n    color = mix(vec3(.23,.6,.5),vec3(.2,.134,.1)*1.3,step(-1.,pos.y))*col;//col * vec3(cos(1.0 + time * 0.2)*0.5 + 0.5, sin(0.8 + time)*0.5+0.5, 0.2);\t  \n  }\n  gl_FragColor = vec4(color, 1.0);\n}", "user": "e70bd82", "parent": "/e#33229.0", "id": "33231.1"}