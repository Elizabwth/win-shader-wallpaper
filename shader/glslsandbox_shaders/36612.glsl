{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n//#define TOP_VIEW\n//#define MOUSE_CONTROL\n\n#define RAYMARCH_STEPS 64\n#define RAYMARCH_LIGHT_STEPS 64\n#define EPSILON 0.01\n#define PI 3.1415\n\nvec3 CAMERA_POS;\n#ifdef TOP_VIEW\n#define CAMERA_ROT 0.5\n#else\n#define CAMERA_ROT 0.35\n#endif\n\nvec3 CAMERA_TARGET = vec3(0., 0.2, 0.);\n\nvec3 LIGHT_POS;\nfloat LIGHT_LENGTH = 9.;\nvec3 SKY_COLOR=vec3(0.00, 0.0, 0.00);\nvec3 LIGHT_COLOR=vec3(0.9, 0.8, 0.5);\n\n#ifdef TOP_VIEW\nfloat LIGHT_BALL_RADIUS=0.1;\n#else\nfloat LIGHT_BALL_RADIUS=0.1;\n#endif\nfloat LIGHT_BRIGHTNESS=10.;\n\nstruct Surface {\n\tvec3 color;\n\tfloat shadow;\n\tfloat ao;\n};\n\nstruct Hit {\n\tvec3 p;\n\tvec3 normal;\n\tSurface s;\n\tbool touched;\n\tfloat raymarch_steps;\n};\n\nstruct Ray {\n\tvec3 origin;\n\tvec3 direction;\n};\n\n\nstruct Camera{\n\tvec3 position;\n\tvec3 lookAt;\n\tvec3 rayDir;\n\tvec3 forward, up, left;\n};\n\n\n\nfloat rand(vec2 n){\n    return fract(sin(n.x + n.y * 1e3) * 1e5);\n}\n\nfloat rand(vec3 n){\n    return fract(sin(n.x + n.y * 1e3 + n.z * 1e4) * 1e5);\n}\n\nvec2 rotate(vec2 p, float angle){\n\treturn vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\n}\n\n\nfloat sdBox(vec3 p, vec3 box_pos, vec3 b){\n\tvec3 d = abs(p - box_pos) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdSphere(vec3 p, vec3 sphere_pos, float r){\n\treturn distance(p, sphere_pos)-r;\n}\n\nfloat opUnion(float d1, float d2){\n\treturn min(d1, d2);\n}\n\n\n\nfloat sdSphere(vec3 p, float r){\n\treturn length(p)-r;\n}\nfloat sdDisc(vec2 p, float r){\n\treturn length(p)-r;\n}\n\nfloat opU(float a, float b){\n\treturn min(a, b);\n}\n\nfloat opI(float a, float b){\n\treturn max(a, b);\n}\n\nfloat opS(float a, float b){\n\treturn max(a, -b);\n}\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdRectangle(vec2 p, vec2 b){\n\tvec2 d = abs(p) - b;\n\treturn min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nbool computing_light=false;\nfloat de(vec3 p){\n\tfloat d = -sdBox(p-vec3(0., 10., 0.), vec3(5., 10., 5.));\n\tvec3 alt_p=p;\n\talt_p.xz=mod(alt_p.xz, vec2(1.5, 1.5))-vec2(.75, .75);\n\td=min(d, sdSphere(alt_p-vec3(0., .2, 0.), .2));\n\n\treturn d;\n}\n\n\nvoid raymarch(Ray light_ray, out Hit result){\n\tresult.p=light_ray.origin;\n\n\tfloat d;\n\tfor(int n=0; n<RAYMARCH_STEPS; n++){\n\t\td=min(de(result.p), sdSphere(result.p-LIGHT_POS, LIGHT_BALL_RADIUS));\n\t\tresult.p+=.6*d*light_ray.direction;\n\t\tif(d<=EPSILON){\n\t\t\tresult.touched=true;\n\t\t\tresult.raymarch_steps=float(n);\n\t\t\treturn;\n\t\t}\n\t\tif(distance(result.p, LIGHT_POS)>LIGHT_LENGTH*2.){\n\t\t\tbreak;\n\t\t}\n\t}\n\tresult.touched=false;\n\tresult.raymarch_steps=float(RAYMARCH_STEPS);\n}\n\nvoid raymarch_alt(Ray light_ray, out Hit result){\n\tresult.p = light_ray.origin;\n\tfloat d;\n\tfloat last_d = 0.;\n\tfloat best_d = 100.;\n\tfloat current_k = 1.6;\n\tfor(int n = 0; n < RAYMARCH_STEPS ; n++){\n\t\td = min(de(result.p), sdSphere(result.p-LIGHT_POS, LIGHT_BALL_RADIUS));\n\t\tif(last_d*current_k>last_d+d){ // Circles don't overlap\n\t\t\tresult.p-=light_ray.direction*last_d*.6;\n\t\t\tcurrent_k = 1.;\n\t\t} else {\n\t\t\tlast_d = d;\n\t\t\tresult.p+=light_ray.direction*d*current_k;\n\t\t\tif(d < EPSILON){\n\t\t\t\tresult.touched=true;\n\t\t\t\tresult.raymarch_steps=float(n);\n\t\t\t}\n\t\t}\n\t}\n}\nfloat raymarch_light(Ray light_ray, float mint, float maxt, float k ){\n    float res = 1.0;\n\tfloat t=mint;\n\tfor(int n=0; n<RAYMARCH_LIGHT_STEPS; n++){\n\t\tfloat h = de(light_ray.origin + light_ray.direction*t);\n\t\tif( h<EPSILON*.1){\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min( res, k*h/t );\n\t\tt += h;\n\t\tif(t > maxt){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid compute_camera(vec2 uv, out Camera result){\n\tresult.lookAt = CAMERA_TARGET;\n\tresult.position = CAMERA_POS;\n\tresult.up = vec3(0., 1., 0.);\n\tresult.forward = normalize(result.lookAt-result.position);\n\tresult.left = cross(result.forward, result.up);\n\tresult.up = cross(result.left, result.forward);\n}\n\nvoid compute_ray(vec2 uv, Camera cam, out Ray result){\n\t#ifdef TOP_VIEW\n\tvec3 screenOrigin = (cam.position+cam.forward*.08);\n\t#else\n\tvec3 screenOrigin = (cam.position+cam.forward);\n\t#endif\n\n\tvec3 screenHit = screenOrigin + uv.x*cam.left + uv.y*cam.up;\n\n\tcam.rayDir = normalize(screenHit-cam.position);\n\tresult.origin=CAMERA_POS;\n\tresult.direction=cam.rayDir;\n\n}\n\nvoid compute_normal(inout Hit result){\n\tvec2 off=vec2(0., EPSILON*.5);\n  \tvec3 n;\n  \tn.x = de(result.p+off.yxx);\n  \tn.y = de(result.p+off.xyx);\n  \tn.z = de(result.p+off.xxy);\n\tn = n-de(result.p);\n  \tresult.normal=normalize(n);\n}\nfloat compute_ambiant_occlusion( in Hit result)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  result.normal * hr + result.p;\n        float dd = de( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.*occ, 0.0, 1.0 );\n}\nvoid compute_surface(Ray light_ray, inout Hit result){\n\tif(!result.touched){\n\t\tresult.s.color=SKY_COLOR;\n\t\tresult.s.shadow=0.;\n\t\treturn;\n\t}\n\tif(distance(result.p, LIGHT_POS)<LIGHT_BALL_RADIUS+EPSILON){\n\t\tresult.s.color=LIGHT_COLOR*2.;\n\t\tresult.s.shadow=1.;\n\t\treturn;\n\t}\n\n\tresult.s.ao=compute_ambiant_occlusion(result);\n\n\tif(result.p.y<EPSILON){\n\t\tresult.s.color = .1*mix(vec3(0.5, 0.5, 0.5), vec3(1., 1., 1.), step(0.0, (cos(result.p.x*3.*3.1415)*cos(result.p.z*3.*3.1415))));\n\t} else {\n\t\tresult.s.color=.1*mix(vec3(1.), result.normal, .5);\n\t}\n\n\t\tresult.s.color=mix(result.s.color, vec3(.9, .7, .3)*(.5+.5*cos(result.p.x*50.)*cos(result.p.y*50.)*cos(result.p.z*50.)), .2*(1.-result.s.ao));\n\n\tRay ray_to_light = Ray(result.p, normalize(LIGHT_POS-result.p));\n\n\tif(dot(ray_to_light.direction, result.normal)<0.){\n\t\tresult.s.shadow=1.;\n\t} else {\n\t\tray_to_light.origin+=ray_to_light.direction*EPSILON;\n\t\tcomputing_light=true;\n\t\tresult.s.shadow=raymarch_light(ray_to_light, 0., distance(result.p, LIGHT_POS), LIGHT_LENGTH);\n\t\tcomputing_light=false;\n\t}\n\tresult.s.shadow*=smoothstep(0.0, .15, dot(ray_to_light.direction, result.normal));\n\tresult.s.shadow=mix(result.s.shadow, 1., .15);\n\tresult.s.shadow*=clamp(1.-smoothstep(0., LIGHT_LENGTH, distance(result.p, LIGHT_POS)), 0., 1.);\n\tresult.s.shadow*=result.s.ao;\n\tresult.s.shadow*=LIGHT_BRIGHTNESS;\n\tresult.s.color*=LIGHT_COLOR*result.s.shadow;\n\n}\n\nvec3 compute_mouse_hit(){\n\tvec2 mouse_on_uv = mouse;\n\tmouse_on_uv-=vec2(.5);\n\tmouse_on_uv.x*=resolution.x/resolution.y;\n\n\n\tCamera cam;\n\tRay view_ray;\n\tHit ray_hit;\n\tcompute_camera(mouse_on_uv, cam);\n\tcompute_ray(mouse_on_uv, cam, view_ray);\n\tcomputing_light=true;\n\traymarch_alt(view_ray, ray_hit);\n\tcomputing_light=false;\n\treturn ray_hit.p;\n}\nvoid main( void ) {\n\t#ifdef TOP_VIEW\n\tCAMERA_POS = vec3(0., 10., 0.)+1.*vec3(cos(PI*CAMERA_ROT), 0., sin(PI*CAMERA_ROT));\n\t#else\n\tCAMERA_POS = vec3(0., 2., 0.)+4.5*vec3(cos(PI*CAMERA_ROT), 0., sin(PI*CAMERA_ROT));\n\t#endif\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tuv-=vec2(.5);\n\tuv.x*=resolution.x/resolution.y;\n\t#ifdef MOUSE_CONTROL\n\tLIGHT_POS=compute_mouse_hit()+vec3(0., 1., 0.);\n        #else\n        LIGHT_POS=vec3(cos(time*.1)*4., 1.0, sin(time*.2)*4.);\n\t#endif\n\tCamera cam;\n\tRay view_ray;\n\n\tcompute_camera(uv, cam);\n\tcompute_ray(uv, cam, view_ray);\n\tHit ray_hit;\n\n\traymarch_alt(view_ray, ray_hit);\n\n\tcompute_normal(ray_hit);\n\tcompute_surface(view_ray, ray_hit);\n\n\tvec3 color = ray_hit.s.color;\n\tcolor=clamp(color, vec3(0.), vec3(1.));\n\tcolor=pow( color, vec3(1.0/2.2) );\n\tgl_FragColor = vec4( color , 1.0 );\n\n}", "user": "4c3adf5", "parent": null, "id": "36612.2"}