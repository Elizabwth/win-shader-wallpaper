{"code": "// Simple color picker... now with touch control\n// public domain\n\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D bb;\n\n\n\n\n#define goTYPE p = ( gl_FragCoord.xy /resolution.xy ) * vec2(64,32);vec3 c = vec3(0);vec2 cpos = vec2(2.*sin(time*1.1001234567890),1.+0.25*abs(sin(time*2.)));vec3 txColor = vec3(1);\n#define goPRINT gl_FragColor += vec4(c, 1.0);\n#define slashN cpos = vec2(1,cpos.y-6.);\n#define inBLK txColor = vec3(0);\n#define inWHT txColor = vec3(1);\n#define inRED txColor = vec3(1,0,0);\n#define inYEL txColor = vec3(1,1,0);\n#define inGRN txColor = vec3(0,1,0);\n#define inCYA txColor = vec3(0,1,1);\n#define inBLU txColor = vec3(0,0,1);\n#define inPUR txColor = vec3(1,0,1);\n#define inPCH txColor = vec3(1,0.7,0.6);\n#define inPNK txColor = vec3(1,0.7,1);\n#define A c += txColor*Sprite3x5(31725.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define B c += txColor*Sprite3x5(31663.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define C c += txColor*Sprite3x5(31015.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define D c += txColor*Sprite3x5(27502.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define E c += txColor*Sprite3x5(31143.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define F c += txColor*Sprite3x5(31140.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define G c += txColor*Sprite3x5(31087.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define H c += txColor*Sprite3x5(23533.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define I c += txColor*Sprite3x5(29847.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define J c += txColor*Sprite3x5(4719.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define K c += txColor*Sprite3x5(23469.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define L c += txColor*Sprite3x5(18727.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define M c += txColor*Sprite3x5(24429.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define N c += txColor*Sprite3x5(7148.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define O c += txColor*Sprite3x5(31599.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define P c += txColor*Sprite3x5(31716.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define Q c += txColor*Sprite3x5(31609.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define R c += txColor*Sprite3x5(27565.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define S c += txColor*Sprite3x5(31183.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define T c += txColor*Sprite3x5(29842.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define U c += txColor*Sprite3x5(23407.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define V c += txColor*Sprite3x5(23402.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define W c += txColor*Sprite3x5(23421.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define X c += txColor*Sprite3x5(23213.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define Y c += txColor*Sprite3x5(23186.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define Z c += txColor*Sprite3x5(29351.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n0 c += txColor*Sprite3x5(31599.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n1 c += txColor*Sprite3x5(11410.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n2 c += txColor*Sprite3x5(29671.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n3 c += txColor*Sprite3x5(29391.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n4 c += txColor*Sprite3x5(23497.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n5 c += txColor*Sprite3x5(31183.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n6 c += txColor*Sprite3x5(31215.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n7 c += txColor*Sprite3x5(29257.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n8 c += txColor*Sprite3x5(31727.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define n9 c += txColor*Sprite3x5(31695.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define DOT c += txColor*Sprite3x5(2.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define COLON c += txColor*Sprite3x5(1040.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define PLUS c += txColor*Sprite3x5(1488.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define DASH c += txColor*Sprite3x5(448.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define LPAREN c += txColor*Sprite3x5(10530.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define RPAREN c += txColor*Sprite3x5(8778.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define _ cpos.x += 4.;if(cpos.x > 61.) slashN\n#define BLOCK c += txColor*Sprite3x5(32767.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define QMARK c += txColor*Sprite3x5(25218.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define EXCLAM c += txColor*Sprite3x5(9346.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define EQUAL c += txColor*Sprite3x5(3640.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define HEART c += txColor*Sprite3x5(3024.,floor(p-cpos));cpos.x += 4.;if(cpos.x > 61.) slashN\n#define getBit(num,bit) float(mod(floor(floor(num)/pow(2.,floor(bit))),2.) == 1.0)\n#define Sprite3x5(sprite,p) getBit(sprite,(2.0 - p.x) + 3.0 * p.y) * float(all(lessThan(p,vec2(3,5))) && all(greaterThanEqual(p,vec2(0,0))))\n#define iHEX if(i < 0.5){if(i < 0.25){if(i < 0.125){if(i < 0.0625){n0}else{n1}}else{if(i < 0.1875){n2}else{n3}}}else{if(i < 0.375){if(i < 0.3125){n4}else{n5}}else{if(i < 0.4375){n6}else{n7}}}}else{if(i < 0.75){if(i < 0.625){if(i < 0.5625){n8}else{n9}}else{if(i < 0.6875){A}else{B}}}else{if(i < 0.875){if(i < 0.8125){C}else{D}}else{if(i < 0.9375){E}else{F}}}}\nvarying vec2 surfacePosition;\nvec3 hsv2rgb(vec3 c)\n{\n\tc.x=fract(c.x+time*.017+length(surfacePosition)*.25);\n    vec4 q = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + q.xyz) * 6.0 - q.www);\n    return pow(c.z * mix(q.xxx, clamp(p - q.xxx, 0.0, 1.0), c.y), vec3(1.25));\n}\n\nfloat sdRect(vec2 p, vec2 t, vec2 b)\n{\n\tvec2 d = abs(p-t)-b;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat sdCircle(vec2 p, vec2 t, float r)\n{\n    return length(p-t)-r;\n}\n\nconst float PI = 3.14159265358979323846264;\n\nvec4 mem_load(){\n\t/*\n\tRead saved input. \n\t*/\n\treturn texture2D(bb, vec2(0.));\n}\nvoid mem_save(){\n\t/*\n\tCheck for input changes, then store input memory. \n\t*/\n\tif(length(gl_FragCoord.xy) < 1.){\n\t\tgl_FragColor = mem_load();\n\t\t\n\t\tvec2 m = (mouse-0.5)* vec2(1.0, resolution.y/resolution.x);\n\t\tif(length(m) < 0.15){\n\t\t\tgl_FragColor.yz = 0.5+m*6.;\n\t\t}else{\n\t\t\tgl_FragColor.x = fract(0.25-atan(m.x, m.y)/(2.*PI));\n\t\t}\n\t}\n}\n\n\nvoid main()\n{\n\t\n\tvec4 mem = mem_load();\n\t\n    vec2 huePos = vec2(cos(2.*PI*mem.x), sin(2.*PI*mem.x))*0.35;\n    vec2 shadePos = 0.17*2.*(mem.yz-0.5);\n    \n    vec2 p = (gl_FragCoord.xy/resolution*2.0-1.0) * vec2(1.0, resolution.y/resolution.x);\n    float sd = sdRect(p, vec2(0.0), vec2(0.17));\n    float osd = max(sdCircle(p, vec2(0.0), 0.4), -sdCircle(p, vec2(0.0), 0.3));\n    \n    float a = min(1.0, length(p) / 0.25);\n    vec2 d = normalize(p);\n    float b = (atan(d.y, d.x) + (PI)) / (2.0*PI);\n    \n    // Hue\n    float w = (atan(huePos.y, huePos.x) + (PI)) / (2.0*PI);\n    float hsd = max(sdCircle(p, huePos, 0.058), -sdCircle(p, huePos, 0.04));\n    \n    // Shade\n    float ssd_inner = sdCircle(p, shadePos, 0.045);\n    float ssd = min(sdCircle(p, shadePos, 0.058), ssd_inner);\n    vec3 selectedColor = hsv2rgb(vec3(w, 0.5+0.5*clamp(vec2(shadePos)/(0.17), vec2(-1.0), vec2(1.0))));\n    \n    vec3 color = vec3(0.0);\n    if (osd < 0.0)\n    {\n        color = hsv2rgb(vec3(b, 1.0, 1.0));\n    }\n    else if (sd < 0.0)\n    {\n        color.rgb = hsv2rgb(vec3(w, 0.5+0.5*clamp(vec2(p)/(0.17), vec2(-1.0), vec2(1.0))));\n    } else if (length(p) < 1.0){\n\tcolor.rgb = selectedColor;\n    }\n    \n    sd = min(ssd, min(hsd, min(sd, osd)));\n    //color = smoothstep(0.0, -2.0/resolution.y, sd)*color;\n    color.rgb = mix(vec3(1.0), color, smoothstep(-2.0/resolution.y, 0.0, hsd));\n    color.rgb = mix(vec3(1.0), color, smoothstep(-2.0/resolution.y, 0.0, ssd));\n    color.rgb = mix(selectedColor, color, smoothstep(-2.0/resolution.y, 0.0, ssd_inner));\n    float mask = smoothstep(2.0/resolution.y, 0.0, -sd);\n    gl_FragColor = vec4(color, 1.0);\n\t\n\tif(length(p) > 0.420){\n\t\tgl_FragColor = vec4(selectedColor,1.)*pow(1.-.75*length(p)*length(p), 0.5);\n\t}\n\t\n\tgoTYPE _ _ _\n\t\tfloat i = 0.;\n\t\ti = selectedColor.x; iHEX\n\t\ti = fract(i*7.999); iHEX\n\t\t\n\t\ti = selectedColor.y; iHEX\n\t\ti = fract(i*7.999); iHEX\n\t\t\n\t\ti = selectedColor.z; iHEX\n\t\ti = fract(i*7.999); iHEX\n\t\t\n\tgoPRINT\n\tmem_save();\n\t\n\t// adding a simple drop shadow (and bumping)\n\tfloat dc = dot(vec3(1), texture2D(bb, (gl_FragCoord.xy+vec2(-2, 2))/resolution).rgb);\n\tif(dc >= 3.){\n\t\tgl_FragColor *= gl_FragColor;\n\t}\n}\n", "user": "c9343a2", "parent": "/e#32201.4", "id": "32225.0"}