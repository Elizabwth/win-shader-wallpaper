{"code": "#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision mediump float;\n\n#endif\n\n// quadratic bezier curve rendering\n// posted by Trisomie21\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nstruct Bezier2 {\n\tvec2 p[3];\n};\n\n#define kCurvesPerCell 2\n\t\nvec2 tangentAt(vec2 P0, vec2 P1, vec2 P2, float t) {\n    return 2.0 * (1.0-t) * (P1 - P0) + 2.0 * t * (P2 - P1);\n}\n\nvec2 normalAt(vec2 P0, vec2 P1, vec2 P2, float t) {\n    vec2 tangent = tangentAt(P0, P1, P2, t);\n    return vec2(tangent.y, -tangent.x);\n}\n\nvec2 positionAt(vec2 P0, vec2 P1, vec2 P2, float t) {\n    float mt = 1.0 - t;\n    return mt*mt*P0 + 2.0*t*mt*P1 + t*t*P2;\n}\n\nfloat cuberoot( float x )\n{\n    if( x<0.0 ) return -pow(-x,1.0/3.0);\n    return pow(x,1.0/3.0);\n}\n\nint solveCubic(in float a, in float b, in float c, out vec3 r)\n{\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = cuberoot(u);\n\t\tv = cuberoot(v);\n\t\tr[0] = offset + u + v;\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\treturn 3;\n}\n\nvoid findNearestPoint( in vec2 P0, in vec2 P1, in vec2 P2, in vec2 p, out float closestDistance, out vec2 closestPoint, out float dotNormal, out float closestT)\n{\n    float dis = 1e20;\n    \n    vec2 sb = (P1 - P0) * 2.0;\n    vec2 sc = P0 - P1 * 2.0 + P2;\n    vec2 sd = P1 - P0;\n    float sA = 1.0 / dot(sc, sc);\n    float sB = 3.0 * dot(sd, sc);\n    float sC = 2.0 * dot(sd, sd);\n    \n    \n    vec2 D = P0 - p;\n\n    float a = sA;\n    float b = sB;\n    float c = sC + dot(D, sc);\n    float d = dot(D, sd);\n\n    vec3 res;\n    int n = solveCubic(b*a, c*a, d*a, res);\n\n    closestDistance = 100000.0;\n\n    for (int i=0; i<3; i++) {\n        if (i == n) break;\n        float t = clamp(res[i], 0.0, 1.0);\n        vec2 pos = positionAt(P0, P1, P2, t);\n        vec2 closestVector = p - pos;\n        float distance = length(closestVector);\n\n        if (distance < closestDistance) {\n\t\tclosestDistance = distance;\n\t\tclosestPoint = pos;\n\t\tvec2 normal = normalAt(P0, P1, P2, t);\n\t\tdotNormal = dot(normalize(normal), normalize(closestVector));\n\t\tclosestT = t;\n        }\n    }\n\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat signedDistanceToBeziers(in Bezier2 beziers[kCurvesPerCell], in int numBeziers, in vec2 position, out int closestCurve)\n{\n\tfloat closestDistance = 10000.0;\n\tvec2 closestOnCurve;\n\tfloat closestDotNormal;\n\t//int closestCurve;\n\n\tfor (int i=0; i<kCurvesPerCell; i++) {\n\t\tif (i == numBeziers) break;\n\t\tfloat distance, dotNormal, t;\n\t\tvec2 oncurve;\n\t\tfindNearestPoint(beziers[i].p[0], beziers[i].p[1], beziers[i].p[2], position, distance, oncurve, dotNormal, t);\n\t\tdistance -= abs(dotNormal) * 1e-3 * distance;\n\t\tbool replace = distance < closestDistance;\n\t\t//if (distance == closestDistance) {\n\t\tif (oncurve == closestOnCurve) {\n\t\t\treplace = abs(dotNormal) > abs(closestDotNormal);\n\t\t}\n\t\t\n\t\tif (replace ) {\n\t\t\tclosestDistance = distance;\n\t\t\tclosestOnCurve = oncurve;\n\t\t\tclosestDotNormal = dotNormal;\n\t\t\tclosestCurve = i;\n\t\t}\n\t}\n\t\n\treturn closestDotNormal < 0.0 ? -closestDistance : closestDistance;\n}\n\nvoid main( void ) {\n\n\tvec2 position = (gl_FragCoord.xy/resolution.y)*2.0 - 1.0;\n\t//position.y += .9;\n\t//position *= (0.5 + 10.0*mouse.y);\n\t//position.x = sqrt(abs(position.x));\n\n\tBezier2 beziers[2];\n\tbeziers[0].p[0] = vec2(-0.8, 0.1);\n\tbeziers[0].p[1] = vec2(0.2, -0.2);\n\tbeziers[0].p[2] = vec2(mouse.x*2.0, mouse.y) * 2.0 - 1.0;\n\tbeziers[1].p[0] = beziers[0].p[2];\n\tbeziers[1].p[1] = vec2(0.7, -0.2);\n\tbeziers[1].p[2] = vec2(0.95, -0.3);\n\t\n\tint closestCurve;\n\tfloat closestDistance = signedDistanceToBeziers(beziers, 2, position, closestCurve);\n\t\t\n\t\n\tfloat k = fract(abs(closestDistance)*30.0);\n\t//closestDistance = abs(closestDistance);\n\t//gl_FragColor = vec4(float(closestCurve) * 0.5 + 0.5, closestDistance < 0.0 ? 0.5 : 1.0, k, 1.0);\n\t//float fac = dFdx(position.x);\n\tgl_FragColor = vec4(smoothstep(-1.0, 1.0, closestDistance*resolution.y));\n\tgl_FragColor.r = k;\n\tgl_FragColor = mix(gl_FragColor, vec4(float(closestCurve)), 0.2);\n\n}", "user": "197df09", "parent": "/e#21933.1", "id": "26367.0"}