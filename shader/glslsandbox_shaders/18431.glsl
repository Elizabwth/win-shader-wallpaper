{"code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nuniform mat4 eye;\nuniform vec3 eyeTranslate;\nuniform vec3 eyeRotate;\n\n#define M_PI\t\t\t\t(3.1415926535897932384626433832795)\n\n// Ray Marcher\n#define MINDELTA\t\t\t(0.00001)\n#define MAXDELTA\t\t\t(0.01)\n#define MAXDIST\t\t\t\t(16.0)\n// Provide 'float s', a distance.\n#define PRECISION\t\t\t(mix(MINDELTA, MAXDELTA, pow(s/MAXDIST, 0.9)))\n#define MAXITER\t\t\t\t(32)\n\n// Background\n#define LIGHTVEC\t\t\t(vec3(1.2, 1.0, 0.1))\n#define BACKROUND1\t\t\t(vec3(0.6, 0.8, 1.0))\n#define BACKROUND2\t\t\t(vec3(0.6, 0.8, 1.0)/2.0)\n\n#define USE_SIMPLEX_NOISE\n#define SIMPLEX_ITERATIONS1\t\t8\n#define SIMPLEX_ITERATIONS2\t\t1\n\n#define FRACT_ITER\t\t\t20\n#define FRACT_SCALE\t\t\t1.8\n#define FRACT_OFFSET\t\t\t1.0\n\nvec3 vRotateX(vec3 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn vec3(p.x, c*p.y+s*p.z, -s*p.y+c*p.z);\n}\n\nvec3 vRotateY(vec3 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec3 vRotateZ(vec3 p, float angle) {\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\nfloat DE(vec3 z) {\n\tfloat c = 2.0;\n\tz.y = mod(z.y, c)-c/2.0;\n\n\tz = vRotateZ(z, M_PI/2.0);\n\n\tfloat r;\n\tint n1 = 0;\n\tfor (int n = 0; n < FRACT_ITER; n++) {\n\t\tfloat rotate = M_PI*0.5;\n\t\tz = vRotateX(z, rotate);\n\t\tz = vRotateY(z, rotate);\n\t\tz = vRotateZ(z, rotate);\n\n\t\tz.xy = abs(z.xy);\n\t\tif (z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n\t\tif (z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n\t\tif (z.y+z.z<0.0) z.zy = -z.yz; // fold 3\n\t\tz = z*FRACT_SCALE - FRACT_OFFSET*(FRACT_SCALE-1.0);\n\t}\n\treturn (length(z) ) * pow(FRACT_SCALE, -float(FRACT_ITER));\n}\n\nfloat getMap(in vec3 position, out int object, bool bump) {\n\tfloat distance = MAXDIST;\n\tfloat tempDist = MAXDIST;\n\n\tdistance = DE(position); object = 1;\n\t\n\treturn distance;\n}\n\nvec3 getNormal(vec3 p) {\n\tvec3 s = p;\n\tfloat h = MINDELTA;\n\tint object;\n\treturn normalize(vec3(\n\t\t\tgetMap(p + vec3(h, 0.0, 0.0), object, true) - getMap(p - vec3(h, 0.0, 0.0), object, true),\n\t\t\tgetMap(p + vec3(0.0, h, 0.0), object, true) - getMap(p - vec3(0.0, h, 0.0), object, true),\n\t\t\tgetMap(p + vec3(0.0, 0.0, h), object, true) - getMap(p - vec3(0.0, 0.0, h), object, true)));\n}\n\nvec2 castRay(in vec3 origin, in vec3 direction, out int object) {\n\tfloat distance = 0.0;\n\tfloat delta = 0.0;\n\tvec3 position;\n\tobject = 0;\n\tint iter = 0;\n\t\n\tposition = origin;\n\tfor (int i = 0; i < MAXITER; i++) {     \n\t\titer += 1;\n\t\tdelta = getMap(position, object, false);\n\t\t\n\t\tdistance += delta;\n\t\tposition = origin + direction*distance;\n\t\tfloat s = distance;\n\t\tif (delta <= PRECISION) {\n\t\t\treturn vec2(distance, float(i));\n\t\t}\n\t\tif (distance > MAXDIST) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tobject = 0;\n\treturn vec2(MAXDIST, float(iter));\n}\n\nvec3 getShading(in vec2 distance, in vec3 origin, in vec3 direction, in int object) {\n\tvec3 position = origin + direction * distance.x;\n\tvec3 color = vec3(1.0, 1.0, 1.0);\n\t\n\tfloat cheapAO = distance.y/float(MAXITER);\n\t\n\tif (object == 1) {\n\t\tcolor = vec3(1.0, 1.0, 1.0);\n\t}\n\t\n\treturn mix(color, vec3(0.0, 0.0, 0.0), cheapAO);\n}\n\nvec3 drawScene(in vec3 origin, in vec3 direction) {\n\tint object = 0;\n\t\n\tvec2 distance = castRay(origin, direction, object);\n\t\n\treturn getShading(distance, origin, direction, object);\n}\n\nvoid main() {\n\n\tvec2 p=(gl_FragCoord.xy/resolution.y)*2.0;\n\tp.x-=resolution.x/resolution.y*1.0;p.y-=1.0;\n\n\t//vec3 origin = vec3(0.0, 0.0, 0.0) - eyeTranslate/128.0;\n\tvec3 origin = vec3(0.0, -mod(time*0.1, 2.0)+1.0, 0.0);\n\tvec3 direction = normalize(vec3(p.x,p.y,1.0));\n\n\tdirection = vRotateZ(direction, time*0.1);\n\tdirection = vRotateX(direction, eyeRotate.x-M_PI/2.0);\n\t//direction = vRotateZ(direction, eyeRotate.z);\n\n\tvec3 color = drawScene(origin, direction);\n\n\tgl_FragColor = vec4(pow(color,vec3(1.0/2.2)), 1.0);\n}", "user": "8d5f91b", "parent": "/e#18320.0", "id": "18431.0"}