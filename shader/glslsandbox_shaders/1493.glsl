{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n/* a lot of code stolen from @iq mixed with some random geometry */\n\nuniform vec2 resolution;\nuniform float time;\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nfloat\nmaxcomp(vec3 v)\n{\n\treturn max(v.x, max(v.y, v.z));\n}\n\nfloat sdbox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\nfloat\nmap(vec3 rp)\n{\n\tfloat dp = rp.y + 1.0;\n\tfloat ds = length(rp) - 0.3;\n\tfloat us = 1000.0;\n\tfor(int i=0; i<3; i++){\n\t\tfor(int j=0; j<3; j++){\n\t\t\tvec3 org = vec3(float(i-1)/3.0, -1, float(j-1)/3.0);\n\t\t\tus = min(us, length(rp - org) - 0.1);\n\t\t}\n\t}\n\t\n\tvec3 c = vec3(.0, .0, -0.75);\n\tvec3 b = vec3(.2, .2, .2);\n\tfloat db = sdbox(rp-c, b);\n\tfloat dq = length(rp-c) - 0.25;\n\treturn min(max(dp, -us), max(db, -dq));\n}\n\nvec3\nnormal(vec3 p)\n{\n\tvec3 e = vec3(.001, .0, .0);\n\treturn normalize(vec3(\n\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t));\n}\n\nvec3\nfbmnormal(vec3 p)\n{\n\tvec3 e = vec3(.001, .0, .0);\n\treturn normalize(vec3(\n\t\tfbm(p+e.xyy) - fbm(p-e.xyy),\n\t\tfbm(p+e.yxy) - fbm(p-e.yxy),\n\t\tfbm(p+e.yyx) - fbm(p-e.yyx)\n\t));\n\t\n}\n\nvec2\nrot(vec2 v, float a)\n{\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a)) * v;\n}\n\nfloat\nshadow(vec3 rp, vec3 rd, float a, float b, float k)\n{\n\tfloat t = a;\n\tfloat r = 1.0;\n\tfor(int i=0; i<80; i++){\n\t\tfloat h = map(rp+rd*t);\n\t\tif(h < 0.001)\n\t\t\treturn 0.0;\n\t\tr = min(r, k*h/t);\n\t\tt += h;\n\t\tif(t >= b)\n\t\t\treturn r;\n\t}\n\treturn r;\n}\n\nvoid\nmain(void)\n{\n\tvec2 pos = (2.0*gl_FragCoord.xy - resolution.xy) / resolution.x;\n\tfloat c = 0.0;\n\t\n\tvec3 lo = vec3(0.5, sin(time)/2.0, -1);\n\tvec3 ro = vec3(0,0.1,-1);\n\tvec3 rd = normalize(vec3(pos, 1.0));\n\tvec3 rp = ro;\n\tfloat d = 1000.0;\n\tvec2 cam;\n\t//cam = rot(rd.xz, sin(time)/8.0+.125);\n\t//rd = vec3(cam.x, rd.y, cam.y);\n\tcam = rot(rd.yz, -.8);\n\trd = vec3(rd.x, cam.x, cam.y);\n\tfor(int i=0; i<80; i++){\n\t\td = map(rp);\n\t\tif(d < 0.0001)\n\t\t\tbreak;\n\t\trp += rd*d;\n\t}\n\tif(d < 0.001){\n\t\tvec3 snor = normal(rp) + 0.3 * fbmnormal(rp*100.0);\n\t\tvec3 ld = lo - rp;\n\t\tfloat diff = max(0.0, dot(ld, snor)) * shadow(rp, normalize(ld), 0.01, length(ld), 16.0);\n\t\tfloat amb = 0.1;\n\t\tc = diff;\n\t}\n\t//c = 0.0;\n\tgl_FragColor = vec4(c, c, c, 1);\n}", "user": "179b6a3", "parent": null, "id": "1493.1"}