{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n//relaxing spherical harmonic \n//feel free to fix the isosurface expression - not sure how to do the standard atomic model bulbs type view...\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI              (4.*atan(1.))\n#define TAU             (8.*atan(1.))\n#define ISQRT2          (1./sqrt(2.))\n  \n#define PHI              .00001\n#define EPSILON          .00002\n#define FARPLANE         64.\n#define FOV              2.\n\n#define VIEWPOINT        vec3(2.75, 2.75, 2.)\n#define VIEWTARGET       vec3(-.35, .0, 0.)\n  \n#define LIGHTPOSITION    vec3(-8.5, 8., 8.423) * 32.\n\nstruct ray\n{\n    float e, i;\n\tvec3 o, d;\n};\n\nstruct surface\n{\n    int id;\n\tvec3 p, n;\n    vec4 c;\n};\n    \nstruct light\n{\n\tvec3 p, c;\n};\n\nstruct material\n{\n\tvec3  dc, sc;\n\tfloat r, i, t;\n};\n\n\t\n\t\n//ray marching\nray      view(in vec2 uv);\nfloat \t map(in vec3 p);\nvec3     derive(in vec3 p, in float e);\nvoid \t emit(inout ray r, inout surface s, const int n);\n\n//distance functions\nvec3\t sphericalharmonic(vec3 n);\nfloat    sphere(vec3 p, float r);\n\n//rotation matrices\nmat2     rmat(float r);\nmat3     rmat(vec3 r);\n\nfloat map(vec3 p)\n{   \n\n\tp.xz    *= rmat(time*.5);\n\t\n \tvec2 d  = vec2(0., max(EPSILON, EPSILON+distance(VIEWPOINT,p)*2./resolution.x));\n\t\n\tvec3 nx = sphericalharmonic(p+d.yxx)-sphericalharmonic(p-d.yxx);\n\tvec3 ny = sphericalharmonic(p+d.xyx)-sphericalharmonic(p-d.xyx);\n\tvec3 nz = sphericalharmonic(p+d.xxy)-sphericalharmonic(p-d.xxy);\n\tvec3 n  = normalize(nx)*normalize(ny)*normalize(nz);\n\t\n\tfloat r = sphere(p, .5+length(n));\t\n\t\n\treturn r;\n}\n\nvoid main( void ) {\n\tvec2 uv    = gl_FragCoord.xy/resolution.xy;\n    \n\tray r      = view(uv);\n\tsurface s  = surface(0, r.o, vec3(0.), vec4(0.));    \n    \n\tlight l    = light(vec3(0.), vec3(0.));\n\tl.c        = vec3(.9, .87, .85);\n\tl.p        = LIGHTPOSITION;\n   \n    \t#ifdef LIGHTANIMATION\n    \tl.p.xz     *= rmat(TAU * mouse.x);\n   \t#endif\n \n    \temit(r, s, 256);\n\n  \tvec3 a = vec3(.5) * uv.y * .25;\n\n\tvec3 c = a;\n\tif(s.id != 0)\n\t{    \n\t\tmaterial m  = material(max(vec3(.25), normalize(s.p)), vec3(.5), .1, .1, 0.); \n\t    \tm.sc\t    += m.dc * .25;\n\t\t\n\t        s.n         = derive(s.p, r.e);\n        \tvec3 ld\t    = normalize(l.p-s.p);\n\t\tvec3 v      = VIEWPOINT-VIEWTARGET;\n\t\tvec3 h\t    = normalize(ld+v); \n\n\t\tfloat ndl   = max(0.0, dot(s.n, ld));\n\n\t        float hdn   = dot(h, s.n);\n        \tfloat d     = clamp(pow(hdn, 32.)*.6, 0., 1.);\n\t\tfloat f\t    = cos(dot(s.n, v))*.15;\n\t\t\n\t        c           = ndl * m.dc * l.c + f ;\n        \tc           += d * l.c * m.sc;\n\t        c           += clamp(c, 0., 1.);\n        \n     \t   \tc = mix(c, a, clamp(.25+r.i, 0., 1.));\n\n\t}\n\tc \t+= (.5+c) * r.i+r.i*.25;\n\t\n\tgl_FragColor = vec4(c, 1.);\n}//sphinx\n\n\nray view(in vec2 uv)\n{ \n\tfloat f = FOV;\n\tvec3  p = VIEWPOINT;\n\tvec3  t = VIEWTARGET;\n     \n\tuv     = uv * 2. - 1.;\n\tuv.x   *= resolution.x/resolution.y;\n    \n\tvec3 w = normalize(t-p);\n\tvec3 u = normalize(cross(w,vec3(0.,1.,0.)));\n\tvec3 v = normalize(cross(u,w));\n\tray r  = ray(0., 0., vec3(0.), vec3(0.));\n\tr.e    = PHI;\n\tr.i    = 0.;\n\tr.o    = p;\n\tr.d    = normalize(uv.x*u + uv.y*v + f*w);\n \n\treturn r;\n}\n\nvoid emit(inout ray r, inout surface s, const int n)\n{\n\tfloat ephi  = PHI;\n    \tfloat e     = 0.;\n    \tfloat pe    = 0.;\n    \tvec3 psp    = r.o;\n\t\n    \tfor(int i = 0; i < 256; i++)\n    \t{\n    \t  \tif (e < FARPLANE && i < n)\n\t\t{\n\t\t\tpsp   = s.p;\n        \t    \n\t\t\tif (r.e < ephi)\n\t\t\t{\n\t                \tr.e  = distance(r.o, s.p);\n        \t        \tr.i  = float(i)/float(n);\n\t        \t        s.id = 1;\n\t\t              \tbreak;\n\t\t\t}\n           \n        \t    s.p   = r.o + r.d * e;\n            \n        \t    r.e   = map(s.p);\n\t            ephi  *= 1.02;            \n        \t    e     += r.e * .8;\n            \n\t            s.p   = r.e * pe < 0. ? mix(psp, s.p, -pe/(r.e-pe)) : s.p;\n        \t    pe    = r.e;\n        \t}\n\t        else\n        \t{\n\t            r.e  = distance(r.o, s.p);\n        \t    r.i  = float(i)/float(n);\n\t            s.id = 0;\n        \t    break;\n\t        }\n\t}\n}\n\nvec3 derive(in vec3 p, in float e)\n{\n\tvec2 d = vec2(0., max(EPSILON, EPSILON+e*2./resolution.x));\n\tvec3 n = vec3(0.);\n\tn.x = map(p+d.yxx)-map(p-d.yxx);\n\tn.y = map(p+d.xyx)-map(p-d.xyx);\n\tn.z = map(p+d.xxy)-map(p-d.xxy);\n\treturn normalize(n);\n}\n\nvec3 sphericalharmonic(vec3 n){ \n\t\n\t//coefficients\n\tvec4 x1 = vec4(1., 0., 0., 0.);\n\tvec4 y1 = vec4(0., 1., 0., 0.);\n\tvec4 z1 = vec4(0., 0., 1., 0.);\n\tvec4 x2 = vec4(0.71);\n\tvec4 y2 = vec4(0.71);\n\tvec4 z2 = vec4(0.71);\n\tvec3 w  = vec3(.71);\n\n\t\n\t//some random animation thereof\n\tvec3 t = time * vec3(.1, .3, .5);\n\t\n\tx1.xyz *= rmat(t.xyz);\n\ty1.xyz *= rmat(t.xzy);\n\tz1.xyz *= rmat(t.zyx);\n\tw      *= rmat(t.yxz);\n\tvec3 l1;\n\tvec3 l2;\n\tvec3 l3;\n\tvec4 n4 = vec4(n, 1.);\n\tl1.r = dot(x1,n4);\n\tl1.g = dot(y1,n4);\n\tl1.b = dot(z1,n4);\n\t\n\tvec4 m2 = n.xyzz * n.yzzx;\n\tl2.r = dot(x2,m2);\n\tl2.g = dot(y2,m2);\n\tl2.b = dot(z2,m2);\n\t\n\tfloat m3 = n.x*n.x - n.y*n.y;\n\tl3 = w * m3;\n    \t\n\tvec3 sh = vec3(l1 + l2 + l3);\n\t\n\treturn sh;\n}\n\n//primitives\nfloat sphere(vec3 p, float r){\n\treturn length(p)-r;\t\t\n}\n\n//rotation matrices\nmat2 rmat(float r)\n{\n\tfloat c = cos(r);\n\tfloat s = sin(r);\n\treturn mat2(c, s, -s, c);\n}\n\nmat3 rmat(vec3 r)\n{\n\tvec3 a = vec3(cos(r.x)*cos(r.y),-sin(r.y),sin(r.x)*cos(r.y));\n\t\n\tfloat c = cos(r.z);\n\tfloat s = sin(r.z);\n\tvec3 as  = a*s;\n\tvec3 ac  = a*a*(1.- c);\n\tvec3 ad  = a.yzx*a.zxy*(1.-c);\n\tmat3 rot = mat3(\n\t\tc    + ac.x, \n        ad.z - as.z, \n        ad.y + as.y,\n\t\tad.z + as.z, \n        c    + ac.y, \n        ad.x - as.x,\n\t\tad.y - as.y, \n        ad.x + as.x, \n        c    + ac.z);\n\n\treturn rot;\t\n}", "user": "ff98f76", "parent": "/e#10483.0", "id": "18352.0"}