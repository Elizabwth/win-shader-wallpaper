{"code": "/*\nCode for the 4k procedural graphics Slisesix from the demoscene \n(http://www.pouet.net/prod.php?which=51074).\nIt made 1st position in the Euskal Party 2008 in Bilbao (Spain).\nIt's raymarching in a procedural distance field\n*/\n// port by @rotwang *** help needed ***\n// removing unsupported stuff like \n// if( (((submat>>10)&7)>6) )\n\n#extension GL_EXT_gpu_shader4: enable\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\nuniform sampler2D tex0;\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nint icoolfFunc3d2( in int n )\n{\n   // n=(n<<13)^n;\n   // return (n*(n*n*15731+789221)+1376312589) & 0x7fffffff;\n\tfloat st = random( vec2(n));\n\treturn int(st);\n}\n\nfloat coolfFunc3d2( in int n )\n{\n    return float(icoolfFunc3d2(n));\n}\n\nfloat noise3f( in vec3 p )\n{\n    ivec3 ip = ivec3(floor(p));\n    vec3 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    int n = ip.x + ip.y*57 + ip.z*113;\n\n    float res = mix(mix(mix(coolfFunc3d2(n+(0+57*0+113*0)),\n                            coolfFunc3d2(n+(1+57*0+113*0)),u.x),\n                        mix(coolfFunc3d2(n+(0+57*1+113*0)),\n                            coolfFunc3d2(n+(1+57*1+113*0)),u.x),u.y),\n                    mix(mix(coolfFunc3d2(n+(0+57*0+113*1)),\n                            coolfFunc3d2(n+(1+57*0+113*1)),u.x),\n                        mix(coolfFunc3d2(n+(0+57*1+113*1)),\n                            coolfFunc3d2(n+(1+57*1+113*1)),u.x),u.y),u.z);\n\n    return 1.0 - res*(1.0/1073741824.0);\n}\n\nfloat fbm( in vec3 p )\n{\n    return 0.5000*noise3f(p*1.0) +\n           0.2500*noise3f(p*2.0) +\n           0.1250*noise3f(p*4.0) +\n           0.0625*noise3f(p*8.0);\n}\n\n\nfloat techo( in float x, in float y )\n{\n    y = 1.0 - y;\n    if( x<0.1 || x>0.9 ) return y;\n    x = x - 0.5;\n    return -(sqrt(x*x+y*y)-0.4);\n}\n\n\nfloat distToBox( in vec3 p, in vec3 abc )\n{\n    vec3 di=max(abs(p)-abc,0.0);\n    return dot(di,di);\n}\n\n\nfloat columna( in float x, in float y, in float z, in float mindist, in float offx )\n{\n    vec3 p=vec3(x,y,z);\n    float di0=distToBox( p, vec3(0.14,1.0,0.14) );\n    if( di0 > (mindist*mindist) ) return mindist + 1.0;\n\n    float y2=y-0.40;\n    float y3=y-0.35;\n    float y4=y-1.00;\n\n    float di1=distToBox( p, vec3(0.10,1.00,0.10) );\n    float di2=distToBox( p, vec3(0.12,0.40,0.12) );\n    float di3=distToBox( p, vec3(0.05,0.35,0.14) );\n    float di4=distToBox( p, vec3(0.14,0.35,0.05) );\n    float di9=distToBox( vec3(x,y4,z), vec3(0.14,0.02,0.14) );\n\n    float di5=distToBox( vec3((x-y2)*0.7071, (y2+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.12) );\n    float di6=distToBox( vec3(x, (y2+z)*0.7071, (z-y2)*0.7071), vec3(0.12,  0.10*0.7071, 0.10*0.7071) );\n    float di7=distToBox( vec3((x-y3)*0.7071, (y3+x)*0.7071, z), vec3(0.10*0.7071,  0.10*0.7071, 0.14) );\n    float di8=distToBox( vec3(x, (y3+z)*0.7071, (z-y3)*0.7071), vec3(0.14,  0.10*0.7071, 0.10*0.7071) );\n\n    float di=min(min(min(di1,di2),min(di3,di4)),min(min(di5,di6),min(di7,di8)));\n    di=min(di,di9);\n\n  //  di += 0.00000003*max( fbm(10.1*p), 0.0);\n\n    return di;\n}\n\n\n\nfloat bicho( vec3 x, in float mindist )\n{\n//    float ramo = noise3f( vec3(2.0*time, 2.3*time, 0.0) );\n\n    x -= vec3(0.64,0.5,1.5);\n\n    float r2 = dot(x,x);\n\n    float sa = smoothstep(0.0,0.5,r2);\n    float fax = 0.75 + 0.25*sa;\n    float fay = 0.80 + 0.20*sa;\n\n    x.x *= fax;\n    x.y *= fay;\n    x.z *= fax;\n\n    r2 = dot(x,x);\n\n    float r = sqrt(r2);\n\n    float a1 = 1.0-smoothstep( 0.0, 0.75, r );\n    a1 *= 0.40;\n    float si1 = sin(a1);\n    float co1 = cos(a1);\n    x.xy = mat2(co1,si1,-si1,co1)*x.xy;\n\n\n    float mindist2 = 100000.0;\n\n    float rr = 0.05+sqrt(dot(x.xz,x.xz));\n    float ca = (0.5-0.045*0.75) -6.0*rr*exp2(-10.0*rr);\n    for( int j=1; j<7; j++ )\n    {\n        float an = (6.2831/7.0) * float(j);\n        float aa = an + 0.40*rr*noise3f( vec3(4.0*rr, 2.5, an) ) + 0.29;\n        float rc = cos(aa);\n        float rs = sin(aa);\n        vec3 q = vec3( x.x*rc-x.z*rs, x.y+ca, x.x*rs+x.z*rc );\n        float dd = dot(q.yz,q.yz);\n        if( q.x>0.0 && q.x<1.5 && dd<mindist2 ) mindist2=dd;\n    }\n\n    float c = sqrt(mindist2) - 0.045;\n    float d = r-0.30;\n    float a = clamp( r*3.0, 0.0, 1.0 );\n    return c*a + d*(1.0-a);\n}\n\n\nfloat map( in vec3 pos, out int sid, out int submat )\n{\n    submat = 0;\n    float dis, mindist;\n\n    //-----------------------\n    // suelo\n    //-----------------------\n    dis = pos.y;\n    vec2 axz = vec2(128.0) + 6.0*vec2(pos.x+pos.z,pos.x-pos.z);\n    ivec2 ixz = ivec2( floor(axz) );\n    submat = icoolfFunc3d2(ixz.x+53*ixz.y);\n    vec2 peldxz = fract( axz );\n    float peld = smoothstep( 0.975, 1.0, max( peldxz.x, peldxz.y ) );\n\t\n//\tif( (((submat>>10)&7)>6) )\n    if( submat>3 )\n    {\n\t    peld = 1.0;\n    }\n    dis += 0.005*peld;\n    mindist = dis;\n    sid = 0;\n    if( peld>0.0000001 ) sid = 2;\n\n    //-----------------------\n    // techo\n    //-----------------------\n    float fx = fract( pos.x+128.0 );\n    float fz = fract( pos.z+128.0 );\n    if( pos.y>1.0 )\n    {\n        dis = max(techo(fx,pos.y),techo(fz,pos.y));\n        if( dis<mindist )\n        {\n            mindist = dis;\n            sid = 5;\n        }\n    }\n    fx = fract( pos.x+128.0+.5 );\n    fz = fract( pos.z+128.0+.5 );\n\n    //-----------------------\n    // columnas\n    dis = columna( fx-.5, pos.y, fz-.5, mindist, 13.1*floor(pos.x)+17.7*floor(pos.z) );\n    if( dis<(mindist*mindist) )\n    {\n        mindist = sqrt(dis);\n        sid = 1;\n    }\n\n    //-----------------------\n    // bicho\n    //-----------------------\n\n    dis = bicho( pos, mindist );\n    if( dis<mindist )\n    {\n        mindist = dis;\n        sid = 4;\n    }\n    //-----------------------\n\n    return mindist;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    float eps = 0.0002;\n    vec3 nor;\n    int kk, kk2;\n    nor.x = map( vec3(pos.x+eps, pos.y, pos.z), kk, kk2 ) - map( vec3(pos.x-eps, pos.y, pos.z), kk, kk2 );\n    nor.y = map( vec3(pos.x, pos.y+eps, pos.z), kk, kk2 ) - map( vec3(pos.x, pos.y-eps, pos.z), kk, kk2 );\n    nor.z = map( vec3(pos.x, pos.y, pos.z+eps), kk, kk2 ) - map( vec3(pos.x, pos.y, pos.z-eps), kk, kk2 );\n    return normalize( nor );\n}\n\n\n\nvoid main(void)\n{\n    vec2 pixel = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;\n    float an = time*0.15;\n    vec2 sc = vec2(cos(an),sin(an));\n\n    float r2 = pixel.x*pixel.x*0.32 + pixel.y*pixel.y;\n    float tt = (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    pixel *= tt;\n\n    float asp = resolution.x/resolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x*sc.x-sc.y,pixel.y,sc.x+asp*pixel.x*sc.y));\n    vec3 ro = vec3(0.5+1.4*sc.y,0.5,1.5-1.4*sc.x);\n\n    float t=0.5;\n    int matID=666;\n    int subMatID;\n    vec3 pos;\n    vec3 rgb = vec3(0.0);\n\n    // cast ray\n   int nt=0;\n   // for( t=0.5; t<12.0; )\n\tfor( int nt=0; nt<60; nt++)\n    {\n        pos = ro + t*rd;\n        float h = map( pos, matID, subMatID );\n        if( h<0.01 )\n\t\tbreak;\n        t += h;\n        if( t>12.0 )\n\t\tbreak;\n    }\n    \n\n    // shade\n    if( matID!=666 )\n    {\n        // calc normal\n        vec3 nor = calcNormal(pos);\n\n\n        // bump mapping\n        float kke=0.0001;\n        float bumpa=0.0075;\n        if( matID!=5 ) bumpa*=0.75;\n        if( matID==4 ) bumpa*=0.50;\n        bumpa /= kke;\n        float kk = fbm(32.0*pos);\n        nor.x += bumpa*(fbm(32.0*vec3(pos.x+kke, pos.y, pos.z))-kk);\n        nor.y += bumpa*(fbm(32.0*vec3(pos.x, pos.y+kke, pos.z))-kk);\n        nor.z += bumpa*(fbm(32.0*vec3(pos.x, pos.y, pos.z+kke))-kk);\n        nor = normalize(nor);\n\n        // light\n        float spe = 0.0;\n        vec3 lig = vec3( 0.5-pos.x, 0.8-pos.y, 1.5-pos.z );\n        float llig = dot(lig,lig);\n        float im = inversesqrt(llig);\n        lig = lig * im;\n        float dif = dot(nor,lig);\n        if( matID==4 )\n            {dif=0.5+0.5*dif;}\n        else\n            {dif=0.1+0.9*dif;}\n        //if( dif<0.0 ) dif=0.0;\n    \t//dif=max(dif,0.0);\n    \tdif = clamp(dif,0.0,1.0);\n    \tdif *= 2.5*exp2(-1.75*llig);\n    \tfloat dif2=(nor[0]+nor[1])*0.075;\n\n\n        // materials\n        if( matID==0 )\n        {\n\t\t//float xoff = 13.1*float(subMatID&255);\n            float xoff = 13.1*float(subMatID);\n            float fb = fbm(16.0*vec3(pos.x+xoff,pos.y,pos.z));\n            rgb = vec3(0.7) + fb*vec3(0.20,0.22,0.25);\n\n           // float baldscale = float((subMatID>>9)&15)/14.0;\n\t\tfloat baldscale = float(subMatID)/14.0;\n            baldscale = 0.51 + 0.34*baldscale;\n            rgb *= baldscale;\n            float fx = 1.0;\n\t\t\n\t\t//if( (subMatID&256)!=0 )\n            if( (subMatID)!=0 )\n\t\t    fx = -1.0;\n\t\t\n            float m = sin( 64.0*pos.z*fx +  64.0*pos.x + 4.0*fb );\n            m = smoothstep( 0.25, 0.5, m ) - smoothstep( 0.5, 0.75, m );\n            rgb += m*vec3(0.15);\n        }\n        else if( matID==2 )\n        {\n            rgb = vec3(0.0);\n        }\n        else if( matID==1 )\n        {\n            float fb = fbm( 16.0*pos );\n            float m = sin( 64.0*pos.z +  64.0*pos.x + 4.0*fb );\n            m = smoothstep( 0.30, 0.5, m ) - smoothstep( 0.5, 0.70, m );\n            rgb = vec3(0.59) + fb*vec3(0.17,0.18,0.21) + m*vec3(0.15) + vec3(dif2);\n        }\n        else if( matID==4 )\n        {\n            float ft = fbm( 16.0*pos );\n            rgb = vec3(0.82,0.73,0.65) + ft*vec3(0.1);\n\n            float fs = 0.9+0.1*fbm( 32.0*pos );\n            rgb *= fs;\n\n            float fre = max( -dot( nor, rd ), 0.0);\n            rgb -= vec3(fre*fre*0.45);\n            spe = clamp((nor.y-nor.z)*0.707,0.0,1.0);\n            spe = 0.20*pow(spe,32.0);\n        }\n        // techo\n        else //if( matID==5 )\n        {\n            float fb = fbm( 16.0*pos );\n            rgb = vec3(0.64,0.61,0.59) + fb*vec3(0.21,0.19,0.19) + dif2;\n        }\n    \n        // AO\n        float ao;\n        float totao = 0.0;\n        float sca = 10.0;\n        for( int aoi=0; aoi<5; aoi++ )\n        {\n            float hr = 0.01 + 0.015*float(aoi*aoi);\n            vec3 aopos =  nor * hr + pos;\n            int kk, kk2;\n            float dd = map( aopos, kk, kk2 );\n            ao = -(dd-hr);\n            totao += ao*sca;\n            sca *= 0.5;\n        }\n        ao = 1.0 - clamp( totao, 0.0, 1.0 );\n    \n        // shadow\n        float so = 0.0;\n        for( int i=0; i<6; i++ )\n        {\n            float h = float(i)/6.0;\n            float hr = 0.01 + h;\n            vec3 aopos = lig * hr + pos;\n            int kk, kk2;\n            float dd = map( aopos, kk, kk2 );\n            so += (1.0-h)*dd*2.0 * (10.0/6.0);\n        }\n        dif *= clamp( (so-0.40)*1.5, 0.0, 1.0 );\n    \n        // lighting\n        rgb = vec3(spe) + rgb * (ao*vec3(0.25,0.30,0.35) + dif*vec3(1.95,1.65,1.05));\n        // fog\n        rgb = rgb * exp2( -0.4*t );\n    }\n\n    // color correct\n    rgb =(sqrt(rgb)*0.7+0.3*rgb)*vec3(0.83,1.0,0.83)*1.2;\n\n    // vigneting\n    rgb *= 0.25+0.75*clamp(0.60*abs(pixel.x-1.0)*abs(pixel.x+1.0),0.0,1.0);\n\n    gl_FragColor=vec4(rgb,1.0);\n}", "user": "38db6be", "parent": null, "id": "4456.7"}