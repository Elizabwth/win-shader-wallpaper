{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\n// fuck minecraft!\n// warped by weylandyutani amsterdam 2012\n\t\n#define pi 3.1415\n//Landscape\n\t\nfloat random(vec4 seed)\n{\n \treturn fract(sin(dot(seed.xy ,vec2(1.9898,78.233)) + dot(seed.zw ,vec2(15.2472,93.2541))) * 43758.5453);\n}\n\nfloat floorTo(float value, float factor)\n{\n \treturn floor(value / factor) * factor;\n}\n\nvec2 floorTo(vec2 value, vec2 factor)\n{\n \treturn vec2(floorTo(value.x, factor.x), floorTo(value.y, factor.y));\n}\n\nfloat lerp(float x, float X, float amount, bool usecos)\n{\n\t if(usecos)\n\t {\n\t  \treturn x + (X - x) * ((cos(amount * pi) - 1.0 ) / -2.0);\n\t }\n\t else\n\t {\n\t  \treturn x + (X - x) * amount;\n\t }\n}\n\nfloat bilerp(float xy, float Xy, float xY, float XY, vec2 amount, bool usecos)\n{\n \tfloat x = lerp(xy, xY, amount.y, usecos);\n \tfloat X = lerp(Xy, XY, amount.y, usecos);\n\treturn lerp(x, X, amount.x, usecos);\n}\n\nfloat getBilerp(vec2 position, vec2 size, float seed, bool usecos)\n{\n \tvec2 min = floorTo(position, size);\n \tvec2 max = min + size;\n \n \treturn bilerp(random(vec4(min.x, min.y, seed, seed)),\n   \t\trandom(vec4(max.x, min.y, seed, seed)),\n   \t\trandom(vec4(min.x, max.y, seed, seed)),\n   \t\trandom(vec4(max.x, max.y, seed, seed)),\n   \t\t(position - min) / size, usecos);\n}\n\nbool ShouldDraw(vec3 voxel)\n{\n\treturn voxel.y < random( vec4( voxel.x, voxel.z, 4.4235, 0.3481 ) ) * 4.0+sin(time/20.0);\n}\n\nvoid IterateVoxel(inout vec3 voxel, Ray ray, out vec3 hitPoint)\n{\n\tfloat maxX = 0.0;\n\tfloat maxY = 0.0;\n\tfloat maxZ = 0.0;\n\t\n\t\t\n\tif(ray.Direction.x != 0.0)\n\t{\n\t\tmaxX = max((voxel.x - ray.Origin.x) / ray.Direction.x, (voxel.x + 1.0 - ray.Origin.x) / ray.Direction.x);\n\t}\n\tif(ray.Direction.y != 0.0)\n\t{\n\t\tmaxY = max((voxel.y - ray.Origin.y) / ray.Direction.y, (voxel.y + 1.0 - ray.Origin.y) / ray.Direction.y);\n\t}\n\tif(ray.Direction.z != 0.0)\n\t{\n\t\tmaxZ = max((voxel.z - ray.Origin.z) / ray.Direction.z, (voxel.z + 1.0 - ray.Origin.z) / ray.Direction.z);\n\t}\n\t\n\tif(maxX < min(maxY, maxZ))\n\t{\n\t\tvoxel.x += sign(ray.Direction.x);\n\t\thitPoint = vec3(1,0,0);\n\t}\n\tif(maxY < min(maxX, maxZ))\n\t{\n\t\tvoxel.y += sign(ray.Direction.y);\n\t\thitPoint = vec3(0,1,0);\n\t}\n\tif(maxZ < min(maxX, maxY))\n\t{\n\t\tvoxel.z += sign(ray.Direction.z);\n\t\thitPoint = vec3(0,0,1);\n\t}\n}\n\t\nvec4 GetRayColor(Ray ray)\n{\n\tvec3 voxel = ray.Origin - fract(ray.Origin);\n\tvec3 hitPoint;\n\t\n\tfor(int i=0;i<70/*CAREFUL WITH THIS!!!*/;i++)\n\t{\n\t\tif(ShouldDraw(voxel))\n\t\t{\n\t\t\treturn vec4(1.0, 0.6, 1.0*sin(time/20.0), 1.0) * abs( dot( hitPoint, ray.Direction ) *ray.Direction.y*2.0);\n\t\t}\n\t\t\n\t\tIterateVoxel(voxel, ray, hitPoint);\n\t}\n\t\n\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvoid GetCameraRay(const in vec3 position, const in vec3 lookAt, out Ray currentRay)\n{\n\tvec3 forwards = normalize(lookAt - position);\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n\t\n\t\n\tvec2 uV = ( gl_FragCoord.xy / resolution.xy );\n\tvec2 viewCoord = uV * 2.0 - 1.0;\n\t\n\tfloat ratio = resolution.x / resolution.y;\n\t\n\tviewCoord.y /= ratio;                              \n\t\n\tcurrentRay.Origin = position;\n\t\n\tvec3 right = normalize(cross(forwards, worldUp));\n\tvec3 up = cross(right, forwards);\n\t       \n\tcurrentRay.Direction = normalize( right * viewCoord.x + up * viewCoord.y + forwards);\n}\n\nvoid main( void ) \n{\n\tRay currentRay;\n \n\tGetCameraRay(vec3(10.1*sin(time*0.1), 12.1, 10.1*cos(time*0.1)), vec3(0.0, 1.0*sin(time/3.0), 1.0*sin(time/2.0)), currentRay);\n\n\tgl_FragColor = GetRayColor(currentRay);\n}", "user": "61ab05e", "parent": "/e#1491.2", "id": "4272.1"}