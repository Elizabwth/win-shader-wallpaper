{"code": "// Copyright (c) 2013 Andrew Baldwin (baldand)\n// License = Attribution-NonCommercial-ShareAlike (http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\n\n// \"Mirror Cube\"\n// A simple ray tracer and a simple scene - one cube\n// Gigatron for glslsandbox ./.\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n\nconst vec3 up = vec3(0.,1.,0.);\n\nfloat intersectfloor(vec3 ro, vec3 rd, float height, out float t0)\n{\t\n\tif (rd.y==0.0) {\n\t\tt0 = 100000.0;\n\t\treturn 0.0;\n\t}\n\t\n\tt0 = -(ro.y - height)/rd.y;\n\tt0 = min(100000.0,t0);\n\treturn t0;\n}\n\nfloat intersectbox(vec3 ro, vec3 rd, float size, out float t0, out float t1, out vec3 normal)\n// Calculate intersections with origin-centred axis-aligned cube with sides length size\n// Returns positive value if there are intersections\n{\n    vec3 ir = 1.0/rd;\n    vec3 tb = ir * (vec3(-size*.5)-ro);\n    vec3 tt = ir * (vec3(size*.5)-ro);\n    vec3 tn = min(tt, tb);\n    vec3 tx = max(tt, tb);\n    vec2 t = max(tn.xx, tn.yz);\n    t0 = max(t.x, t.y);\n    t = min(tx.xx, tx.yz);\n    t1 = min(t.x, t.y);\n\tfloat d = (t1-t0);\n\tvec3 i = ro + t0*rd;\n\tnormal = step(size*.499,abs(i))*sign(i);\n\tif (t0<-0.1) d = t0;\n\treturn d;\n}\n\nfloat intersect(vec3 boxPos, vec3 ro, vec3 rd, out vec3 intersection, out vec3 normal, out int material, out float t) \n{\n\tfloat tb0=0.0;\n\tfloat tb1=0.0;\n\tvec3 boxnormal;\n\tfloat dbox = intersectbox(ro-boxPos,rd,1.,tb0,tb1,boxnormal);\n\tfloat tf = 0.0;\n\tfloat dfloor = intersectfloor(ro,rd,0.,tf);\n\tt = tf;\n\tfloat d = dfloor;\n\tmaterial = 4; // Sky\n\tif (d>=0.) {\n\t\tnormal = vec3(0.,1.,0.);\n\t\tmaterial = 2; // Floor\n\t}\n\tif (dbox>=0.) {\n\t\tt = tb0;\n\t\td = dbox;\n\t\tnormal = boxnormal;\n\t\tmaterial = 1; // Box\n\t\tif (t<0.) d=-0.1;\n\t}\n\tintersection = ro+t*rd;\n\treturn d;\n}\n\t\t\t\t\nvoid main()\n{\n\tfloat rotspeed = time*1.+mouse.x/resolution.x;\n\tvec3 light = vec3(5.,4.+3.*sin(-rotspeed*.4),2.);\n\tfloat radius = sin(rotspeed*.1)*2.+4.;\n\tvec3 boxPos = vec3(0.3,1.5*abs(sin(rotspeed)),0.2);// bounce please\n\tvec3 eye = vec3(radius*sin(rotspeed),2.*sin(.1*rotspeed)+2.5+2.*mouse.y/resolution.y,radius*cos(rotspeed*1.));\n\tvec3 screen = vec3((radius-1.)*sin(rotspeed),1.5*sin(.1*rotspeed)+2.+2.*mouse.y/resolution.y,(radius-1.)*cos(rotspeed*1.));\n        vec2 screenSize = vec2(resolution.x/resolution.y,1.0);\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec2 offset = screenSize * (uv - 0.5);\n\tvec3 right = cross(up,normalize(screen - eye));\n\tvec3 ro = screen + offset.y*up + offset.x*right;\n\tvec3 rd = normalize(ro - eye);\n\tvec3 i = vec3(0.);\n\tvec3 n = vec3(0.);\n\tint m,m2;\n\tfloat d,lightd,ra,global,direct,shade,t,tlight;\n\tvec3 lrd,i2,n2;\n\tvec3 c=vec3(0.);\n\tvec3 ca=vec3(0.);\n\tfloat lra=1.;\n\tfor (int reflections=0;reflections<10;reflections++) {\n\t\t// Find the direct ray hit\n\t\td = intersect(boxPos,ro,rd,i,n,m,t);\n\t\t// Check for shadows to the light\n\t\tlrd = normalize(light-i);\n\t\ttlight = length(light-i);\n\t\tlightd = smoothstep(.5*length(i-i2),.0,intersect(boxPos,i,lrd,i2,n2,m2,t));\n\t\tif (t>tlight) lightd=1.0;\n\t\t// Colouring\n\t\tglobal = .3;\n\t\tdirect = max( (10./length(lrd)) * dot( lrd, n) ,0.0);\n\t\tshade = global + direct*lightd;\n\t\tif (m==0) { ra=0.0; c = vec3(0.9,2.0,2.5); }\n\t\tif (m==1) { ra=0.2; c = shade*(.5+.5*(i-boxPos)); }\n\t\tif (m==2) {\n\t\t\tra = 0.3;\n\t\t\tvec2 mxz = abs(fract(i.xz)*2.-1.);\n\t\t\tfloat fade = clamp(1.-length(i.xz)*.05,0.,1.);\n\t\t\tfloat fc =mix(.5,smoothstep(1.,.9,mxz.x+mxz.y),fade);\n\t\t\tc = vec3(fc*shade);\n\t\t}\n\t\t// Calculate any reflection on the next iteration\n\t\tca += lra*c;\n\t\tlra *= ra;\n\t\trd = reflect(rd,n);\n\t\tro = i+0.01*rd;\n\t}\n\tgl_FragColor = vec4(ca/(1.+ca),1.);\n}", "user": "c5d8d74", "parent": "/e#25463.1", "id": "25869.0"}