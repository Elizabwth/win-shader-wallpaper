{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nstruct Ray\n{\n\tvec3 Origin;\n\tvec3 Direction;\n};\n\n// minecraft flickers!\n// warped by weylandyutani amsterdam 2012\n\t\n// (Kabuto) made this a bit more minecraft-like ;-)\tspeed-optimized by selectively both blob-based and voxel-based raymarching\n\n// Start simplex noise\n\n\t//\n\t// Description : Array and textureless GLSL 2D/3D/4D simplex\n\t// noise functions.\n\t// Author : Ian McEwan, Ashima Arts.\n\t// Maintainer : ijm\n\t// Lastmod : 20110822 (ijm)\n\t// License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n\t// Distributed under the MIT License. See LICENSE file.\n\t// https://github.com/ashima/webgl-noise\n\t//\n\t// Modified by Kabuto to return the derivative as well\n\t//\n\t\n\t\n\tvec4 permute(vec4 x) {\n\t     return mod(((x*34.0)+1.0)*x, 289.0);\n\t}\n\t\n\tvec4 taylorInvSqrt(vec4 r)\n\t{\n\t  return 1.79284291400159 - 0.85373472095314 * r;\n\t}\n\t\n\t// modified perlin noise, giving value in w and derivative in xyz\n\tfloat snoise(vec3 v)\n\t  {\n\t  const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;\n\t  const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\t\n\t// First corner\n\t  vec3 i = floor(v + dot(v, C.yyy) );\n\t  vec3 x0 = v - i + dot(i, C.xxx) ;\n\t\n\t// Other corners\n\t  vec3 g = step(x0.yzx, x0.xyz);\n\t  vec3 l = 1.0 - g;\n\t  vec3 i1 = min( g.xyz, l.zxy );\n\t  vec3 i2 = max( g.xyz, l.zxy );\n\t\n\t  // x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t  // x1 = x0 - i1 + 1.0 * C.xxx;\n\t  // x2 = x0 - i2 + 2.0 * C.xxx;\n\t  // x3 = x0 - 1.0 + 3.0 * C.xxx;\n\t  vec3 x1 = x0 - i1 + C.xxx;\n\t  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\t  vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y\n\t\n\t// Permutations\n\t  i = mod(i,289.0);\n\t  vec4 p = permute( permute( permute(\n\t\t     i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\t\t   + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\t\t   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\t\n\t// Gradients: 7x7 points over a square, mapped onto an octahedron.\n\t// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n\t  float n_ = 0.142857142857; // 1.0/7.0\n\t  vec3 ns = n_ * D.wyz - D.xzx;\n\t\n\t  vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)\n\t\n\t  vec4 x_ = floor(j * ns.z);\n\t  vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)\n\t\n\t  vec4 x = x_ *ns.x + ns.yyyy;\n\t  vec4 y = y_ *ns.x + ns.yyyy;\n\t  vec4 h = 1.0 - abs(x) - abs(y);\n\t\n\t  vec4 b0 = vec4( x.xy, y.xy );\n\t  vec4 b1 = vec4( x.zw, y.zw );\n\t\n\t  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n\t  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n\t  vec4 s0 = floor(b0)*2.0 + 1.0;\n\t  vec4 s1 = floor(b1)*2.0 + 1.0;\n\t  vec4 sh = -step(h, vec4(0.0));\n\t\n\t  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\t  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\t\n\t  vec3 p0 = vec3(a0.xy,h.x);\n\t  vec3 p1 = vec3(a0.zw,h.y);\n\t  vec3 p2 = vec3(a1.xy,h.z);\n\t  vec3 p3 = vec3(a1.zw,h.w);\n\t\n\t//Normalise gradients\n\t  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\t  p0 *= norm.x;\n\t  p1 *= norm.y;\n\t  p2 *= norm.z;\n\t  p3 *= norm.w;\n\t\n\t// Mix final noise value\n\t  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\t  m = m * m;\n\t return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );\n\t\t  \n\t// derivatives\n\t /* vec3 dx = vec3(0.001, 0, 0);\n\t  vec4 mx = max(0.6 - vec4(dot(x0+dx,x0+dx), dot(x1+dx,x1+dx), dot(x2+dx,x2+dx), dot(x3+dx,x3+dx)), 0.0);\n\t  mx = mx * mx;\n\t  float wx = 42.0 * dot( mx*mx, vec4( dot(p0,x0+dx), dot(p1,x1+dx), dot(p2,x2+dx), dot(p3,x3+dx) ) );\n\n\t  vec3 dy = vec3(0, 0.001, 0);\n\t  vec4 my = max(0.6 - vec4(dot(x0+dy,x0+dy), dot(x1+dy,x1+dy), dot(x2+dy,x2+dy), dot(x3+dy,x3+dy)), 0.0);\n\t  my = my * my;\n\t  float wy = 42.0 * dot( my*my, vec4( dot(p0,x0+dy), dot(p1,x1+dy), dot(p2,x2+dy), dot(p3,x3+dy) ) );\n\n\t  vec3 dz = vec3(0, 0, 0.001);\n\t  vec4 mz = max(0.6 - vec4(dot(x0+dz,x0+dz), dot(x1+dz,x1+dz), dot(x2+dz,x2+dz), dot(x3+dz,x3+dz)), 0.0);\n\t  mz = mz * mz;\n\t  float wz = 42.0 * dot( mz*mz, vec4( dot(p0,x0+dz), dot(p1,x1+dz), dot(p2,x2+dz), dot(p3,x3+dz) ) );\n\t\t  \n\treturn vec4((wx-w)*100.0, (wy-w)*100.0, (wz-w)*100.0, w);*/\n\t  }\n\n// End simplex noise\n\t\n#define pi 6.1415\n//Landscape\n\t\nfloat random(vec4 seed)\n{\n \treturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)) + dot(seed.zw ,vec2(15.2472,93.2541))) * 43758.5453);\n}\n\nfloat floorTo(float value, float factor)\n{\n \treturn floor(value / factor) * factor;\n}\n\nvec2 floorTo(vec2 value, vec2 factor)\n{\n \treturn vec2(floorTo(value.x, factor.x), floorTo(value.y, factor.y));\n}\n\nfloat lerp(float x, float X, float amount, bool usecos)\n{\n\t if(usecos)\n\t {\n\t  \treturn x + (X - x) * ((cos(amount * pi) - 1.0 ) / -2.0);\n\t }\n\t else\n\t {\n\t  \treturn x + (X - x) * amount;\n\t }\n}\n\nfloat bilerp(float xy, float Xy, float xY, float XY, vec2 amount, bool usecos)\n{\n \tfloat x = lerp(xy, xY, amount.y, usecos);\n \tfloat X = lerp(Xy, XY, amount.y, usecos);\n\treturn lerp(x, X, amount.x, usecos);\n}\n\nfloat getBilerp(vec2 position, vec2 size, float seed, bool usecos)\n{\n \tvec2 min = floorTo(position, size);\n \tvec2 max = min + size;\n \n \treturn bilerp(random(vec4(min.x, min.y, seed, seed)),\n   \t\trandom(vec4(max.x, min.y, seed, seed)),\n   \t\trandom(vec4(min.x, max.y, seed, seed)),\n   \t\trandom(vec4(max.x, max.y, seed, seed)),\n   \t\t(position - min) / size, usecos);\n}\n\nvec2 getTunnelCoords(float z) {\n\treturn vec2(cos(z*0.03)*6.0 + cos(z*0.023)*12.0, cos(z*0.02)*6.0);\n}\n\n// > 0 -> void, < 0 -> solid. if > 0 it should be the approximate distance to nearest solid.\nfloat ShouldDraw(vec3 voxel)\n{\t\n\tvec2 tunnel = getTunnelCoords(voxel.z);\n\tfloat tx = voxel.x - tunnel.x;\n\tfloat ty = voxel.y - tunnel.y;\n\treturn max(2.-sqrt(tx*tx+ty*ty), (5. + ty*.4 + snoise(voxel*.03)*5. - 1. + snoise(voxel*.01)*12.));\n}\n\n//currently returns one of 4 stone types\nfloat getStoneType(vec3 voxel) {\n\tfloat s1 = snoise(voxel*.01);\n\tfloat s2 = snoise(voxel*.007);\n\treturn mix(sign(s1)*.5+2.5, sign(s2)*.5+.5, step(abs(s1*.2),abs(s2)));\n}\n\n\nvoid IterateVoxel(inout vec3 voxel, Ray ray, out vec3 hitPoint, out vec3 actual)\n{\t\n\tvec3 stp = voxel + step(vec3(0), ray.Direction) - ray.Origin;\n\tvec3 max = stp / ray.Direction;\n\t\n\tif(max.x < min(max.y, max.z)) {\n\t\tvoxel.x += sign(ray.Direction.x);\n\t\thitPoint = vec3(1,0,0);\n\t\tactual = stp.x/ray.Direction.x*ray.Direction + ray.Origin;\n\t} else if(max.y < max.z) {\n\t\tvoxel.y += sign(ray.Direction.y);\n\t\thitPoint = vec3(0,1,0);\n\t\tactual = stp.y/ray.Direction.y*ray.Direction + ray.Origin;\n\t} else {\n\t\tvoxel.z += sign(ray.Direction.z);\n\t\thitPoint = vec3(0,0,1);\n\t\tactual = stp.z/ray.Direction.z*ray.Direction + ray.Origin;\n\t}\n}\n\t\nvec3 getColorAt(vec3 voxel, vec3 actual, vec3 hitPoint, Ray ray) {\n\tconst float lightDist = 55.0;\n\tfloat lightNum = voxel.z/lightDist+1e-5;\n\tfloat lightFrac = fract(lightNum);\n\tlightNum -= lightFrac;\n\tfloat lightZ = lightNum*lightDist;\n\tvec3 light = vec3(getTunnelCoords(lightZ), lightZ);\n\tvec3 lv = light-voxel;\n\tfloat lvl = length(lv);\n\tfloat light2 =( dot( hitPoint, lv )/lvl+1.2) / (lvl*lvl);\n\tfloat totallight = light2*(1.-lightFrac);\n\t\n\tlightNum += 1.;\n\tlightZ += lightDist;\n\tlight = vec3(getTunnelCoords(lightZ), lightZ);\n\tlv = light-voxel;\n\tlvl = length(lv);\n\tlight2 =( dot( hitPoint, lv )/lvl+1.2) / (lvl*lvl);\n\ttotallight += light2*lightFrac;\n\ttotallight *= 103.;\n\ttotallight += dot(hitPoint*sign(ray.Direction),vec3(0,-1,0))*0.2+0.2 ;\n\t\n\tvec2 tex = floor(fract(vec2(dot(hitPoint,actual.zxx),dot(hitPoint,actual.yzy)))*16.);\n\t\n\tfloat stone = getStoneType(voxel)+1.;\n\t\n\tvec3 c0 = vec3(0.7+stone*.1,0.7,0.7-stone*.1);\n\tvec3 c1 = vec3(0.7,0.7,0.7)+vec3(stone-3.5,3.5-stone,-0.3)*step(2.5,stone);\n\t\n\t\n\tfloat rnd = dot(sin(tex*vec2(3.3-stone*.7,.01+.3*stone)), sin(tex*vec2(3.1+stone,.01+.3*stone)));\n\tvec3 rndV = max(.2,rnd)*c0+max(.2,-rnd)*c1;\n\t\n\tif (actual.y < -20.1) {\n\t\tvec3 water = ray.Origin + ray.Direction*(-20. - ray.Origin.y)/ray.Direction.y;\n\t\treturn vec3((vec3(0.03,0.1,0.2)+rndV*.05+sin(water.x*11.)*.03+sin(water.z*11.)*.03)*totallight);\n\t} else if (stone == 1. && ShouldDraw(voxel+vec3(0,1,0)) > 0. && actual.y-voxel.y > 0.7) {\n\t\treturn vec3((vec3(0.1,0.4,0.)+rndV*.15)*totallight);\n\t} else if (stone == 1. && ShouldDraw(voxel+vec3(0,3,0)) > 0.) {\n\t\treturn vec3((vec3(0.35,0.15,0.0)+rndV*.1)*totallight);\n\t}\n\t\n\treturn vec3(1.,.8,.6)*rndV*totallight;\n}\n\t\n\nvec3 GetRayColor(Ray ray)\n{\n\tvec3 voxel = ray.Origin - fract(ray.Origin);\n\tvec3 hitPoint;\n\tvec3 actual;\n\t\n\tconst int maxIter = 250;/*CAREFUL WITH THIS!!!*/\n\t\n\tfor(int i=0;i<maxIter;i++)\n\t{\n\t\tfloat dist = ShouldDraw(voxel);\n\t\tif(dist < 0. || i == maxIter-1) {\n\t\t\treturn getColorAt(voxel, actual, hitPoint, ray);\n\t\t} else if (voxel.y > 20.) {\n\t\t\treturn vec3(0.1, 0.3, 0.9);\n\t\t} else if (dist < 3.) {\n\t\t\tIterateVoxel(voxel, ray, hitPoint, actual);\n\t\t}\n\t\telse {\n\t\t\tvoxel = ray.Origin + ray.Direction * (dot(voxel + .5 - ray.Origin, ray.Direction)+dist-1.);\n\t\t\tvoxel = floor(voxel);\n\t\t}\n\t}\n\t\n\treturn vec3(0);\n}\n\nvoid GetCameraRay(const in vec3 position, const in vec3 lookAt, out Ray currentRay)\n{\n\tvec3 forwards = normalize(lookAt - position);\n\tvec3 worldUp = vec3(0.0, 1.0, 0.0);\n\t\n\t\n\tvec2 uV = ( gl_FragCoord.xy / resolution.xy );\n\tvec2 viewCoord = uV * 2.0 - 1.0;\n\t\n\tfloat ratio = resolution.x / resolution.y;\n\t\n\tviewCoord.y /= ratio;                              \n\t\n\tcurrentRay.Origin = position;\n\t\n\tvec3 right = normalize(cross(forwards, worldUp));\n\tvec3 up = cross(right, forwards);\n\t       \n\tcurrentRay.Direction = normalize( right * viewCoord.x + up * viewCoord.y + forwards);\n}\n\nvoid main( void ) \n{\n\tRay currentRay;\n \n\tfloat time2 = time*15.;\n\tGetCameraRay(vec3(getTunnelCoords(time2),time2), vec3(0.1, 0.0, time2*1.+17.), currentRay);\n\n\t//making black \"black\" instead of alpha black... _gtoledo3\n\tvec3 color = GetRayColor(currentRay);\n\tgl_FragColor = vec4((color+sqrt(color))*.5,1.0);\n}", "user": "e5c6f9b", "parent": "/e#1492.0", "id": "1497.9"}