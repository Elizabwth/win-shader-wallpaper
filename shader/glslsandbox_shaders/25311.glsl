{"code": "precision highp float;\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define RENDER_MODE\n\n#define PI 3.14159265359\n#define DEG2RAD (PI/180.0)\n\n#ifdef RENDER_MODE\nvec3 rotateX(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(p.x, c*p.y+s*p.z, -s*p.y+c*p.z);\n}\n\nvec3 rotateY(vec3 p, float angle)\n{\n    float c = cos(angle);\n   float s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec3 rotateZ(vec3 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);\n}\n\n\nfloat kaleidoscopic_IFS(vec3 z)\n{\n    const int FRACT_ITER      = 20;\n    float FRACT_SCALE   = 1.8;\n    float FRACT_OFFSET  = 1.0;\n\t\n    float c = 2.0;\n    z.y = mod(z.y, c)-c/2.0;\n    z = rotateZ(z, PI/2.0);\n    float r;\n    int n1 = 0;\n    for (int n = 0; n < FRACT_ITER; n++) {\n        float rotate = PI*0.5;\n        z = rotateX(z, rotate);\n        z = rotateY(z, rotate);\n        z = rotateZ(z, rotate);\n\n        z.xy = abs(z.xy);\n       // if (z.x+z.y<0.0) z.xy = -z.yx; // fold 1\n        //if (z.x+z.z<0.0) z.xz = -z.zx; // fold 2\n        //if (z.y+z.z<0.0) z.zy = -z.yz; // fold 3\n        z = z*FRACT_SCALE - FRACT_OFFSET*(FRACT_SCALE-1.0);\n    }\n    return (length(z) ) * pow(FRACT_SCALE, -float(FRACT_ITER));\n}\n\n\nfloat tglad_formula(vec3 z0)\n{\n\tz0 = mod(z0, 2.);\n\t\n    float mr=0.25, mxr=1.0;\n    vec4 scale=vec4(-3.12,-3.12,-3.12,3.12), p0=vec4(0.0,1.59,-1.0,0.0);\n    vec4 z = vec4(z0,1.0);\n    for (int n = 0; n < 3; n++) {\n        z.xyz=clamp(z.xyz, -0.94, 0.94)*2.0-z.xyz;\n        z*=scale/clamp(dot(z.xyz,z.xyz),mr,mxr)*1.;\n        z+=p0;\n    }\n    float dS=(length(max(abs(z.xyz)-vec3(1.2,49.0,1.4),0.0))-0.06)/z.w;\n    return dS;\n}\n\n// distance function from Hartverdrahtet\n// ( http://www.pouet.net/prod.php?which=59086 )\nfloat hartverdrahtet(vec3 f)\n{\n\tvec3 cs=vec3(.808,.808,1.167);\n\tfloat fs=1.;\n\tvec3 fc=vec3(0);\n\tfloat fu=10.;\n\tfloat fd=.763;\n\t\n\t// scene selection\n\tint i = int(mod(time/2.0, 9.0));\n\tif(i==0) cs.y=.58;\n\tif(i==1) cs.xy=vec2(.5);\n\tif(i==2) cs.xy=vec2(.5);\n\tif(i==3) fu=1.01,cs.x=.9;\n\tif(i==4) fu=1.01,cs.x=.9;\n\tif(i==6) cs=vec3(.5,.5,1.04);\n\tif(i==5) fu=.9;\n\tif(i==7) fd=.7,fs=1.34,cs.xy=vec2(.5);\n\tif(i==8) fc.z=-.38;\n\t\n\t//cs += sin(time)*0.2;\n\t\t\n\tfloat v=1.;\n\tfor(int i=0; i<12; i++){\n\t\tf=2.*clamp(f,-cs,cs)-f;\n\t\tfloat c=max(fs/dot(f,f),1.);\n\t\tf*=c;\n\t\tv*=c;\n\t\tf+=fc;\n\t}\n\tfloat z=length(f.xy)-fu;\n\treturn fd*max(z,abs(length(f.xy)*f.z)/sqrt(dot(f,f)))/abs(v);\n}\n\nfloat pseudo_kleinian(vec3 p)\n{\n\tconst vec3 CSize = vec3(0.92436,0.90756,0.92436);\n\tconst float Size = 1.0;\n\tconst vec3 C = vec3(0.0,0.0,0.0);\n\tfloat DEfactor=1.;\n\tconst vec3 Offset = vec3(0.0,0.0,0.0);\n   \tvec3 ap=p+1.;\n\tfor(int i=0;i<10 ;i++){\n\t\tap=p;\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n\t\tfloat r2 = dot(p,p);\n\t\tfloat k = max(Size/r2,1.);\n\t\tp *= k;\n\t\tDEfactor *= k;\n\t\tp += C;\n\t}\n\tfloat r = abs(0.5*abs(p.z-Offset.z)/DEfactor);\n\treturn r;\n}\n\nfloat pseudo_knightyan(vec3 p)\n{\t\n\tconst vec3 CSize = vec3(0.63248, 0.78632, 0.775);\n\tfloat DEfactor=1.;\n\tfor(int i=0;i<6;i++){\n\t\tp = 2.*clamp(p, -CSize, CSize)-p;\n\t\tfloat k = max(0.70968/dot(p,p),1.);\n\t\tp *= k;\n\t\tDEfactor *= k*1.1;\n\t}\n\tfloat rxy=length(p.xy);\n\treturn max(rxy-0.92784, abs(rxy*p.z) / length(p))/DEfactor;\n}\n\n\nfloat map(vec3 p)\n{\n\t//return kaleidoscopic_IFS(p);\n\treturn tglad_formula(p);\n\t//return hartverdrahtet(p);\n\t//return pseudo_kleinian(p);\n\t//return pseudo_knightyan(p);\n}\n\nvec3 guess_normal(vec3 p)\n{\n\tconst float d = 0.001;\n\treturn normalize( vec3(\n\t\tmap(p+vec3(  d,0.0,0.0)) - map(p+vec3( -d,0.0,0.0)),\n\t\tmap(p+vec3(0.0,  d,0.0)) - map(p+vec3(0.0, -d,0.0)),\n\t\tmap(p+vec3(0.0,0.0,  d)) - map(p+vec3(0.0,0.0, -d)) ) );\n}\n\n\nvec2 pattern(vec2 p)\n{\n\tp = fract(p);\n\tfloat r = 0.123;\n\tfloat v = 0.0, g = 0.0;\n\tr = fract(r * 9184.928);\n\tfloat cp, d;\n\t\n\td = p.x;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.x - 1.0;\n\tg += pow(clamp(3.0 - abs(d), 0.0, 1.0), 1000.0);\n\td = p.y - 1.0;\n\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 10000.0);\n\t\n\tconst int iter = 12;\n\tfor(int i = 0; i < iter; i ++)\n\t{\n\t\tcp = 0.5 + (r - 0.5) * 0.9;\n\t\td = p.x - cp;\n\t\tg += pow(clamp(1.0 - abs(d), 0.0, 1.0), 200.0);\n\t\tif(d > 0.0) {\n\t\t\tr = fract(r * 4829.013);\n\t\t\tp.x = (p.x - cp) / (1.0 - cp);\n\t\t\tv += 1.0;\n\t\t}\n\t\telse {\n\t\t\tr = fract(r * 129.528);\n\t\t\tp.x = p.x / cp;\n\t\t}\n\t\tp = p.yx;\n\t}\n\tv /= float(iter);\n\treturn vec2(g, v);\n}\n\nvec2 sphere_mapping(vec3 p)\n{\n\treturn vec2(\n\t\tasin(p.x)/PI + 0.5,\n\t\tasin(p.y)/PI + 0.5);\n}\n\n\nmat3 axis_rotation_matrix33(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\n#endif\n\nvoid main( void ) {\n#ifdef RENDER_MODE\n\tvec3 pos = vec3(vec2((gl_FragCoord.xy*2.0 - resolution.xy) / resolution.y), 0.0);\n\t\n\tvec3 camPos = vec3(5.0*cos(time*0.1), 0.5*sin(time*0.2), 5.0*sin(time*0.1));\n\tvec3 camDir = normalize(pos - camPos);\n\tvec3 camUp = normalize( vec3(0.0, 1.0+cos(time*0.1)*0.75, sin(time*0.1)*0.75) );\n\tcamUp  = axis_rotation_matrix33(cross(camDir, camUp), 90.0*DEG2RAD)*camDir;\n\tvec3 camSide = cross(camDir, camUp);\n\t\n\tfloat fovy = 60.0;\n\t\n\tvec3 rayDir = normalize(camSide*-pos.x + camUp*-pos.y + camDir*1.0/tan(fovy*0.5*DEG2RAD));\n\tvec3 rayPos = camPos;\n\tfloat m = 0.0;\n\tfloat d = 0.0, total_d = 0.0;\n\tconst int MAX_MARCH = 100;\n\tconst float MAX_DISTANCE = 100.0;\n\tfor(int i=0; i<MAX_MARCH; ++i) {\n\t\td = map(rayPos);\n\t\ttotal_d += d;\n\t\trayPos += rayDir * d;\n\t\tm += 1.0;\n\t\tif(d<0.001) { break; }\n\t\tif(total_d>MAX_DISTANCE) { break; }\n\t}\n\t\n\tvec3 normal = guess_normal(rayPos);\n\t\n\tfloat r = mod(time*2.0, 20.0);\n\tfloat glow = max((mod(length(rayPos)-time*1.5, 10.0)-9.0)*2.5, 0.0);\n\tvec3 gp = abs(mod(rayPos, vec3(0.4)));\n\tvec2 p =(sphere_mapping(normalize(rayPos)*mod(length(rayPos), 1.0))*2.0);\n\tif(p.x<1.4) {\n\t\tglow = 0.0;\n\t}\n\telse {\n\t\tglow += 0.0;\n\t}\n\tglow += max(1.0-abs(dot(-camDir, normal)) - 0.4, 0.0) * 0.5;\n\t\n\tfloat c = (total_d)*0.01;\n\tvec4 result = vec4( vec3(c, c, c) + vec3(0.02, 0.02, 0.025)*m*0.4, 1.0 );\n\tresult.xyz += vec3(0.5, 0.5, 0.75)*glow;\n\t//result *= mod(gl_FragCoord.y, 4.0)<2.0 ? 0.6 : 1.0;\n\t//result.xyz = normal*0.5+0.5;\n\tgl_FragColor = result;\n\n\t\n\t\n#else\n\tgl_FragColor = vec4(0.2);\n#endif\n\t\n}", "user": "4878ed1", "parent": "/e#25300.0", "id": "25311.1"}