{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Fake bokeh shaded cube by Kabuto\n// Theory: works.\n// Practice: slow and has bugs... as usual.\n\n// mouse: change focal plane\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float PI = 3.141592653589;\n\nfloat cap(vec2 a, vec2 b) {\n\tvec2 abd = vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y);\n\tfloat y_x = abd.y/(abd.x-1.);\n\t\n\treturn atan(-y_x)-y_x/(1.+y_x*y_x)+PI/2.;\n}\n\nfloat cap1(float p) {\n\tp = max(min(p,1.),-1.);\n\treturn asin(p)+p*sqrt(1.-p*p)+PI/2.;\n}\n\nfloat ebok(vec2 p, vec2 a, vec2 b) {\n\tvec2 an = vec2(a.y,-a.x);\n\tvec2 bn = vec2(b.y,-b.x);\n\t\n\tfloat surface;\n\tif (dot(p,p) < .99) {\n\t\tfloat pa = dot(p,a);\n\t\tfloat ra = -pa+sqrt(pa*pa-dot(p,p)+1.);\n\t\tvec2 pac = ra*a;\n\t\t\n\t\tfloat pb = dot(p,b);\n\t\tfloat rb = -pb+sqrt(pb*pb-dot(p,p)+1.);\n\t\tvec2 pbc = rb*b;\n\t\t\n\t\tsurface = cap(p+pac,p+pbc)+(pac.x*pbc.y-pac.y*pbc.x)*.5;\n\t} else {\n\t\tfloat d1 = dot(an,p);\n\t\tfloat d2 = -dot(bn,p);\n\t\tfloat sda = step(dot(p,a),0.);\n\t\tfloat sdb = step(dot(p,b),0.);\n\t\tsurface = PI*(sda+sdb-sda*sdb) - cap1(-d1)*sda - cap1(-d2)*sdb;\n\t\t\n\t}\n\treturn surface;\n}\n\nfloat handleCorner(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 ba = normalize(a-b);\n\tvec2 bc = normalize(c-b);\n\tfloat h = dot(a-p,vec2(ba.y,-ba.x));\n\treturn ebok(p-b, bc, ba) - cap1(h);\n}\n\nfloat bokehtria(vec2 p, vec2 a, vec2 b, vec2 c) {\n\tvec2 mi = min(min(a,b),c)-1.;\n\tvec2 ma = max(max(a,b),c)+1.;\n\treturn (a.x-b.x)*(a.y-c.y)<(a.y-b.y)*(a.x-c.x)||p.x<mi.x||p.y<mi.y||p.x>ma.x||p.y>ma.y ? 0. :  handleCorner(p,a,b,c) + handleCorner(p,b,c,a) + handleCorner(p,c,a,b) + PI;\n}\n\nfloat bokehsquare(vec2 p, vec2 a, vec2 b, vec2 c, vec2 d, float scale) {\n\t//return bokehtria(p*scale,a*scale,b*scale,c*scale) + bokehtria(p*scale,c*scale,d*scale,a*scale);\n\tp *= scale; a *= scale; b *= scale; c *= scale; d *= scale;\n\tvec2 mi = min(min(a,b),min(c,d))-1.;\n\tvec2 ma = max(max(a,b),max(c,d))+1.;\n\treturn (a.x-b.x)*(a.y-c.y)<(a.y-b.y)*(a.x-c.x)||p.x<mi.x||p.y<mi.y||p.x>ma.x||p.y>ma.y ? 0. :  handleCorner(p,a,b,c) + handleCorner(p,b,c,d) + handleCorner(p,c,d,a) + handleCorner(p,d,a,b) + PI;\n}\n\nvec2 project(vec3 v) {\n\treturn v.xy/(v.z+14.);\n}\n\nvec4 shade(vec3 v, float f) {\n\tfloat highlight = pow(f*.5+.5,100.);\n\treturn vec4(pow(f*.5+.5,10.)*v*1.5*(1.-highlight)+highlight,1.)/PI;\n}\n\nvoid main( void ) {\n\tfloat rx = time;// + mouse.x*8.;\n\t//float ry = mouse.y*4.;\n\tmat3 matx = mat3(cos(rx),0,sin(rx),0,1,0,-sin(rx),0,cos(rx));\n\t//mat3 maty = mat3(1,0,0,0,cos(ry),-sin(ry),0,sin(ry),cos(ry));\n\tmat3 mat = matx;//*maty;\n\t\n\n\tmat3 rot = mat3(1,0,0,0,.8,.6,0,-.6,.8)*mat3(.96,.28,0,-.28,.96,0,0,0,1);\n\t\n//\tfloat scale = exp(sin(time*.5)*2.5+3.5);\n\n\tvec2 p = ( gl_FragCoord.xy - resolution*.5 ) / resolution.x ;\n\t\n\tvec3 color = vec3(0,.2,.7);\n\t\n\tfor (float z = -1.; z <= 1.; z++) {\n\t\tfor (float x = -1.; x <= 1.; x++) {\n\t\t\tvec3 q = vec3(x*3.5+z,sin(x*2.+z*2.+time),z*-3.5+x);\n\t\t\t\n\t\t\tfloat scale = 1./(1./(q.z+14.) - 1./(mouse.y*9.-4.5+14.1));\n\t\t\t\t\n\t\t\tvec2 a = project(vec3(-1.,1.,-1)*mat+q);\n\t\t\tvec2 b = project(vec3(1.,1.,-1.)*mat+q);\n\t\t\tvec2 c = project(vec3(-1.,1.,1.)*mat+q);\n\t\t\tvec2 d = project(vec3(1.,1.,1.)*mat+q);\n\t\t\tvec2 e = project(vec3(-1.,-1.,-1.)*mat+q);\n\t\t\tvec2 f = project(vec3(1.,-1.,-1.)*mat+q);\n\t\t\tvec2 g = project(vec3(-1.,-1.,1.)*mat+q);\n\t\t\tvec2 h = project(vec3(1.,-1.,1.)*mat+q);\n\t\t\t\n\t\t\tvec4 color1 = \n\n\t\t\t\t+ (dot(vec3(mat[0][0],mat[1][0],mat[2][0]),q+vec3(0,0,14.)) > 0. ? bokehsquare(p,a,c,g,e,scale)*shade(vec3(.5,.5,.7),mat[2][0]) : bokehsquare(p,f,h,d,b,scale)*shade(vec3(.5,.5,.3),-mat[2][0]));\n\t\t\tcolor = color1.xyz + color*(1.-color1.w);\n\t\t\tmat *= rot;\n\t\t}\n\t}\n\n\t\n\n\tgl_FragColor = vec4( vec3(sqrt(color)), 1.0 );\n\n}", "user": "2e26788", "parent": "/e#3858.5", "id": "3933.0"}