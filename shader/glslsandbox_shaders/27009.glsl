{"code": "// Daniel Varga\n// Newton-fractal for a time-dependent 4th degree polynomial.\n// Based on modified Newton Fractal 1-z^3 by @hintz\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat TD = 0.5;\n\n// for pretty colors\nvec4 hsv2rgb(vec3 col)\n{\n    float iH = floor(mod(col.x,1.0)*6.0);\n    float fH = mod(col.x,1.0)*6.0-iH;\n    float p = col.z*(1.0-col.y);\n    float q = col.z*(1.0-fH*col.y);\n    float t = col.z*(1.0-(1.0-fH)*col.y);\n  \n  if (iH==0.0)\n  {\n    return vec4(col.z, t, p, 1.0);\n  }\n  if (iH==1.0)\n  {\n    return vec4(q, col.z, p, 1.0);\n  }\n  if (iH==2.0)\n  {\n    return vec4(p, col.z, t, 1.0);\n  }\n  if (iH==3.0)\n  {\n    return vec4(p, q, col.z, 1.0);\n  }\n  if (iH==4.0)\n  {\n    return vec4(t, p, col.z, 1.0);\n  }\n  \n  return vec4(col.z, p, q, 1.0); \n}\n\n// complex number math functions\nvec2 mul(vec2 a, vec2 b)\n{\n  return vec2(a.x*b.x - a.y*b.y, a.y*b.x + a.x*b.y);\n}\n\nvec2 div(vec2 a, vec2 b)\n{\n  return vec2((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n}\n\nvec2 exponential(vec2 a, float b)\n{\n  float r = pow(length(a),b);\n  float s = b*atan(a.y,a.x);\n  return vec2(r*cos(s),r*sin(s));\n}\n\n// Any function \nvec2 f(vec2 z)\n{\n  // return exponential(z,sin(time)*5.+8.)-1.;\n  vec2 p = vec2(sin(time*TD),cos(time*TD));\n  p = mul(p,z);\n  p = p+vec2(sin(time*TD),cos(2.*time*TD));\n  p = mul(p,z);\n  p = p;//+vec2(sin(time*TD+10.)/10.,cos(.4*time*TD+5.)/10.);\n  p = mul(p,z);\n  p = p+vec2(2.,0.);\n  p = mul(p,z);\n  p = p+vec2(1.,1.);\n  p = mul(p,z);\n  p = p+vec2(1.,1.);\n  return p;\n}\n\n// Newton-Raphson\nvec2 iter(vec2 z)\n{\n  float h = sin(time*TD*0.8)*0.6;//1e-5;\n  // Try it with 1.0, it's actually cooler than a faithful Newton-Raphson. It's like a Julia.\n  vec2 delta = vec2(h,cos(time*TD*0.9)*0.25);\n  // dz = (f(z + complex(h, h)) - f(z)) / complex(h, h)\n  // zNext = z - f(z)/dz\n  vec2 dz = f(z+delta)-f(z);\n  dz = div(dz,delta);\n  return z-div(f(z),dz);\n}\n\nvec2 newtonfractal(vec2 z)\n{\n  for (int n=0;n<100;n++)\n  {\n    vec2 old=z;\n    z = iter(z);\n   \n    vec2 d=z-old;\n     \n    if (length(d) < 0.03)\n    {\n      //return vec2(.2,0.8);\n      return vec2(atan(z.y,z.x)/3.141592653/2., float(n)*0.025); // Hue based on the direction of z.\n      return vec2(z.x+z.y, float(n)*0.025); // Ad hoc coloring based on z, the original by @hintz, optimized for z^3-1.\n    }\n  }\n  \n  return vec2(0.,1.);\n}\n\nvoid main(void)\n{\n  float deltax=8.0+sin(time*TD*1.0)*3.8; // Time-dependent zoom-in-zoom-out.\nfloat deltay = resolution.y/resolution.x * deltax;\n\nfloat real = deltax*(gl_FragCoord.x/resolution.x-0.5);\nfloat imag = deltay*(gl_FragCoord.y/resolution.y-0.5);\n\t\n  vec2 results = newtonfractal(vec2(real, imag));\n\n  float h = results.x;\n  float v = 0.7-results.y;\n  float s = 0.7;\n\n  gl_FragColor = hsv2rgb(vec3(h,s,v));\n}\n", "user": "943f9dd", "parent": "/e#11605.0", "id": "27009.0"}