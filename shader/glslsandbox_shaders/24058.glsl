{"code": "\n//---------------------------------------------------------\n// Shader:   BritneysSpaceship.glsl          2/2015 by Kali\n// original: https://www.shadertoy.com/view/4tX3Rj\n// tags:     raymarching, fractal, 3d, space, 3d\n//---------------------------------------------------------\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D texture; \n\n//---------------------------------------------------------\n//#define LESSDETAIL\n\n#define RAY_STEPS 100\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(1., .97, .93)\n#define AMBIENT_COLOR vec3(.75, .65, .6)\n\n#define SPECULAR 0.65\n#define DIFFUSE  1.0\n#define AMBIENT  0.35\n\n#define BRIGHTNESS 1.5\n#define GAMMA 1.35\n#define SATURATION 0.8\n\n#define detail 0.00004\n#define t time*0.2\n\nvec3 lightdir = normalize(vec3(0.1, -0.15, -1.));\nconst vec3 origin = vec3(-1., 0.2, 0.);\nfloat det=0.0;\nvec3 pth1;\n\nmat2 rot(float a) \n{\n  return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec4 formula(vec4 p) \n{\n  p.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n  p=p*2./clamp(dot(p.xyz, p.xyz), .15, 1.)-vec4(0.5, 0.5, 0.8, 0.);\n  p.xy*=rot(.5);\n  return p;\n}\n\nfloat screen(vec3 p) \n{\n  float d1=length(p.yz-vec2(.25, 0.))-.5;  \n  float d2=length(p.yz-vec2(.25, 2.))-.5;  \n  return min(max(d1, abs(p.x-.3)-.01), max(d2, abs(p.x+2.3)-.01));\n}\n\nvec2 de(vec3 pos) \n{\n  float hid=0.;\n  vec3 tpos=pos;\n  tpos.z=abs(2.-mod(tpos.z, 4.));\n  vec4 p=vec4(tpos, 1.5);\n  float y=max(0., .35-abs(pos.y-3.35))/.35;\n  #ifdef LESSDETAIL\n    for (int i=0; i<6; i++) \n      p=formula(p);\n    float fr=max(-tpos.x-4., (length(max(vec2(0.), p.yz-2.))-.5)/p.w);\n  #else \n    for (int i=0; i<8; i++) \n      p=formula(p);\n    float fr=max(-tpos.x-4., (length(max(vec2(0.), p.yz-3.)))/p.w);\n  #endif  \n\n  float sc=screen(tpos);\n  float d=min(sc, fr);\n  if (abs(d-sc)<.001) hid=1.;\n  return vec2(d, hid);\n}\n\nvec2 colorize(vec3 p) \n{\n  p.z=abs(2.-mod(p.z, 4.));\n  float es, l=es=0.;\n  float ot=1000.;\n  for (int i = 0; i < 15; i++) \n  { \n    p=formula(vec4(p, 0.)).xyz;\n    float pl = l;\n    l = length(p);\n    es+= exp(-10. / abs(l - pl));\n    ot=min(ot, abs(l-3.));\n  }\n  return vec2(es, ot);\n}\n\n\n\nvec3 path(float ti)\n{\n  vec3  p=vec3(sin(ti)*2., (1.-sin(ti*.5))*.5, -cos(ti*.25)*30.)*.5;\n  return p;\n}\n\n\nvec3 normal(vec3 p) \n{\n  vec3 e = vec3(0.0, det, 0.0);\n  return normalize(vec3(de(p+e.yxx).x-de(p-e.yxx).x, \n                        de(p+e.xyx).x-de(p-e.xyx).x, \n                        de(p+e.xxy).x-de(p-e.xxy).x));\n}\n\nfloat shadow(vec3 pos, vec3 sdir) \n{\n  float sh=1.0;\n  float totdist =2.0*det;\n  float dist=10.;\n  for (int steps=0; steps<SHADOW_STEPS; steps++) \n  {\n    if (totdist<1. && dist>detail) \n    {\n      vec3 p = pos - totdist * sdir;\n      dist = de(p).x;\n      sh = min( sh, max(50.*dist/totdist, 0.0) );\n      totdist += max(.01, dist);\n    }\n  }\n  return clamp(sh, 0.1, 1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor )\n{\n  float aodet=detail*40.;\n  float totao = 0.0;\n  float sca = 13.0;\n  for ( int aoi=0; aoi<5; aoi++ ) \n  {\n    float hr = aodet*float(aoi*aoi);\n    vec3 aopos =  nor * hr + pos;\n    float dd = de( aopos ).x;\n    totao += -(dd-hr)*sca;\n    sca *= 0.7;\n  }\n  return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) \n{\n  float sh=shadow(p, lightdir);\n  float ao=calcAO(p, n);\n  float diff=max(0., dot(lightdir, -n))*sh*DIFFUSE;\n  vec3 amb=max(.5, dot(dir, -n))*AMBIENT*AMBIENT_COLOR;\n  vec3 r = reflect(lightdir, n);\n  float spec=pow(max(0., dot(dir, -r))*sh, 15.)*SPECULAR;\n  vec3 col;\n  vec2 getcol=colorize(p);\n  if (hid>.5) \n  {\n    col=vec3(1.); \n    spec=spec*spec;\n  }\n  else \n  {\n    float k=pow(getcol.x*.11, 2.); \n    col=mix(vec3(k, k*k, k*k), vec3(k), .5)+.1;\n    col+=pow(max(0., 1.-getcol.y), 5.)*.3;\n  }\n  col=col*ao*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;  \n\n  if (hid>.5) \n  {\n    vec3 p2=p;\n    p2.z=abs(1.-mod(p2.z, 2.));\n    vec3 c=texture2D(texture, mod(p.zy+vec2(.4, 0.2), vec2(1.))).xyz*2.;\n    col+=c*abs(.01-mod(p.y-t*.5, .02))/.01*ao;\n    col*=max(0., 1.-pow(length(p2.yz-vec2(.25, 1.)), 2.)*3.5);\n  }\n  else \n  {\n    vec3 c=(texture2D(texture, mod(p.zx*2.+vec2(0.5), vec2(1.))).xyz);\n    c*=abs(.01-mod(p.x-t*.5*sign(p.x+1.), .02))/.01;\n    col+=pow(getcol.x, 10.)*.0000000003*c;\n    col+=pow(max(0., 1.-getcol.y), 4.)\n        *pow(max(0., 1.-abs(1.-mod(p.z+t, 4.))), 2.)\n        *vec3(1., .8, .4)*4.*max(0., .05-abs(p.x+1.))/.05;\n  }\n  return col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n  float glow, eglow, totdist=glow=0.;\n  vec2 d=vec2(1., 0.);\n  vec3 p, col=vec3(0.);\n\n  for (int i=0; i<RAY_STEPS; i++) \n  {\n    if (d.x>det && totdist<30.0) \n    {\n      p=from+totdist*dir;\n      d=de(p);\n      det=detail*(1.+totdist*50.);\n      totdist+=d.x; \n      if (d.x<0.015)glow+=max(0., .015-d.x)*exp(-totdist);\n    }\n  }\n  float l=max(0., dot(normalize(-dir), normalize(lightdir)));\n  vec3 backg=vec3(max(0., -dir.y+.6))*AMBIENT_COLOR*.5*max(0.4, l);\n\n  if (d.x<det || totdist<30.) \n  {\n    p=p-abs(d.x-det)*dir;\n    vec3 norm=normal(p);\n    col=light(p, dir, norm, d.y); \n    col = mix(col, backg, 1.0-exp(-.15*pow(totdist, 1.5)));\n  } \n  else \n  { \n    col=backg;\n    vec3 st = (dir * 3.+ vec3(1.3, 2.5, 1.25)) * .3;\n    for (int i = 0; i < 13; i++) st = abs(st) / dot(st, st) - .9;\n    col+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 );\n  }\n  vec3 lglow=LIGHT_COLOR*pow(l, 25.)*.5;\n  col+=glow*(.5+l*.5)*LIGHT_COLOR*.7;\n  col+=lglow*exp(min(30., totdist)*.02);\n  return col;\n}\n\nvec3 move(inout vec3 dir) \n{\n  vec3 go=path(t);\n  vec3 adv=path(t+.7);\n  float hd=de(adv).x;\n  vec3 advec=normalize(adv-go);\n  float an=adv.x-go.x; \n  an*=min(1., abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n  dir.xy*=mat2(cos(an), sin(an), -sin(an), cos(an));\n  an=advec.y*1.7;\n  dir.yz*=mat2(cos(an), sin(an), -sin(an), cos(an));\n  an=atan(advec.x, advec.z);\n  dir.xz*=mat2(cos(an), sin(an), -sin(an), cos(an));\n  return go;\n}\n\nvoid main()\n{\n  pth1 = path(t+.3)+origin;\n  vec2 uv = gl_FragCoord.xy / resolution.xy *2. -1.;\n  uv.y *= resolution.y / resolution.x;\n  vec2 mo = mouse.xy / resolution.xy;\n  mo.x *= 6.28;\n  vec3 dir=normalize(vec3(uv*.8, 1.));\n  dir.yz*=rot(mo.y);\n  dir.xz*=rot(mo.x);\n  vec3 from=origin+move(dir);\n  vec3 color=raymarch(from, dir); \n  color=clamp(color, vec3(.0), vec3(1.));\n  color=pow(color, vec3(GAMMA))*BRIGHTNESS;\n  color=mix(vec3(length(color)), color, SATURATION);\n  gl_FragColor = vec4(color, 1.);\n}\n", "user": "4e5d0f1", "parent": "/e#24056.0", "id": "24058.1"}