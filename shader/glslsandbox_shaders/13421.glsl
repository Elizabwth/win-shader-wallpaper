{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Hello Morph! By David Hoskins. Jan 2014.\n// Aardman's (from Wallace & Gromit fame) early work.\n// Morph, the plasticine animation from British childhoods in the 70s and 80s.\n// http://www.youtube.com/watch?v=jSMRPKM1evk\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n// Comment this line out to remove frame judder effect...\n#define STOP_MOTION_EFFECT\n\n#define \telbowR\t\tvec3(1.0, -.1, 0.3)\n#define \tshoulderR\tvec3(0.4, 0.56,  -.05)\n#define \twristR\t\tvec3(.5, -.4, -0.1)\n#define \tshoulderL\tvec3(-0.4, 0.56, -.05)\nvec3 elbowL;\nvec3 wristL;\n\nconst vec3 sunColour  = vec3(1.0);\nconst vec3 skinColour = vec3(.72, .23, 0.12);\nvec3 sunDir\t= normalize(vec3(.5, .7, -.8));\n\nfloat hello;\nfloat owwww;\nfloat wave;\nfloat gtime;\nbool  blink = false;\n\n//----------------------------------------------------------------------------------------\nmat3 RotMat(vec3 v, float angle)\n{\n\tv = normalize(v);\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nfloat Segment(vec3 p,  vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn length( pa - ba*h ) - r1 + r2*h;\n}\n\n//----------------------------------------------------------------------------------------\nfloat  Sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Mouth( vec3 p, vec3 a)\n{\n\tfloat curve = cos(p.x*(5.35+sin(time)*1.25))*.11;\n\tp.y += curve;\n\ta.y += (curve*curve);\n\treturn length(max(abs(p) - a,0.0)) -.02;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Cylinder( vec3 p, vec2 h )\n{\n  return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//----------------------------------------------------------------------------------------\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\t//b.x -= p.y * .08;\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat Nose(vec3 p, vec3 a, float r )\n{\n\tfloat h = clamp( dot(p,a)/dot(a,a), 0.0, 1.0 );\n\treturn length( p - a*h ) - r;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\n//----------------------------------------------------------------------------------------\nfloat sMin( float a, float b )\n{\n    float k = .1;\n\tfloat h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.-h);\n}\n\n\n//----------------------------------------------------------------------------------------\nvec2 Map( in vec3 pos )\n{\t// Floor...\n    vec2 res = vec2( 1000.0, -1.0);\n\tfloat d;\n\tvec3 p2;\n\n\t// Head...\n\tvec3 p = pos-vec3(0.0, 1.0, -0.1);\n\tfloat h = sin(time*2.3) * .1 - wave*0.01;\n\tp = RotMat(vec3(0.0, 0.5, .1), h) * p;\n\tp2 = RotMat(vec3(1.0, 0.0, .0), wave*.01+hello*2.0) * p;\n\tres = opU(res, vec2(Sphere(p, .38), 3.0 ));\n\t// Mouth...\n\tfloat mo = -Mouth(p2-vec3(0.0, -.057-hello, -0.3), vec3(.155-owwww, -.01+hello, .2));\n\tif (res.x  < mo ) res = vec2(mo, 2.0);\n\t\n\t// Eyes...\n\tif (res.y > 2.5)\n\t{\n\t\tvec3 p3 = vec3(abs(p2.x), p2.yz);\n\t\tif (dot(normalize(p3*vec3(1.0, .9, 1.0)), normalize(vec3(.32, 0.28, -.7))) > .945) res.y = 4.0;\n\t\tif (dot(normalize(p3), normalize(vec3(.32, 0.18, -.8))) > .993) res.y = 5.0;\n\t}\n\n\t// Nose\n\tp2 = p2-vec3(0.0, 0.0, 0.0);\n\tres = opU(res, vec2(Nose(p2, vec3(.0,0.0,-.5), 0.07), 3.0 ));\n\t\n\t// Neck...\n\tp = p-vec3(0.0, -.4, .1);\n\td = Cylinder(p, vec2(0.16, .17));\n\tres.x = sMin(res.x, d);\n\n\t// Body...\t\n\tp = p-vec3(0.0, -.85, 0.0);\n\td = RoundBox(p, vec3(0.18, .49, 0.0), .26);\n\tres.x = sMin(res.x, d);\n\t\n\t// Right arm upper...\n\tp = p-vec3(0.0, 0.0, 0.0);\n\td = Segment(p, shoulderR, elbowR, .19, .05);\n\tres.x = sMin(res.x, d);\n\t// Right arm lower...\n\td = Segment(p, elbowR, wristR, .15, .03);\n\tres.x = sMin(res.x, d);\n\t// Right hand...\t\n\td = Segment(p*vec3(1.0, .75, 1.0), wristR+vec3(0, .1, 0.), wristR+vec3(-.15, .05, -.15), .14, .02);\n\tres.x = min(res.x, d);\n\t\n\t// Left arm upper...\n\td = Segment(p, shoulderL, elbowL, .19, .05);\n\tres.x = sMin(res.x, d);\n\t// Left arm lower...\n\td = Segment(p, elbowL, wristL, .14, .01);\n\tres.x = sMin(res.x, d);\n\t\n\t// Hand...\t\n\tp = (p-wristL);\n\tp.z -= p.x*.5;\n\tp = RotMat(vec3(0.0, 0.0, 1.0), -wave*1.5) * p;\n\td = Segment(p, vec3(0.0), -vec3(-.25, -0.15, 0.1), .06, .01);\n\tres.x = sMin(res.x, d);\n\td = RoundBox(p-vec3(0.0, .25, 0.0), vec3(.045, .09, -.05), .09);\n\tres.x = sMin(res.x, d);\n\t\n\tp = pos;\n\t// Mirrored legs...\n\tp.x = abs(p.x);\n\tvec3 topLeg = vec3(0.22, -.8, 0.0);\n\tvec3 ankle  = vec3(0.3, -2.0, 0.0);\n\td = Segment(p, topLeg, ankle, .23, .05);\n\tres.x = sMin(res.x, d);\n\tankle.y -=.3;\n\tvec3 foot = ankle + vec3(0.27, -.05, -0.3);\n\td = Segment(p, ankle, foot, .25, .05);\n\td = max((ankle.y-p.y), d);\n\tres.x = sMin(res.x, d);\n\n    return res;\n}\n\n//----------------------------------------------------------------------------------------\nvec2 RayMarch( in vec3 ro, in vec3 rd)\n{\n\tconst float precis = 0.01;\n\tfloat t = .25;\n\t\n\tvec2 res = vec2(precis*2.0, -1.0);\n    for( int i = 0; i < 70; i++ )\n    {\n        if(res.x < precis) continue;\n\t\tif (t > 8.0)\n\t\t{\n\t\t\tres.y = -1.0;\n\t\t\tcontinue;\n\t\t}\n\t\tt += max(.005, res.x * .45);\n\t\tres = Map( ro+rd*t );\n    }\n\treturn vec2( t, res.y);\t\n}\n\n//----------------------------------------------------------------------------------------\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.1;\n    for( int i=0; i < 6; i++ )\n    {\n\t\tif (res < 0.0) continue;\n        float h = Map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t);\n     \tt += clamp( h, 0.02, 2.0 );\n    }\n    return max(res, 0.0);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos )\n{\n\tconst vec2 eps = vec2( 0.03, 0.0);\n\tvec3 nor = vec3(\n\t    Map(pos+eps.xyy).x - Map(pos-eps.xyy).x,\n\t    Map(pos+eps.yxy).x - Map(pos-eps.yxy).x,\n\t    Map(pos+eps.yyx).x - Map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n//----------------------------------------------------------------------------------------\nvec3 Render( in vec3 ro, in vec3 rd )\n{ \n\tvec3 col = vec3(0.9), pos, norm;\n\tvec2 res = RayMarch(ro, rd);\n\n\tfloat dis = res.x;\n\tfloat mat = res.y;\n\t\n\tif (mat < .5)\n\t{\n\t\t// Missed...\n\t\tif (rd.y < 0.0)\n\t\t{\n\t\t\tdis = (-2.3-ro.y)/rd.y;\n\t\t\tvec2 p = ro.xz + rd.xz * dis;\n\t\t\tpos = vec3(p.x, -2.0, p.y);\n\t\t\tcol = vec3(.85, .6, .3);//texture2D(iChannel0, p*.3).xyz*.65;\n\t\t\tnorm = vec3(0.0, 1.0, 0.0);\n\t\t\tmat = 1.5;\n\t\t}\n\t}else\n\t{\n\t\tpos = ro + dis * rd;\n\t\tnorm = Normal( pos );\n\n\t\tif (mat < 2.5)\n\t\t{\n\t\t\t// Inside mouth...\n\t\t\tcol = skinColour*.3;\n\t\n\t\t}else if (mat < 3.5)\n\t\t{\n\t\t\t// Plasticine...\n\t\t\tcol = skinColour;\n\t\n\t\t}else if (mat < 4.5)\n\t\t{\n\t\t\t// Eye balls...\n\t\t\tif (blink == true)\n\t\t\t\tcol = skinColour * .7;\n\t\t\telse\n\t\t\t\tcol = vec3(1.0);\n\t\t}else if (mat < 5.5)\n\t\t{\n\t\t\t// Pupil...\n\t\t\tif (blink == true)\n\t\t\t\tcol = skinColour * .7;\n\t\t\telse\n\t\t\t\tcol = vec3(0.0);\n\t\t}\n\t}\n\tif (mat > 0.5)\n\t{\n\t\tfloat diff = max(dot(norm, sunDir), 0.0);\n\t\tfloat ambi = clamp(.2 + 0.2 * norm.y,0.0, 1.0);\n\t\tfloat shad = Shadow(pos, sunDir);\n\t\tfloat spec = max( 0.0, pow( max( dot(sunDir,reflect(rd,norm)), 0.0), 5.0) ) * .2;\n\t\t\n\t\tvec3 lite = diff * sunColour * shad + diff*ambi;\n\t\t\t\n\t\tcol = col * lite + spec * shad;\n\t\tcol = mix(col, vec3(.9), min(dis*dis*.001, 1.0));\n\t}\n\t\n\n\treturn col;\n}\n\n//----------------------------------------------------------------------------------------\nvoid main( void )\n{\n\t// Stop motion time...\n#ifdef STOP_MOTION_EFFECT\n\tgtime = mod((floor(time*20.0) / 20.0), 20.0)-.5;\n#else\n\tgtime = mod(iGlobalTime, 20.0)-.5;\n#endif\n\t\n\tvec2 q = gl_FragCoord.xy/resolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= resolution.x/resolution.y;\n    //vec2 mo = (iMouse.xy/iResolution.xy)-.5;\n\t\n\tfloat m = fract(time*.19);\n\thello =  (1.0+sin(m*100.0)) * .02 * (smoothstep(0.0, .01, m) - smoothstep(0.05, .1, m));\n\towwww = (smoothstep(0.05, .1, m)-smoothstep(0.12, .15, m))*.12;\n\tif (mod(time-1.0, 3.0) < .12)\n\t\t\tblink = true;\n\t\n\t// Camera...\n\tfloat t = clamp(time-2.5, 0.0, 1.0);\n\tt = t*t*(3.0-2.0*t);\n\tvec3 origin = mix(vec3(0.0, 1.0, -1.2), vec3(-1.0, 1.0, -5.0), t);\n\tvec3 target = mix(vec3(0.0, 1.0, 4.0),  vec3( 0.0, -.4, 0.0), t);\n\t\n\tvec3 cw = normalize( target-origin);\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = ( cross(cu,cw) );\n\tvec3 ray = normalize( p.x*cu + p.y*cv + 2.6*cw );\n\t\n\t// Wave...\n\twave = sin(time*15.0-.8)*.5+.5;\n\twave = wave*wave*(3.0-2.0*wave)-.5;\n\telbowL\t\t= vec3(-.95-wave*.05, .2, -0.25);\n\twristL\t\t= vec3(elbowL.x+1.0*sin(wave)*.6, elbowL.y+cos(wave)*.6, -.75);\n\n    vec3 col = Render(origin, ray);\n\t\n\tcol = sqrt(col);\n\tcol *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n    gl_FragColor=vec4(clamp(col, 0.0, 1.0), 1.0 );\n\t\n}\n", "user": "30d600", "parent": null, "id": "13421.0"}