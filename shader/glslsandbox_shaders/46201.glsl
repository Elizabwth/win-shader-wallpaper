{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4sVczV\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// Protect glslsandbox uniform names\n#define time        stemu_time\n\n// --------[ Original ShaderToy begins here ]---------- //\n//#define ANOTHER_LEVEL\n\n\n/* SHADERTOY FROM HERE */\n\nfloat guiLead = 0.6;\nfloat guiInnerRatio = 0.4407892623709694;\nfloat guiFocal = 3.;\nfloat guiRotateModel = 0.4560833039600971;\nfloat guiDebug = 0.6749066960348409;\nfloat guiZipOffset = 30.;\nfloat guiZipSize = 60.;\nfloat guiZipSpeed = 3.3;\nfloat guiZoom = 0.1;\nfloat guiModelScale = 7.749066960348409;\n\nmat4 cameraMatrix = mat4(\n    -0.7063226699829102,\n    0.7052236199378967,\n    0.06198469549417496,\n    0,\n    -0.30620118975639343,\n    -0.3832840919494629,\n    0.8714323043823242,\n    0,\n    0.6382971405982971,\n    0.5965006947517395,\n    0.48660656809806824,\n    0,\n    0.14653973281383514,\n    0.6211488246917725,\n    0.13233166933059692,\n    1\n);\n\nvec3 camPosition = vec3(0.14653973281383514, 0.6211488246917725, 0.13233166933059692);\n\nfloat time;\n\n#define PI 3.14159265359\n#define HALF_PI 1.5707963267948966\n#define TAU 6.28318530718\n#define PHI 1.618033988749895\n\n\n// --------------------------------------------------------\n// Utils\n// --------------------------------------------------------\n\n#define saturate(x) clamp(x, 0., 1.)\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat range(float vmin, float vmax, float value) {\n  return (value - vmin) / (vmax - vmin);\n}\n\nfloat rangec(float a, float b, float t) {\n    return clamp(range(a, b, t), 0., 1.);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n    vec2 d = abs(p) - b;\n    return length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\nvec3 cartToPolar(vec3 p) {\n    float x = p.x; // distance from the plane it lies on\n    float a = atan(p.y, p.z); // angle around center\n    float r = length(p.zy); // distance from center\n    return vec3(x, a, r);\n}\n\nvec3 polarToCart(vec3 p) {\n    return vec3(\n        p.x,\n        sin(p.y) * p.z,\n        cos(p.y) * p.z\n    );\n}\n\nvec2 closestPointOnLine(vec2 line, vec2 point){\n    line = normalize(line);\n    float d = dot(point, line);\n    return line * d;\n}\n\n// Closest of two points\nvec3 closestPoint(vec3 pos, vec3 p1, vec3 p2) {\n    if (length(pos - p1) < length(pos - p2)) {\n        return p1;\n    } else {\n        return p2;\n    }\n}\n\n// --------------------------------------------------------\n// Helix\n// --------------------------------------------------------\n\n// Closest point on a helix for one revolution\nvec3 closestHelixSection(vec3 p, float lead, float radius) {\n\n    p = cartToPolar(p);\n    p.y *= radius;\n\n    vec2 line = vec2(lead, radius * PI * 2.);\n    vec2 closest = closestPointOnLine(line, p.xy);\n\n    closest.y /= radius;\n    vec3 closestCart = polarToCart(vec3(closest, radius));\n\n    return closestCart;\n}\n\n// Closest point on a helix for infinite revolutions\nvec3 closestHelix(vec3 p, float lead, float radius) {\n    float c = pMod1(p.x, lead);\n    vec3 offset = vec3(lead, 0, 0);\n    vec3 A = closestHelixSection(p, lead, radius);\n    vec3 B = closestHelixSection(p + offset, lead, radius) - offset;\n    vec3 C = closestHelixSection(p - offset, lead, radius) + offset;\n    vec3 closest = closestPoint(p, A, closestPoint(p, B, C));\n    closest += offset * c;\n    return closest;\n}\n\n// Cartesian to helix coordinates\nvoid pModHelix(inout vec3 p, float lead, float radius) {\n    vec3 closest = closestHelix(p, lead, radius);\n    float helixAngle = atan((2. * PI * radius) / lead);\n    vec3 normal = normalize(closest - vec3(closest.x,0,0));\n    vec3 tangent = vec3(1,0,0) * rotationMatrix(normal, helixAngle);\n    float x = (closest.x / lead) * radius * PI * 2.;\n    float y = dot(p - closest, cross(tangent, normal));\n    float z = dot(p - closest, normal);\n    p = vec3(x, y, z);\n}\n\nfloat pModHelixScale(inout vec3 p, float lead, float innerRatio) {\n    float radius = mix(.25, .5, innerRatio);\n    pModHelix(p, lead, radius);\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\nfloat pModHelixUnwrap(inout vec3 p, float lead, float innerRatio, float t) {\n    float radius = mix(.25, .5, innerRatio);\n    float width = cos(asin(t));\n    float adjust = (1. / width);\n    float offset = ((.5 * adjust) - .5) * 7.;\n\n    vec3 pp = p;\n    pp.z -= radius;\n    pR(pp.xy, PI * -.5);\n    pp.x *= -1.;\n\n    p.z += offset;\n    radius += offset;\n    pModHelix(p, lead, radius);\n\n    p = mix(p, pp, rangec(.8, 1., t));\n\n    float scale = mix(.5, 0., innerRatio);\n    p /= scale;\n    return 1. / scale;\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float dist;\n    vec3 albedo;\n    int id;\n};\n\nfloat anim(float t, float index) {\n    float overlap = .5;\n    float steps = 2.;\n    float all = mix(steps, 1., overlap);\n    float width = 1. / (all - 1.);\n    float each = width * (1.- overlap);\n    float start = index * each - width * .5;\n    float end = start + width;\n    return range(start, end, t);\n}\n\nfloat unzip(vec3 p, float t) {\n    float size = guiZipSize;\n    float speed = guiZipSpeed;\n\n    t *= size * speed;\n\n    if (sign(p.y) != sign(p.x)) {\n        float radius = mix(.25, .5, guiInnerRatio);\n        float scale = mix(.5, 0., guiInnerRatio);\n        float factor = radius / scale * PI * 2.;\n        t -= (factor - .5);\n    }\n\n    return range(size, 0., abs(p.x) + size - t);\n}\n\nvoid addPipe(inout float d, vec3 p, float scale, float tt) {\n\n    float t = clamp(0., 1., tt);\n\n    float boundry = 1.;\n    float part;\n    float separate = (\n        rangec(0., boundry * .01, t) * .3 +\n        rangec(boundry * .01, boundry, t) * .7\n    );\n\n    float round = rangec(.0, 1., t);\n\n    part = fBox2(p.yz, vec2(mix(guiLead * 2., .5, separate), .5));\n    part = mix(part, length(p.yz) - .5, round);\n    part /= scale;\n\n    d = mix(d, part, smoothstep(.0, .01, t));\n}\n\nvoid unzipHelixModel(inout float d, inout float scale, inout vec3 p, float lead, float innerRatio, float step, float invert) {\n    float offset = guiZipOffset / lead;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n    float t1 = unzip(p + vec3(offset,0,0) * invert, anim(time, step));\n    addPipe(d, p, scale, t1);\n}\n\nModel map(vec3 p) {\n\n    float part, d, t1, t2, t3, t4;\n    float lead = guiLead;\n    float innerRatio = guiInnerRatio;\n    vec2 uv1, uv2, uv3;\n\n    p /= guiModelScale;\n\n    vec3 pp = p;\n\n    d = 1e12;\n\n    float s = mix(.5, 0., innerRatio);\n\n    float scale = 1./pow(1./s, time);\n\n    pR(p.xy, PI * -.5 * time + guiRotateModel * PI * 2.);\n    \n    p *= scale;\n    p.z += .5;\n\n    scale *= pModHelixUnwrap(p, lead, innerRatio, time);\n    p.x *= -1.;\n    scale *= pModHelixScale(p, lead, innerRatio);\n    p.x *= -1.;\n\n    #ifdef ANOTHER_LEVEL\n        scale *= pModHelixScale(p, lead, innerRatio);\n        p.x *= -1.;\n    #endif\n\n    d = min(d, length(p.yz) - .5);\n    d /= scale;\n\n    unzipHelixModel(d, scale, p, lead, innerRatio, -1., 1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 0., -1.);\n    unzipHelixModel(d, scale, p, lead, innerRatio, 1., 1.);\n\n    d *= guiModelScale;\n\n    return Model(d, vec3(0), 1);\n}\n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 1.5; // max trace distance\nconst float INTERSECTION_PRECISION = .001; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float FUDGE_FACTOR = 1.; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    bool isOutline;\n};\n\n// Faster runtime\nvec3 _calcNormal(vec3 pos){\n    vec3 eps = vec3(.0001,0,0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).dist - map(pos-eps.xyy).dist,\n        map(pos+eps.yxy).dist - map(pos-eps.yxy).dist,\n        map(pos+eps.yyx).dist - map(pos-eps.yyx).dist );\n    return normalize(nor);\n}\n\n// Faster compilation\nconst int NORMAL_STEPS = 6;\nvec3 calcNormal(vec3 pos){\n    vec3 eps = vec3(.001,0,0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++){\n        nor += map(pos + eps * invert).dist * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\n\nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 2.0;\n    float outlineDist = INTERSECTION_PRECISION * 2.0;\n    Model model;\n\n    float outline = .0023;\n    bool isOutline = false;\n    bool miss = false;\n\n    float lastDist = currentDist;\n\n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len);\n        lastDist = currentDist;\n        currentDist = model.dist;\n        miss = currentDist > lastDist;\n        outlineDist = currentDist * -1. + outline;\n        isOutline = outlineDist > .0 && outlineDist < currentDist && miss;\n        if (isOutline) {\n            currentDist = outlineDist;\n        }\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n\n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n\n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, isOutline);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for( int i=0; i<32; i++ )\n    {\n        float h = map( ro + rd*t ).dist;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvec3 doLighting(vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n\n    vec3 col;\n    vec3 up = normalize(vec3(1));\n\n    // lighitng        \n    float occ = mix(calcAO( pos, nor ), 1., .8);\n    vec3  lig = normalize(vec3(0,.2,1));\n    float amb = clamp(dot(nor, up) * .5 + .5, 0., 1.);\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    vec3  hal = normalize( lig-rd );\n    float spe = pow(clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n\n    vec3 cA = vec3(.7,.3,.9);\n    vec3 cB = vec3(.4,.9,.8);\n    vec3 cC = vec3(.7,0,.7);\n\n    col = mix(cA, cB, rangec(.0, 1., dot(-rd, nor))); // need better ramp\n    col = mix(col, vec3(.8,.5,1), rangec(.5, 1., dif) * .5);\n    col += cC * rangec(.5, 1., dif) * .1;\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 ) * .9;\n\n    vec3 lin = vec3(0);\n    lin += .5 * dif;\n    lin += .1 * spe * dif;\n    lin += .2 * fre * occ;\n    lin += .5 * amb * occ;\n    lin += .4 * occ;\n    col = col*lin;\n\n    return col;\n}\n\nvoid render(inout vec3 color, Hit hit){\n\n    vec3 background = vec3(.1)* vec3(.5,0,1);\n    background = color;\n\n    if (hit.isBackground) {\n        color = background;\n        return;\n    }\n\n    if (hit.isOutline) {\n        color = vec3(background * .33);\n    } else {\n        vec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    }\n\n    float fog = length(camPosition - hit.pos);\n    fog = smoothstep(float(MAX_TRACE_DISTANCE) * .36, float(MAX_TRACE_DISTANCE), fog);\n    color = mix(color, background, fog);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n\n    vec3 color = mix(vec3(.4,.3,.5) * .9, vec3(.6), -.2);\n\n    vec3 bgA = vec3(.6,.5,.8) * .55;\n    vec3 bgB = vec3(.7,.9,1.) * .5;\n    color = mix(bgA, bgB, dot(p, normalize(vec2(.2,-.6))) * .5);\n\n    time = iTime;\n    time *= .7;\n    time = mod(time, 1.);\n\n    float camDist = length(camPosition);\n\n    mat4 camMat = cameraMatrix;\n    float focalLength = guiFocal;\n    vec3 rd = normalize(\n        (vec4(p, -focalLength, 1) * camMat).xyz\n    );\n\n    Hit hit = raymarch(CastRay(camPosition, rd));\n\n    render(color, hit);\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float vig = pow(\n        16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y),\n        0.075\n    );\n    color *= vec3(.9, .95, 1.) * vig * 1.1;\n\n    color = mix(color, vec3(pow(length(color * .6), 2.)), .1);\n    color *= 1.05;\n    color = pow(color, vec3(1.2,1.3,1.2));\n\n    fragColor = vec4(color,1.0);\n}\n\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "aa44711", "parent": null, "id": "46201.0"}