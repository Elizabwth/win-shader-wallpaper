{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n// ShaderToy compatibility layer\n\nfloat iTime = time;\nvec2 iMouse = mouse + resolution.xy/2.0;\nvec2 iResolution = resolution;\n\nvec3 texture(sampler2D t, vec2 p) {\n  return texture2D(t, p).xyz;\n}\n\nvoid mainImage( out vec4 iFragColor, in vec2 fragCoord );\n\nvoid main( void ) {\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n\n// Original shader from https://www.shadertoy.com/view/XtfSWX\n// Skin peeler\n// by Dave Hoskins\n// Originally from Xyptonjtroz by nimitz (twitter: @stormoid)\n// Edited by Dave Hoskins, by changing atmosphere with quite a few lighting changes & added audio\n\n#define ITR 500\n#define FAR 150.\n#define time iTime\n\n/*\n\tBelievable animated volumetric dust storm in 7 samples,\n\tblending each layer in based on geometry distance allows to\n\trender it without visible seams. 3d Triangle noise is \n\tused for the dust volume.\n\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\n// ShaderToy compatibility layer\n\nfloat iTime = time;\nvec2 iMouse = mouse + vec2(0.1, 0.5);\nvec2 iResolution = resolution;\n\nvec3 texture(sampler2D t, vec2 p) {\n  return texture2D(t, p).xyz;\n}\n\nvoid mainImage( out vec4 iFragColor, in vec2 fragCoord );\n\nvoid main( void ) {\n  mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n\tFurther explanation of the dust generation...\n\t\t\n\tThe basic idea is to have layers of gradient shaded volumetric\n\tanimated noise. The problem is when geometry is intersected\n\tbefore the ray reaches the far plane. A way to smoothly blend\n\tthe low sampled noise is needed.  So I am blending (smoothstep)\n\teach dust layer based on current ray distance and the solid \n\tinteresction distance. I am also scaling the noise taps\tas a \n\tfunction of the current distance so that the distant dust doesn't\n\tappear too noisy and as a function of current height to get some\n\t\"ground hugging\" effect.\n\t\n*/\n\nuniform float sigma;     // The sigma value for the gaussian function: higher value means more blur\n                         // A good value for 9x9 is around 3 to 5\n                         // A good value for 7x7 is around 2.5 to 4\n                         // A good value for 5x5 is around 2 to 3.5\n                         // ... play around with this based on what you need :)\n\nuniform float blurSize;  // This should usually be equal to\n                         // 1.0f / texture_pixel_width for a horizontal blur, and\n                         // 1.0f / texture_pixel_height for a vertical blur.\n\nuniform sampler2D blurSampler;  // Texture that will be blurred by this shader\n\n\n// The following are all mutually exclusive macros for various \n// seperable blurs of varying kernel size\n\nconst float numBlurPixelsPerSide = 2.0;\nconst vec2  blurMultiplyVec      = vec2(1.0, 0.0);\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\n// This only exists to get this shader to compile when no macros are defined\nfloat Hash(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat Noise3d(in vec3 p)\n{\n    vec2 add = vec2(1.0, 0.0);\n\tp *= 10.0;\n    float h = 0.0;\n    float a = .3;\n    for (int n = 0; n < 4; n++)\n    {\n        vec3 i = floor(p);\n        vec3 f = fract(p); \n        f *= f * (3.0-2.0*f);\n\n        h += mix(\n            mix(mix(Hash(i), Hash(i + add.xyy),f.x),\n                mix(Hash(i + add.yxy), Hash(i + add.xxy),f.x),\n                f.y),\n            mix(mix(Hash(i + add.yyx), Hash(i + add.xyx),f.x),\n                mix(Hash(i + add.yxx), Hash(i + add.xxx),f.x),\n                f.y),\n            f.z)*a;\n         a*=.5;\n        p += p;\n    }\n    return h;\n}\nvec3 Clouds(vec3 sky, vec3 rd)\n{\n    \n    rd.y = max(rd.y, 0.0);\n    float ele = rd.y;\n    float v = (200.0)/rd.y;\n\n    rd.y = v;\n    rd.xz = rd.xz * v - time*8.0;\n\trd.xz *= .0004;\n    \n\tfloat f = Noise3d(rd.xzz*3.) * Noise3d(rd.zxx*1.3)*2.5;\n    f = f*pow(ele, .5)*2.;\n  \tf = clamp(f-.15, 0.01, 1.0);\n\n    return  mix(sky, vec3(1),f );\n}\n#define SUN_COLOUR  vec3(1., .95, .85)\n\nvec3 Sky(vec3 rd, vec3 ligt)\n{\n    rd.y = max(rd.y, 0.0);\n    \n    vec3 sky = mix(vec3(.1, .15, .25), vec3(.8), pow(.8-rd.y, 3.0));\n    return  mix(sky, SUN_COLOUR, min(pow(max(dot(rd,ligt), 0.0), 4.5)*1.2, 1.0));\n}\n\n\n\n#define MOD3 vec3(.16532,.17369,.15787)\nfloat brightPassThreshold;\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvec3 bloom(in vec3 col){\n\tvec3 luminanceVector = vec3(0.2125, 0.7154, 0.0721);\n    vec3 c = col;\n    float luminance = dot(luminanceVector, c.xyz);\n    luminance = max(0.0, luminance - brightPassThreshold);\n    c.xyz *= sign(luminance);\n\treturn c;\n   // c.a = 1.0;\n}\n\nfloat height(in vec2 p)\n{\n    p *= 0.2;\n    return sin(p.y)*0.4 + sin(p.x)*0.4;\n}\n\n//smooth min form iq\nfloat smin( float a, float b)\n{\n    const float k = 0.7;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyy) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+9.19);\n    return fract(vec2(p3.x * p3.y, p3.z*p3.x));\n}\n\nfloat vine(vec3 p, in float c, in float h)\n{\n    p.y += sin(p.z*.5625+1.3)*1.5-.5;\n    p.x += cos(p.z*.4575)*1.;\n  //  p.z -=.3;\n    vec2 q = vec2(mod(p.x, c)-c/2., p.y);\n    return length(q) - h -sin(p.z*3.+sin(p.x*7.)*0.5+time)*0.13;\n}\n\nfloat map(vec3 p)\n{\n    p.y += height(p.zx);\n    \n    vec3 bp = p;\n    vec2 hs = hash22(floor(p.zx/2.));\n    p.zx = mod(p.zy,1.)-0.001;\n    \n    float d = p.y+1.1;\n    p.y -= hs.x*0.4-0.15;\n    p.zx += hs*1.3;\n    d = smin(d, length(-p)-hs.y*0.4);\n    \n    d = smin(d, vine(bp+vec3(1.8,0.,0),15.,.8) );\n    d = smin(d, vine(bp.zyx+vec3(0.,0,17.),20.,0.75) );\n    \n    return d*1.1;\n}\n\nfloat Occ(vec3 p)\n{\n    float h = 0.0;\n    h  = clamp(map(p), 0.5, 1.0);\n \treturn sqrt(h);   \n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n    float precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t   \th = map(ro+rd*d);\n        \n    }\n\treturn d;\n}\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg);\n\n        bp *= 2.;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n   p.x += time;\n   p.z += time*.5;\n    \n    return triNoise3d(p*2.2/(d+8.0))*(smoothstep(.7,.0,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .5;\n    for(int i=0; i<7; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n        col = mix(col,vec3(.85, .65, .5),rz*clamp(smoothstep(d,d*5.1,mt),0.,0.9) );\n        d *= 1.8;\n        if (d>mt)break;\n    }\n    return col;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.05;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat bnoise(in vec3 p)\n{\n    float n = sin(triNoise3d(p*3.)*7.)*0.4;\n    n += sin(triNoise3d(p*1.5)*7.)*0.2;\n    return (n*n)*0.01;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(.005,0);\n    float n0 = bnoise(p);\n    vec3 d = vec3(bnoise(p+e.xyy)-n0, bnoise(p+e.yxy)-n0, bnoise(p+e.yyx)-n0)/e.x;\n    n = normalize(n-d*2.5/sqrt(ds));\n    return n;\n}\n\nfloat shadow(in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<20; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 4.*h/t );\n        t += clamp( h, 0.2, 1.5 );\n            }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 q = fragCoord.xy/iResolution.xy;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.1,0.07):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t\n\tvec3 ro = vec3(smoothstep(0.,1.,tri(time*.6)*2.)*0.1, smoothstep(0.,1.,tri(time*1.2)*2.)*0.05, -time*0.6);\n    ro.y -= height(ro.zx)+0.07;\n    mo.x += smoothstep(0.7,1.,sin(time*.35))-1.5 - smoothstep(-.7,-1.,sin(time*.35));\n \n    vec3 eyedir = normalize(vec3(cos(mo.x),mo.y*2.-0.2+sin(time*.75*1.37)*0.15,sin(mo.x)));\n    vec3 rightdir = normalize(vec3(cos(mo.x+1.5708),0.,sin(mo.x+1.5708)));\n    vec3 updir = normalize(cross(rightdir,eyedir));\n\tvec3 rd=normalize((p.x*rightdir+p.y*updir)*1.+eyedir);\n\t\n    vec3 ligt = normalize( vec3(.5, .5, -.2) );\n    \n\tfloat rz = march(ro,rd);\n\tvec3 sky = Sky(rd, ligt);\n    \n    vec3 col = sky;\n    vec3 fogb = mix(vec3(1.5, .4,.4), vec3(1.,.9,.8), min(pow(max(dot(rd,ligt), 0.0), 1.5)*1.25, 1.0));\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        float d = distance(pos,ro);\n        nor = bump(pos,nor,d);\n        float shd = shadow(pos,ligt,0.1,1.);\n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 )*shd;\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),3.)*shd;\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 1.5 );\n        vec3 brdf = dif*vec3(1.00)+abs(nor.y)*.24;\n        col = clamp(mix(vec3(.7,0.4,.3),vec3(.3, 0.1, 0.1),(pos.y+.5)*.25), .0, 1.0);\n        col *= (sin(bnoise(pos*.1)*250.)*0.5+0.0);\n        col = col*brdf + spe* fre*sky;\n\t\n    }\n    \n    //ordinary distance fog first\n    col = mix(sky, col, smoothstep(FAR-10000.0,FAR,rz));\n    \n    //then volumetric fog\n    col = fog(col, ro, rd, rz);\n    col *= bloom(col*sky) * 4.;\n    //post...\n\n\t\n    col = smoothstep(0.0, 1.0, col);\n    \n    col *= .5+.5*pow(70. *q.x*q.y*(1.0-q.x)*(1.0-q.y), .1);\n    \n\t  // Incremental Gaussian Coefficent Calculation (See GPU Gems 3 pp. 877 - 889)\n  vec3 incrementalGaussian;\n  incrementalGaussian.x = 1.0 / (sqrt(2.0 * 3.14) * 3.0);\n  incrementalGaussian.y = exp(-0.5 / (sigma * sigma));\n  incrementalGaussian.z = incrementalGaussian.y * incrementalGaussian.y;\n\n  vec4 avgValue = vec4(0., 0.0, 0.0, 0.0);\n  float coefficientSum;\n\n  // Take the central sample first...\n  avgValue +=  fragColor;\n  coefficientSum += col.x;\n  incrementalGaussian.xy *= incrementalGaussian.yz;\n\n  // Go through the remaining 8 vertical samples (4 on each side of the center)\n  for (float i = 1.0; i <= numBlurPixelsPerSide; i++) { \n\t   avgValue +=  i * blurSize * \n                          avgValue * incrementalGaussian.x;         \n    incrementalGaussian.xy *= incrementalGaussian.yz;\n    //coefficientSum += 0.1 ;\n\t  avgValue/=coefficientSum;\n  }\n\n    \n\tfragColor = vec4( col * smoothstep(0.0, .0, coefficientSum), .5 ) + coefficientSum * avgValue;\n}\n", "user": "4d26240", "parent": "/e#47342.4", "id": 47471}