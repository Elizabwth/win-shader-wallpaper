{"code": "precision mediump float;\n#define TUNNEL_DIST 500.\n\nuniform float time;\nuniform vec2 resolution;\n\nfloat iTime = time;\nvec2 iResolution = vec2(resolution.x, resolution.y);\n\nconst float PI = 3.14;\n\nfloat mapSphere(vec3 p) {\n\treturn length(p) - 1.0;\n}\n\nfloat mapCube(vec3 p) {\n \treturn length(max(abs(p)- vec3(0.5, 0.5, 0.5), 0.0));\n}\n\nfloat mapTorus(vec3 p) {\n\tvec2 q = vec2(length(p.xz) - 0.9, p.y);\n \treturn length(q) - 0.1;\n}\n\nfloat mapPlane(vec3 p) {\n\tvec4 n = vec4(0.1, 0.0, 0.0, 1.0);\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat repeat(vec3 p, vec3 c) {\n    vec3 q = mod(p, c) - 0.5 * c;\n    return mapCube(q);\n}\n\nfloat trace(vec4 o, vec4 r, mat4 transforms) {\n\tfloat t = 0.0;\n    for (int i = 0; i < 32; i++) {\n    \t\n        vec4 p = o + r * t;\n    \t\n        /*\n\t\t\tRepeatition code\n\t\t*/\n        p.x = mod(p.x + 1.0, 2.0) - 1.;\n        p.y = mod(p.y + 1.0, 2.0) - 1.;\n        p.z = mod(p.z + 1.0, 2.0) - 1.;\n        \n        \n        float d = mapCube((transforms * p).xyz);\n        t += d * 0.5;\n    \n    }\n    return t;\n}\n\nmat4 rotateX(float a) {\n\treturn mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, cos(a), sin(a), 0.0,\n        0.0, -sin(a), cos(a), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateY(float a) {\n\treturn mat4(\n    \tcos(a), 0.0, sin(a), 0.0,\n        0.0, 1.0, 0.0, 0.0, \n        -sin(a), 0.0, cos(a), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 rotateZ(float a) {\n\treturn mat4(\n    \tcos(a), sin(a), 0.0, 0.0,\n        -sin(a), cos(a), 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 translate(float x, float y, float z) {\n\treturn mat4(\n    \t1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x, y, z, 1.0\n    );\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float time = iTime;\n\t\n    /*\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1.0);\n\t*/\n    \n    // as suggested :3\n   \tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec4 p = vec4(uv, 1.0, 1.0);\n    \n    vec3 l = vec3(p.xyz - vec3(0.0, 0.0, -3.));\n   \tvec3 n = normalize(p.xyz);\n    \n    vec3 lp = normalize(l - p.xyz);\n    vec3 lc = vec3(dot(lp, n));\n    vec3 color = vec3(1.0, 0.0, 0.0);\n    \n    vec4 r = normalize(p);\n    vec4 o = vec4(\n       \t-1.0,\n        2. * cos(iTime / 2.),\n       \tiTime,\n        1.0\n    );\n    \n    float t = trace(o, r, rotateX(iTime) * rotateY(iTime));\n   \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog * lc * color);\n    \n    fragColor = vec4(fc, 1.0);\n\n}\n\n\nvoid main() {\n\tiTime = time;\n\tiResolution = resolution;\n\tmainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "c7d64f5", "parent": null, "id": 47336}