{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4ddfDS\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/*\n    I've been playing with partitioned space marching techniques recently \n    and I've been struggling to get movement between domain repeaated objects in cells.\n    This one is based on approach by Nimitz in Sparse Grid Marching and it works a treat\n    https://www.shadertoy.com/view/XlfGDs\n\n    Other interesting approaches I've found\n    https://www.shadertoy.com/view/Xljfzw a great example from Mattz\n\n\t... and the branchless approach by fb39ca4\n    https://www.shadertoy.com/view/4dX3zl\n\n    ... and my favourite voxel marcher IQ\n    https://www.shadertoy.com/view/4dfGzs\n*/\n\n#define EPS 0.001\n#define FAR 100.\n#define T iTime\n#define PI 3.141592\n\nconst float c = 1.0;\nconst float ch = c * 0.5;\nconst float ch2 = ch + 0.01;\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Shane\nvec3 path(float t) {\n    float a = sin(t * PI / 24.0 + 1.7);\n    float b = cos(t * PI / 24.0);\n    return vec3(a * 2.0, b * a, t);    \n} \n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//IQ - sphere functions\nvec2 sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(0.0);\n    h = sqrt(h);\n    float tN = -b - h;\n    float tF = -b + h;\n    return vec2(tN, tF);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n\n//Nimitz\nfloat dBox(vec3 ro, vec3 rd)  {\n    vec3 m = 1.2 / rd;\n    vec3 t = -m * ro + abs(m) * ch2;\n\treturn min(min(t.x, t.y), t.z);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec4 map(vec3 rp, vec3 rd) {\n\n    //vec4 sound = texture(iChannel0, vec2(0.5) / iResolution.xy);\n    \n    //rp.y = mod(rp.z, 2.0) < 1.0 ? rp.y : rp.y + min(1.0, mod(T, 2.0));\n    //rp.x = mod(rp.z, 2.0) < 1.0 ? rp.x : rp.x + max(1.0, mod(T, 2.0));\n    rp.y = mod(rp.z, 2.0) < 1.0 ? rp.y : rp.y + T;\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 q  = mod(rp, c) -ch;\n   \tfloat t = dBox(q, rd); //Base distance is cell exit distance\n    \n    if (mod(rp.z - 2.0, 24.0) > 18.0) {\n        col = noise(floor(rp)) > 0.9 ? vec3(1.0, 0.7, 0.1) : vec3(0.0);\n        t = min(t, sdBox(q, vec3(0.2)));\n    }\n    \n    return vec4(col, t);\n}\n\nvec4 castRay(vec3 ro, vec3 rd) {\n    \n    float t = 0.0;\n    vec3 col = vec3(0.0);\n    \n    for (int i = 0; i < 98; i++) {\n        vec4 ns = map( ro + rd * t, rd);\n        if (ns.w < EPS || t > FAR) {\n            col = ns.xyz;\n            break;\n    \t}\n        t += ns.w;\n    }\n\t\n    return vec4(col, t);\n}\n\nvec3 normal(vec3 rp, vec3 rd) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(rp + e.yxx, rd).w + e.xxy * map(rp + e.xxy, rd).w + \n\t\t\t\t\t e.xyx * map(rp + e.xyx, rd).w + e.yyy * map(rp + e.yyy, rd).w);   \n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd, inout vec3 lp) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    vec3 lookAt = vec3(0.0, 0.0, T * 6.0);\n    ro = lookAt + vec3(0.0, 0.0, -1.0);\n    lp = lookAt + vec3(0.0, 0.0, 10.0 + sin(T * 0.2) * 6.0);\n\n    lookAt = path(lookAt.z);\n    ro = path(ro.z);\n\tlp = path(lp.z);\n      \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n    rd.xy *= rot(sin(-ro.x  * 0.5) * 0.4);//isdive\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\t\n\t\n    vec3 pc = vec3(0.0), ro, rd, lp;\n    setupCamera(fragCoord, ro, rd, lp);\n    float mint = FAR;\n    \n\tvec4 scene = castRay(ro,rd);\n    \n    if (scene.w < FAR) {\n        \n        mint = scene.w;\n        vec3 rp = ro + rd * scene.w;\n        vec3 n = normal(rp, rd);\n        \n        //camera light\n        vec3 ld = normalize(vec3(4.0, 5.0, -4.0));\n        float atten = 1.0 / (1.0 + scene.w * scene.w * 0.05);\n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 64.0);\n        vec3 ac = vec3(1.0) * max(dot(ld, n), 0.05) * 0.2;\n        ac += vec3(0.1, 0.0, 0.9) * max(0.0, n.y) * 0.1;\n        ac += vec3(1.0) * spec * atten;\n        \n        //glowball light\n        ld = normalize(lp - rp);\n        float lt = length(lp - rp);\n        atten = 1.0 / (1.0 + lt * lt * 0.03);\n        spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 64.0);\n        //shadow\n        vec4 shadow = castRay(rp - rd * 0.01, ld);\n        float sh = shadow.w > 0.0 && shadow.w < lt ? 0.0 : 1.0;\n        vec3 gc = vec3(1.0, 0.5, 0.0) * max(dot(ld, n), 0.05) * atten * sh;\n        atten = 1.0 / (1.0 + lt * lt * 0.08);\n        gc += vec3(1.0, 0.8, 0.0) * max(dot(ld, n), 0.05) * atten * sh;\n        gc += vec3(1.0, 1.0, 0.3) * spec * atten * sh;\n        \n        pc = ac + gc;\n        pc += scene.xyz;\n    }\n    \n    //glow light\n    vec2 si = sphIntersect(ro, rd, vec4(lp, 1.0));\n    if (si.x > 0.0 && si.x < mint) {\n        float w = sphDensity(ro, rd, vec4(lp, 1.0), FAR);\n        if (w > 0.0) {\n        \tpc += vec3(1.0, 0.2, 0.0) * w * w;    \n        \tpc += vec3(1.0, 0.5, 0.0) * w * w * w;    \n        \tpc += vec3(1.0, 1.0, 0.0) * w * w * w * w * w;    \n        }\n    }\n\n\tfragColor = vec4(pc, 1.0 );\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "1eca43", "parent": null, "id": 47308}