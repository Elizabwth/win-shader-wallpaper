{"code": "// JvB: slowed down camera movement which seems appropriate for this majestic shader\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(cos(n)*43758.5453123);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\n\n\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+ 57.0);\n    float d = hash(n+ 58.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t30.0*f*f*(f*(f-2.0)+1.0)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    float res = mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nmat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\t\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nfloat terrain( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for(int i=0;i<5; i++)\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p=mat2(1.6,-1.2,1.2,1.6)*p;\n    }\n\n    return a*150.0;\n}\n\nfloat terrain2( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for(int i=0;i<14; i++)\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p=m2*p;\n    }\n\n    return a*150.;\n}\n\n\nfloat map( in vec3 p )\n{\n\tfloat h = terrain(p.xz);\n\t\n\tfloat ss = 0.03;\n\tfloat hh = h*ss;\n\tfloat fh = fract(hh);\n\tfloat ih = floor(hh);\n\tfh = mix( sqrt(fh), fh, smoothstep(50.0,40.0,h) );\n\th = (ih+fh)/ss;\n\t\n    return p.y - h;\n}\n\nfloat map2( in vec3 p )\n{\n\tfloat h = terrain2(p.xz);\n\n\t\n\tfloat ss = 0.03;\n\tfloat hh = h*ss;\n\tfloat fh = fract(hh);\n\tfloat ih = floor(hh);\n\tfh = mix( sqrt(fh), fh, smoothstep(50.0,140.0,h) );\n\th = (ih+fh)/ss;\n\t\n    return p.y - h;\n}\n\nbool jinteresct(in vec3 rO, in vec3 rD, out float resT )\n{\n    float h = 0.0;\n    float t = 0.0;\n\tfor( int j=0; j<120; j++ )\n\t{\n        if( t>2000.0 ) break;\n\t\t\n\t    vec3 p = rO + t*rD;\nif( p.y>300.0 ) break;\n        h = map( p );\n\n\t\tif( h<0.1 )\n\t\t{\n\t\t\tresT = t; \n\t\t\treturn true;\n\t\t}\n\t\tt += max(0.1,0.5*h);\n\n\t}\n\n\tif( h<5.0 )\n    {\n\t    resT = t;\n\t    return true;\n\t}\n\treturn false;\n}\n\nfloat sinteresct(in vec3 rO, in vec3 rD )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfor( int j=0; j<50; j++ )\n\t{\n        if( t>1000.0 ) break;\n\t    vec3 p = rO + t*rD;\n\n        float h = map( p );\n\n\t\tif( h<0.1 )\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\n\t}\n\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n\tfloat e = 0.001;\n\te = 0.001*t;\n    vec3  eps = vec3(e,0.0,0.0);\n    vec3 nor;\n    nor.x = map2(pos+eps.xyy) - map2(pos-eps.xyy);\n    nor.y = map2(pos+eps.yxy) - map2(pos-eps.yxy);\n    nor.z = map2(pos+eps.yyx) - map2(pos-eps.yyx);\n    return normalize(nor);\n}\n\nvec3 camPath( float time )\n{\n    vec2 p = 600.0*vec2( cos(1.4+0.37*time*0.1), \n                         cos(3.2+0.31*time*0.1) );\n\n\treturn vec3( p.x, 0.0, p.y );\n}\n\nvoid main(void)\n{\n    vec2 xy = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy;\n\n\tvec2 s = xy*vec2(1.75,1.0);\n\n    float time = time*.15;\n\n\tvec3 light1 = normalize( vec3(  0.4, 0.22,  0.6 ) );\n\tvec3 light2 = vec3( -0.707, 0.000, -0.707 );\n\n\n\tvec3 campos = camPath( time );\n\tvec3 camtar = camPath( time + 3.0*10.0 );\n\tcampos.y = terrain( campos.xz ) + 15.0;\n\tcamtar.y = campos.y*0.5;\n\n\tfloat roll = 0.1*cos(0.1*time);\n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( s.x*cu + s.y*cv + 1.6*cw );\n\n\n\tfloat sundot = clamp(dot(rd,light1),0.0,1.0);\n\tvec3 col;\n    float t;\n    if( !jinteresct(campos,rd,t) )\n    {\n     \tcol = 0.9*vec3(0.97,.99,1.0)*(1.0-0.3*rd.y);\n\t\tcol += 0.2*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n\t}\n\telse\n\t{\n\t\tvec3 pos = campos + t*rd;\n\n        vec3 nor = calcNormal( pos, t );\n\n\t\tfloat dif1 = clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat dif2 = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n\t\tfloat sh = 1.0;\n\t\tif( dif1>0.001 ) \n\t\t\tsh = sinteresct(pos+light1*20.0,light1);\n\t\t\n\t\tvec3 dif1v = vec3(dif1);\n\t\tdif1v *= vec3( sh, sh*sh*0.5+0.5*sh, sh*sh );\n\n\t\tfloat r = noise( 7.0*pos.xz );\n\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.10,0.05,0.03), vec3(0.13,0.10,0.08), clamp(terrain2( vec2(pos.x,pos.y*48.0))/200.0,0.0,1.0) );\n\t\tcol = mix( col, 0.17*vec3(0.5,.23,0.04)*(0.50+0.50*r),smoothstep(0.70,0.9,nor.y) );\n        col = mix( col, 0.10*vec3(0.2,.30,0.00)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y) );\n  \t    col *= 01.75;\n         // snow\n       \n\n\t\t\n\t\tvec3 brdf  = 2.0*vec3(0.17,0.19,0.20)*clamp(nor.y,0.0,1.0);\n\t\t     brdf += 6.0*vec3(1.00,0.95,0.80)*dif1v;\n\t\t     brdf += 2.0*vec3(0.20,0.20,0.20)*dif2;\n\n\t\tcol *= brdf;\n\t\t\n\t\tfloat fo = 1.0-exp(-pow(0.0015*t,1.5));\n\t\tvec3 fco = vec3(0.7) + 0.6*vec3(0.8,0.7,0.5)*pow( sundot, 4.0 );\n\t\tcol = mix( col, fco, fo );\n\t}\n\n\t\n\n\tvec2 uv = xy*0.5+0.5;\n\tcol *= 0.9 + 0.3*pow(6.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y),10.1);\n\tgl_FragColor=vec4(col,1.0);\n}\n", "user": "4d26240", "parent": "/e#7026.0", "id": 47493}