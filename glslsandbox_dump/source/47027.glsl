{"code": "\n\n\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n// marching stuff\n#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 100\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.7\n\n\n#define SPHERE_RADIUS 1.5\n#define BOX_X 1.0\n#define BOX_Y 0.4\n#define BOX_Z 1.0\n\nmat2 rotmat() {\n    float a = time;\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\t\t\t\t\t// distance functions from iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec3 p )\n{\n    vec2 um = mouse.xy / resolution.xy-.5;\n    \n    vec3 sPos = vec3(p.x - sin(time) * 2., p.y, p.z);\n    float d1 = sdSphere(sPos, SPHERE_RADIUS);\n    float d2 = sdBox(p, vec3(BOX_X, BOX_Y, BOX_Z));\n    return smin( d1, d2, 8.0 );\n}\n\nvec2 scene(vec3 position)\n{\n    \n    vec3 translate = vec3(0.0, 0.0, 1.0);\n   \tfloat materialID = 1.0;\n    \n    mat2 r = rotmat();\n    \n    vec3 box_pos = position - translate;\n    \n    box_pos.yz *= r; // rotate\n    \n    float distance_1 = opBlend(box_pos); \n    \n    \n    return vec2(distance_1, materialID);\n    \n   \n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    \n    float total_distance = NEAR_CLIPPING_PLANE;\n    \n     for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n     {\n         \n        vec2 result = scene(position + direction * total_distance); \n        \n        if(result.x < EPSILON)\n        {\n         \treturn vec2(total_distance, result.y);   \n            \n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n         \n        if(total_distance > FAR_CLIPPING_PLANE)\n            break;\n         \n     }\n     \n     return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n\tn.y\t= scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n\tn.z\t= scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n\treturn normalize(n);\n\n}\n\n\nvoid main( void )\n{\n    vec2 uv = 2.0*vec2(gl_FragCoord.xy - 0.5*resolution.xy)/resolution.y;\n  \n    vec2 um = mouse.xy / resolution.xy-.5;\n    um.x *= resolution.x/resolution.y;\n \n\tvec3 camera_origin = vec3(0.0, 0.0, -6.0);\n        \n   \tvec3 direction = normalize(vec3(uv, 2.5));\n    \n    vec2 result = raymarch(camera_origin, direction);\n    \n    \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    \n    if(result.y == 1.0)\n    \tmaterialColor = vec3(1.0, 1.0, 1.0);\n    \n    vec3 intersection = camera_origin + direction * result.x;\n    vec3 nrml = normal(intersection, 0.001);\n    vec3 light_dir = normalize(vec3(1.0, 0.0, -1.0));\n    float diffuse = dot(light_dir, nrml);\n  \n    diffuse = max(0.2, diffuse);\n    \n    vec3 light_color = vec3(1.4, 1.2, 0.7) * 1.5;\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    \n     // Combine light\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    \n    \n    \n    if(result.x == FAR_CLIPPING_PLANE)\n    \t gl_FragColor = vec4(0.1, 0.5, 0.9, 1.0) * fog;\n    else\n    \tgl_FragColor = vec4(diffuseLit, 1.0) * fog;\n        \n \n   \n}\n\n\n\n\n\n", "user": "8d8b852", "parent": null, "id": 47027}