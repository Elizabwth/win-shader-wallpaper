{"code": "// co3moz\n// rotating and translating square example 3\n\nprecision mediump float;\nuniform float time;\nuniform vec2 resolution;\n\n#define formula(s) (pixel.x - (s) < square.x && pixel.x + (s)> square.x && pixel.y - (s)< square.y && pixel.y + (s) > square.y)\nvec3 drawSquare(in vec2 pixel, in vec2 square, in vec3 setting) {\n\tif(formula(setting.x) && !(formula(setting.x - setting.y))) return vec3(setting.z / 40.0);\n\treturn vec3(0.0);\n}\n\nvoid main(void) {\n\tfloat angle = sin(time) * 0.3;\n\tmat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); // this is a 2D rotation matrix\n\tvec2 aspect = resolution.xy / min(resolution.x, resolution.y); // for squared tiles, we calculate aspect\n\tvec2 position = (gl_FragCoord.xy / resolution.xy) * aspect; // position of pixel we need to multiply it with aspect, so we get squared tiles\n\tvec2 center = vec2(0.5) * aspect; // 0.5 is center but we need to multiply it with aspect (0.5 isn't center for squared tiles)\n\t\n\tposition *= rotation;\n\tcenter *= rotation;\n\t\n\tvec3 color = vec3(0.0);\n\tfor(int i = 0; i < 40; i++) {\n\t\tvec3 d = drawSquare(position, center + vec2(sin(float(i) / 10.0 + time) / 4.0, 0.0), vec3(0.01 + sin(float(i) / 100.0), 0.01 , float(i)));\n\t\tif(length(d) != 0.0) color = d;//vec3(sin(time),cos(time),0.50); // fix for old graphics card\n\t}\n\tgl_FragColor = vec4(sin(0.2*(time + 3.2))*cos(time*10.*color), 1.0);\n}", "user": "ec0409d", "parent": "/e#46783.2", "id": 46977}