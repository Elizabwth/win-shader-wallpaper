{"code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float \t\ttime;\nuniform vec2 \t\tmouse;\nuniform vec2 \t\tresolution;\nuniform sampler2D \trenderbuffer;\n\n//GDC 2016\n\n\n//uncomment these to change slides\n//#define SLIDE_PYTHAGORAS\n//#define SLIDE_DISTANCE_FUNCTIONS\n//#define SLIDE_DISTANCE_OPERATIONS\n//#define SLIDE_CAMERA\n//#define SLIDE_RAY_STEPS\n//#define SLIDE_DERIVE_NORMALS\n#define SLIDE_LIGHTS_AND_MATERIALS\n\n\n//distance functions\n#ifdef SLIDE_PYTHAGORAS\n\t#define SCENE_PYTHAGORAS\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\t\n\t#define RAYS\t \t\t\t1\n\t#define ITERATIONS \t\t\t1\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t(mouse.x < .5 ? 1. : 1.)\n\t#define\tORTHOGRAPHIC\t\t\t(mouse.x < .5)\n\t#define FOV\t\t\t\t(mouse.x > .85 ? mouse.y * 8. : 3.5)\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\tvec2(1., 0.)\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n\n\n//distance functions\n#ifdef SLIDE_DISTANCE_FUNCTIONS\n\t#define SCENE_DISTANCE_FUNCTIONS\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\t\n\t#define RAYS\t \t\t\t1\n\t#define ITERATIONS \t\t\t1\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t(mouse.x < .5 ? 1. : 1.)\n\t#define\tORTHOGRAPHIC\t\t\t(mouse.x < .5)\n\t#define FOV\t\t\t\t(mouse.x > .85 ? mouse.y * 8. : 3.5)\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\tvec2(1., 0.)\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n\n//distance functions\n#ifdef SLIDE_DISTANCE_OPERATIONS\n\t#define SCENE_DISTANCE_OPERATIONS\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\t\n\t#define RAYS\t \t\t\t1\n\t#define ITERATIONS \t\t\t1\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t(mouse.x < .5 ? 1. : 1.)\n\t#define\tORTHOGRAPHIC\t\t\t(mouse.x < .5)\n\t#define FOV\t\t\t\t(mouse.x > .85 ? mouse.y * 8. : 3.5)\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\tvec2(1., 0.)\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n\n//camera\n#ifdef SLIDE_CAMERA\n\t#define SCENE_SPHERES\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\t\n\t#define PLOT_RAYS\t\t\t1.\n//\t#define RAY_POSITION\t\t\tPLOT_RAYS * 2.\n\t#define RAY_PATH\t\t\tPLOT_RAYS * 1.\n//\t#define RAY_DISTANCE\t\t\tPLOT_RAYS * 1.\n\t#define RAYS\t \t\t\t32\n\t#define ITERATIONS \t\t\t32\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t(mouse.x < .5 ? 1. : 1.)\n\t#define\tORTHOGRAPHIC\t\t\t(mouse.x < .5)\n\t#define FOV\t\t\t\t(mouse.x > .85 ? mouse.y * 8. : 3.5)\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\tvec2(1., 0.)\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n//ray stepping\n#ifdef SLIDE_RAY_STEPS\n\t#define SCENE_SPHERES\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\n\t#define PLOT_RAYS\t\t\t1.\n\t#define RAY_POSITION\t\t\tPLOT_RAYS * 2.\n\t#define RAY_PATH\t\t\tPLOT_RAYS * 1.\n\t#define RAY_DISTANCE\t\t\tPLOT_RAYS * 1.\n\t#define RAY_ANIMATE\t\t\t(mouse.x < .75 ? floor(fract(time/16.) * 24.) : 32.)\n\t#define RAYS\t \t\t\t1\n\t#define ITERATIONS \t\t\t16\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t.5\n\t#define\tORTHOGRAPHIC\t\t\tfalse\n\t#define FOV\t\t\t\t1.25\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\t(mouse.x < .75 ? vec2(1., 0.) : vec2(.5, mouse.y-.5)*8.)\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n//calculating derivatives\n#ifdef SLIDE_DERIVE_NORMALS\n\t#define SCENE_SPHERES\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 1.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 2.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .25\n\t#define PLOT_RAYS\t\t\t.125\n\t#define RAY_POSITION\t\t\tPLOT_RAYS * 2.\n\t#define RAY_PATH\t\t\tPLOT_RAYS * 1.\n\t#define RAY_DISTANCE\t\t\tPLOT_RAYS * 1.\n\t#define PLOT_DERIVATIVE\t\t\t1.\n\t#define DERIVATIVE_LINE_SCALE\t\t.25\n\t#define DERIVATIVE_NORMAL\t\tPLOT_DERIVATIVE * vec3(0., 1., 0.)\n\t#define DERIVATIVE_TANGENT\t\tPLOT_DERIVATIVE * vec3(1., 0., 0.)\n\t#define DERIVATIVE_SAMPLE\t\tPLOT_DERIVATIVE * 1.\n\t#define DERIVATIVE_SAMPLE_SCALE\t\t.125\n\t#define DERIVATIVE_ANIMATE\t\tfloor(fract(time/16.) * 16.)\n\t#define RAYS\t \t\t\t1\n\t#define ITERATIONS \t\t\t16\n\t#define THRESHOLD\t\t\t.01\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t.5\n\t#define\tORTHOGRAPHIC\t\t\tfalse\n\t#define FOV\t\t\t\t1.25\n\t#define VIEWPOINT\t\t\tvec2(-1.75, 0.)\n\t#define VIEWTARGET\t\t\t(mouse.y < .9 ? ((mouse * 2. - 1.) * \tASPECT) : vec2(1., 0.))\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t0\n\t#define\tSHADOW_ITERATIONS\t\t0\n#endif\n\n#ifdef SLIDE_LIGHTS_AND_MATERIALS\n//\t#define SCENE_RED_BALL_ON_CHECKER_FLOOR\n\t#define SCENE_NOISY_RED_BALL_ON_CHECKER_FLOOR\n\t#define PLOT_MAP\t\t\t1.\n\t#define MAP_DISTANCE \t\t\tPLOT_MAP * 2.\n\t#define MAP_MANIFOLD \t\t\tPLOT_MAP * 1.\n\t#define MAP_CONTOUR \t\t\tPLOT_MAP * .125\n\t#define PLOT_LIGHT\t\t\t1.\n\t#define LIGHT_OCCLUSION\t\t\tPLOT_LIGHT * 1.\n\t#define LIGHT_SHADOW\t\t\tPLOT_LIGHT * 1.\n\t#define LIGHT_BRDF\t\t\tPLOT_LIGHT * 1.\n\t#define LIGHT_RAY\t\t\tPLOT_LIGHT * 1.\n\t#define LIGHT_SHADE\t\t\tPLOT_LIGHT * 1.\t\n\t#define RAYS\t \t\t\t1\n\t#define RAY_REFINEMENT\n\t#define ITERATIONS \t\t\t32\n\t#define THRESHOLD\t\t\t.005\n\t#define FARPLANE \t\t\t4.\n\t#define SCALE\t\t\t\t.5\n\t#define FOV\t\t\t\t(mouse.y < .9 ? max(1.,length(VIEWTARGET-\tVIEWPOINT)*4.5) : 3.)\n\t#define ORTHOGRAPHIC\t\t\tfalse\n\t#define VIEWPOINT\t\t\tvec2(-1.5, 0.)\n\t#define VIEWTARGET\t\t\t(mouse.y < .9 ? ((mouse * 2. - 1.) * \tASPECT) : vec2(1., 0.))\n\t#define LIGHT_POSITION\t\t\tvec2(-.5, .95)\n\t#define LIGHT_COLOR\t\t\tvec3(.75, .75, .45)\n\t#define\tOCCLUSION_ITERATIONS\t\t3\n\t#define\tSHADOW_ITERATIONS\t\t6\t\t\n\t#define REFLECTION \t\t\ttrue\n\t#define REFRACTION \t\t\ttrue\n#endif \n\n\n#define RESOLUTION_MIN\t\t\t\tmin(resolution.x, resolution.y)\n#define RESOLUTION_MAX\t\t\t\tmin(resolution.x, resolution.y)\n#define LINE_RESOLUTION\t\t\t\t(256.)\n#define ASPECT\t\t\t\t\tresolution.xy/RESOLUTION_MIN\n#define PI\t\t\t\t\t(4. * atan(1.))\n#define TAU\t\t\t\t\t(8. * atan(1.))\n\n\nstruct ray\n{\n\tvec2  origin;\n\tvec2  position;\n\tvec2  prior;\n  \tvec2  direction;\n  \tfloat range;\n\tfloat travel;\n  \tfloat iteration;\n\tfloat threshold;\n  \tbool  intersection;\n};\n\nstruct material\n{\n  \tfloat id;\n  \tfloat index;\n  \tfloat roughness;\n\tfloat opacity;\n  \tvec2 uv;\n  \tvec2 normal;\n  \tvec2 tangent;\n  \tvec3 color;\n};  \n\nstruct light\n{\n  \tvec2 position;\n  \tvec2 direction;\n  \tvec3 color;\n};\n\n\nstruct plot\n{\n\tvec2 prior;\n\tvec2 position;\n\tvec2 point;\n  \tvec3 ray;\n \tvec3 light;\n\tvec3 color;\n\tvec3 derivative;\n\tvec3 brdf;\n  \tvec3 occlusion;\n  \tvec3 shadow;\n\tvec3 map;\n};\n\nray\t\tconstruct_ray(void);\nmaterial\tconstruct_material(void);\nlight\t\tconstruct_light(void);\nplot\t\tconstruct_plot(const in vec2 position);\n\nfloat \t\tmap(vec2 p);\nvoid \t\tmap(in vec2 p, out float range, out float id);\nvoid \t\tintersect(const in float range, const in float id, inout float minimum, inout float material_id);\n\nvoid \t\tview(in float index, inout ray r);\nvoid \t\temit(inout ray r, inout plot p);\nvoid\t\tderive(inout ray r, inout material m, inout plot p);\nvoid \t\tshade(inout ray r,  inout light l, inout material m, inout plot p);\n\nfloat \t\tshadow(const in vec2 position, const in vec2 direction, inout ray r, inout plot p);\nfloat \t\tdistribution(const in float r, const in float ndh);\nfloat \t\tgeometry(in float i, in float ndl, in float ndv);\nfloat \t\tfresnel(const in float i, const in float ndl);\n\nvoid \t\tassign_material(in ray r, out material m);\n\nvoid \t\tplot_ray(in vec2 position, inout ray r, inout plot p);\n\nfloat \t\tcontour(float x);\nfloat \t\tpoint(vec2 position, float radius);\nfloat \t\tpoint(vec2 position);\nfloat \t\tcircle(vec2 position, float radius);\nfloat \t\tline(vec2 p, vec2 a, vec2 b);\nfloat \t\tbox(vec2 position, vec2 scale);\n\nfloat \t\thash(in float x );\nfloat \t\thash(in vec2 x );\nfloat \t\tvalue_noise(vec2 uv);\nfloat \t\tfbm(vec2 uv);\n\nvec3 \t\thsv(float h, float s,float v);\n\nfloat \t\tface(vec2 position, vec2 normal, float translation);\nfloat \t\tsphere(vec2 position, float radius);\nfloat \t\ttorus(vec2 position, vec2 radius);\nfloat \t\tcube(vec2 position, vec2 scale);\nfloat \t\tsimplex(vec2 position, float scale);\nfloat \t\tfractal(vec2 position, float rotation, float translation, float scale);\nfloat \t\tsegment(vec2 position, vec2 a, vec2 b);\n\nvec2 \t\tcross(in vec2 uv);\nvec2 \t\tproject(vec2 position, vec2 a, vec2 b);\nmat2 \t\trmat(in float t);\n\n#//Scene Map\nvoid map(in vec2 position, out float range, out float id)\n{\n\tvec2 mouse_position\t= (mouse * 2. - 1.) * resolution.xy/resolution.yy;\n\t\n\trange\t\t\t= FARPLANE;\n\tid\t\t\t= 0.;\n\n\t#ifdef SCENE_PYTHAGORAS\n\tfloat material_id\t= 5.;\n\t\n\t\n\tfloat fields[7];\n\tfields[0]\t\t= sphere(position-vec2(.75, 0.), .0);\n\tfields[1]\t\t= min(fields[0], sphere(position+vec2(.75, 0.), .0));\n\tfields[2]\t\t= cube(position, vec2(.5));\n\tfields[3]\t\t= simplex(position, .5);\n\tfields[4]\t\t= torus(position, vec2(.35, .125));\n\tfields[5]\t\t= segment(position, vec2(0.), vec2(.71, 0.) * rmat(time))-.015;\n\tfields[6]\t\t= fractal(position, cos(time*.25)*.5+1., .3, .15);\n\t\n\tfloat field\t\t= 0.;\n\tfloat selection\t\t= floor(mouse.x * 7.);\n\tfor(int i = 0; i < 7; i++)\n\t{\n\t\tif(selection == float(i))\n\t\t{\n\t\t\tintersect(fields[i], material_id, range, id);\n\t\t}\n\t}\n\t#endif \n\t\n\t\n\t#ifdef SCENE_DISTANCE_FUNCTIONS\n\tfloat material_id\t= 5.;\n\tfloat fields[7];\n\tfields[0]\t\t= face(position, vec2(0., 1.), 1.-mouse.y*2.);\n\tfields[1]\t\t= sphere(position, .5);\n\tfields[2]\t\t= cube(position, vec2(.5));\n\tfields[3]\t\t= simplex(position, .5);\n\tfields[4]\t\t= torus(position, vec2(.35, .125));\n\tfields[5]\t\t= segment(position, vec2(0.), vec2(.71, 0.) * rmat(time))-.015;\n\tfields[6]\t\t= fractal(position, cos(time*.25)*.5+1., .3, .15);\n\t\n\tfloat field\t\t= 0.;\n\tfloat selection\t\t= floor(mouse.x * 7.);\n\tfor(int i = 0; i < 7; i++)\n\t{\n\t\tif(selection == float(i))\n\t\t{\n\t\t\tintersect(fields[i], material_id, range, id);\n\t\t}\n\t}\n\t#endif \n\t\n\t#ifdef SCENE_DISTANCE_OPERATIONS\n\tfloat material_id\t= 5.;\n\tvec2 offset\t\t= vec2(.5, 0.) * cos(time*.3);\n\tfloat s\t\t\t= sphere(position-offset-vec2(.25, 0.), .5);\n\tfloat c \t\t\t= cube(position+offset+vec2(.25, 0.), vec2(.5));\n\tfloat n \t\t\t= fbm((position*.5)*2.+322.)*.75 * min(mouse.y, .75);\n\tfloat fields[7];\n\tfields[0]\t\t= min(s, c);\n\tfields[1]\t\t= max(-s, c);\n\tfields[2]\t\t= max(-max(c, s), min(c, s));\n\tfields[3]\t\t= max(max(c, s), min(c, s));;\n\tfields[4]\t\t= sphere(mod(position + time * .125, 1.)-.5, .25);\n\tfields[5]\t\t= cube(position * (1.+n*2.), vec2(.75));\n\tfields[6]\t\t= max(-face(position, vec2(0., 1.), .7), fractal((position+vec2(0.,.7)+n*n), .23-n*.15, .3+n*.3, .4-n*.5-position.y*.125));\n\t\n\tfloat field\t\t= 0.;\n\tfloat selection\t\t= floor(mouse.x * 7.);\n\tfor(int i = 0; i < 7; i++)\n\t{\n\t\tif(selection == float(i))\n\t\t{\n\t\t\tintersect(fields[i], material_id, range, id);\n\t\t}\n\t}\n\t#endif \n\t\n\t#ifdef SCENE_FANCY_EXAMPLE\n\t\n\t#endif\n\t\n\t\n\t//demo spheres\n\t#ifdef SCENE_SPHERES\n\tfloat material_id\t= 5.;\n\tintersect(sphere(position + vec2(0.5,    .35), .25), material_id, range, id);\n\tintersect(sphere(position + vec2(-.1,   -.25), .15), material_id, range, id);\n\tintersect(sphere(position + vec2(-1.35, 0.35), .55), material_id, range, id);\n\tintersect(sphere(position + vec2(-1.45, -.25), .25), material_id, range, id);\n\t#endif \n\t\n\t#ifdef SCENE_RED_BALL_ON_CHECKER_FLOOR\n\tintersect(face(position, vec2(0.,1.), .75), 1., range, id);\n\tintersect(sphere(position + vec2(-.75, 0.), .75), 2., range, id);\n\tintersect(face(position, vec2(-1.,0.), 2.5), 1., range, id);\n\t#endif\n\t\n\t#ifdef SCENE_NOISY_RED_BALL_ON_CHECKER_FLOOR\n\tfloat checker_floor \t= face(position, vec2(0.,1.), .75);\n\tfloat back_wall\t\t= face(position, vec2(-1.,0.), 2.5);\n\t\n\tfloat noise \t\t= fbm(position*1.25-vec2(8., 3.))*.5;\n\tfloat ball \t\t= sphere(position + vec2(-.75, 0.05), 1.);\n\tfloat noise_ball\t= ball+ noise;\n\tnoise_ball\t\t= max(-checker_floor+.001, noise_ball);\n\t\n\tintersect(checker_floor, 1., range, id);\n\tintersect(back_wall, 1., range, id);\n\tintersect(noise_ball, 2., range, id);\n\t#endif\n}\n\n\n#//Materials\nvoid assign_material(in ray r, out material m)\n{\n\tmap(r.position, r.range, m.id);\n\t\n\tif(m.id == 1.)\n\t{\n\t\tm.roughness \t= .2;\n\t\tm.index \t= .5;\n\t\tm.opacity\t= 1.;\n\t\tbool checker\t= fract(2. * r.position.x) < .5;\n\t\tm.color \t\t= checker ? vec3(.25) : vec3(.125);\n\t}\n\telse if(m.id == 2.)\n\t{\n\t\tm.roughness \t= .1;\n\t\tm.index\t\t= .6;\n\t\tm.opacity\t= .75;\n\t\tm.color\t\t= vec3(.75, .25, .125);\n\t}\n\telse if(m.id == 3.)\n\t{\n\t\tm.roughness \t= .1;\n\t\tm.index\t\t= .8;\n\t\tm.opacity\t= .025;\n\t\tm.color\t\t= vec3(.55, .75, .95);\n\t}\n\telse if(m.id == 4.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index\t\t= .5;\n\t\tm.opacity\t= .5;\n\t\tm.color\t\t= vec3(1., 1., 1.);\n\t}\n\telse if(m.id == 5.)\n\t{\n\t\tm.roughness \t= .5;\n\t\tm.index\t\t= .5;\n\t\tm.opacity\t= .5;\n\t\tm.color\t\t= vec3(0., 1.5, 0.);\n\t}\n\telse\n\t{\n\t\tm.id\t\t= 0.;\n\t\tm.roughness \t= 1.;\n\t\tm.index\t\t= 1.;\n\t\tm.color\t\t= vec3(1.);\n\t}\n}\n\n#ifdef RAY_ANIMATE\nfloat ray_steps = 0.;\n#endif\n\nvec3 pythagoras_slide(vec2 position)\n{\n\treturn vec3(0.);\t\n}\n\nvoid main( void ) \n{\n\tvec2 uv \t\t= gl_FragCoord.xy/resolution.xy;\n\tvec2 position\t= (uv * 2. - 1.) * ASPECT;\n\tvec2 mouse\t= (mouse * 2. - 1.) * ASPECT;\n\t\n\tplot p\t\t= construct_plot(position);\n\t\n\tfor(int i = 1; i <= RAYS; i++)\n\t{\n\t\t#ifdef RAY_ANIMATE\n\t\tray_steps = 0.;\n\t\t#endif\n\t\t\n\t\tray r\t\t= construct_ray();\n\t\t\n\t\tview(float(i), r);\n\t\t\n\t\t#ifdef PLOT_RAYS\n\t\tp.color\t\t= max(p.color, circle(p.position-r.origin,.01) * .25);\n\t\t#endif \n\t\t\n\t\temit(r, p);\n\t\t\n\t\tif(r.intersection)\n\t\t{\n\t\t\t#ifdef RAY_REFINEMENT\n\t\t\tp.ray.x\t\t\t+= circle(position-r.position,THRESHOLD);\n\t\t\t#endif\n\t\t\t\n\t\t\tmaterial m\t\t= construct_material();\n\t\t\t\n\t\t\tassign_material(r, m);\n\t\n\t\t\tderive(r, m, p);\n\n\t\t\tr.position\t\t-= m.normal * abs(r.range-THRESHOLD);\n\n\t\t\t#ifdef RAY_REFINEMENT\n\t\t\tp.ray.x\t\t\t+= circle(position-r.position,.05);\t\t\t\n\t\t\t#endif\n\t\t\t\n\t\t\tlight l\t\t\t= construct_light();\t\n\t\t\tl.position\t\t= LIGHT_POSITION;\n\t\t\tl.direction\t\t= normalize(l.position-r.position);\n\t\t\t\n\t\t\tp.point\t\t\t= l.position;\n\t\t\t\n\t\t\t#ifdef REFLECTION\n\t\t\tray r2 \t\t\t= construct_ray();\n\t\t\tmaterial m2 \t\t= m;\n\t\t\tr2.threshold\t\t= 0.;\n\t\t\tr2.direction \t\t= reflect(r.direction, m2.normal);\n\t\t\tr2.origin\t\t= r.position + r2.direction * .025;\n\t\t\tr2.position\t\t= r2.origin;\n\t\t\t\n\t\t\temit(r2, p);\n\t\t\t\n\t\t\tassign_material(r2, m2);\n\t\n\t\t\tderive(r2, m2, p);\n\t\t\t\n\t\t\tif(r2.intersection)\n\t\t\t{\n\t\t\t\t#ifdef RAY_REFINEMENT\n\t\t\t\tp.ray.y\t\t+= circle(position-r2.position,THRESHOLD);\t\t\t\n\t\t\t\t#endif\n\t\t\t\n\t\t\t\tr2.position\t+= m2.normal * abs(r2.range-THRESHOLD);\n\t\t\t\t\n\t\t\t\t#ifdef RAY_REFINEMENT\n\t\t\t\tp.ray.y\t\t+= circle(position-r2.position,THRESHOLD);\t\t\t\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\tp.point\t\t= r.position;\n\t\t\t\tlight l2 \t= l;\n\t\t\t\tl2.direction \t= normalize(l2.position-r2.position);\n\t\t\t\tl2.color\t\t= LIGHT_COLOR * m.color;\n\n\t\t\t\tshade(r2, l2, m2, p);\n\t\t\t}\n\t\t\t#endif\n\t\t\n\n\t\t\t#ifdef REFRACTION\n\t\t\tif(m.opacity < 1.)\n\t\t\t{\n\t\t\t\tray r3 \t\t= r;\n\t\t\t\tr3.intersection = false;\n\t\t\t\t\n\t\t\t\tmaterial m3 \t= m;\n\t\t\t\tr3.direction \t= refract(m3.normal, r3.direction, m.index);\n\t\t\t\tr3.origin\t= r3.position - r3.direction  * .0125;\n\t\t\t\tr3.position\t= r3.origin;\n\t\t\t\tr3.travel\t= 0.;\n\n\t\t\t\t#ifdef RAY_REFINEMENT\n\t\t\t\tp.ray.z\t\t+= circle(position-r3.position,THRESHOLD);\t\t\t\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\temit(r3, p);\n\t\t\t\n\t\t\t\tif(r3.intersection)\n\t\t\t\t{\n\t\t\t\t\tderive(r3, m3, p);\n\t\t\t\t\n\t\t\t\t\t#ifdef RAY_REFINEMENT\n\t\t\t\t\tfloat bias \t= pow(r3.range, sqrt(5.)/3.);\n\t\t\t\t\tr3.position\t+= m3.normal * bias;\n\t\t\t\t\tp.ray.x\t\t+= circle(position-r3.position,bias);\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t\tlight l2 \t= l;\n\t\t\t\t\tl2.position \t= r.position;\n\t\t\t\t\tl2.direction \t= refract(m3.normal, l2.direction, m.index);\n\t\t\t\t\tl2.color\t\t= mix(LIGHT_COLOR, m3.color, m3.opacity);\n\t\t\n\t\t\t\t\tp.point\t\t= l2.position;\t\t\n\t\t\t\t\tshade(r3, l2, m3, p);\n\t\t\t\t\n\n\t\t\t\t\tr3.direction \t= refract(m3.normal, r3.direction, 1.);\t\t\n\t\t\t\t\tr3.origin\t= r3.position + r3.direction * THRESHOLD;\t\t\n\t\t\t\t\tr3.position\t= r3.origin;\n\t\t\t\t\tr3.travel\t= 0.;\n\t\t\n\t\t\t\t\tr3.intersection = true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\t#ifdef RAY_REFINEMENT\n\t\t\t\t\tp.ray.z\t\t+= circle(position-r3.position,.05);\t\t\t\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tp.point\t\t= r3.position;\n\t\t\t\t\temit(r3, p);\n\t\t\t\t\t\n\t\t\t\t\tderive(r3, m3, p);\n\t\t\t\t\tl2.position \t= r3.origin;\n\t\t\t\t\tl2.direction \t= refract(m3.normal, l2.direction, m.index);\t\n\t\t\t\t\tl2.color\t\t= mix(l2.color, m3.color, m3.opacity);\n\t\t\t\t\t\t\t\n\t\t\t\t\tshade(r3, l2, m3, p);\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endif\n\t\t\n\t\t\n\t\t\t#ifdef REFLECTION\n\t\t\tm.color \t= mix(m.color, m2.color, m.roughness);\n\t\t\t#endif\n\t\t\t\n\t\t\tl.position \t= LIGHT_POSITION;\n\t\t\tl.color  \t= LIGHT_COLOR;\n\t\t\tl.direction \t= normalize(l.position-r.position);\n\t\t\tp.point\t\t= l.position;\t\t\n\t\t\tshade(r, l, m, p);\n\t\t\t\n\t\t\t#ifdef RAY_ANIMATE\n\t\t\tif(ray_steps > 32.) break;\n\t\t\t#endif\n\t\t}\t\t\n\t}\n\t\n\t\n\t#ifdef PLOT_MAP\n\tfloat scene\t= map(position);\t\n\tray r\t\t= construct_ray();\n\tr.position\t= position-r.origin;\n\tr.intersection\t= true;\n\n\tmaterial m\t= construct_material();\t\n\t\n\tassign_material(r, m);\n\t\n\tm.color\t\t= scene < THRESHOLD ? m.color : vec3(scene*.25);\n\n\t\t#ifdef MAP_DISTANCE\n\t\tp.map\t\t+= abs(scene) * m.color * MAP_DISTANCE;\n\t\t#endif\n\t\n\t\t#ifdef MAP_MANIFOLD\n\t\tp.map\t\t+= contour(abs(scene)) * m.color * MAP_MANIFOLD;\t\t\t\n\t\t#endif\n\n\t\t#ifdef MAP_CONTOUR\n\t\tp.map\t\t+= contour(abs(.01+fract(scene*16.-.5)-.5)/16.) * MAP_CONTOUR;\n\t\t#endif\n\t#endif\n\t\n\t#ifdef PLOT_LIGHT\n\tp.light\t\t=  max(p.light,  point(position-LIGHT_POSITION,  5.) * LIGHT_COLOR);\n\tp.light\t\t+= max(p.light, circle(position-LIGHT_POSITION, .02)) * .0625;\n\t#endif \n\t\n\tvec4 result \t= vec4(0.);\n\tresult.xyz\t+= p.ray;\n\tresult.xyz\t+= p.derivative;\n\tresult.xyz\t+= p.brdf;\n\tresult.xyz\t+= p.light;\n\tresult.xyz\t+= p.color;\n\tresult.xyz\t+= p.map;\n\tresult.xyz\t+= p.occlusion;\n\tresult.xyz\t+= p.shadow;\n\t\n\t#ifdef SLIDE_PYTHAGORAS\n\tfloat grid\t= 0.;\n\tgrid\t\t= max(contour(abs(.01+fract(position.x*16.-.5)-.5)/16.) * MAP_CONTOUR, contour(abs(.01+fract(position.y*16.-.5)-.5)/16.) * MAP_CONTOUR);\n\t\n\tresult \t\t*= 0.;\n\tresult.xyz\t+= grid;\n\tresult \t\t= clamp(1.-result, 0., 1.);\n\t\n\tvec2 point_origin\t= vec2(0., 0.);\n\tvec2 point_position\t= point_origin;\n\tvec2 mouse_position\t= mouse;\n\n\tfloat target_point\t= point(position-point_origin, 8.);\n\tfloat mouse_point\t= point(position-mouse_position, 8.);\n\t\n\t\n\tfloat x\t\t= 0.;\n\tfloat y\t\t= 0.;\n\tfloat z\t\t= 0.;\n\tfloat x_box\t= 0.;\n\tfloat y_box\t= 0.;\n\tfloat z_box\t= 0.;\n\t\n\tbvec2 maxima\t= bvec2(mouse_position.x < point_position.x, mouse_position.y < point_position.y);\n\tfloat width\t= abs(point_position.x-mouse_position.x) * (maxima.y ? 1. : -1.);\n\tfloat height\t= abs(point_position.y-mouse_position.y) * (maxima.x ? 1. : -1.);\n\t\n\tvec2 offset\t= vec2(0.);\n\toffset.x\t\t= maxima.x ? width : 0.;\n\t\n\tfloat diagonal\t= length(mouse_position-point_position);\n\t\n\tvec2 direction\t= cross(normalize(point_position-mouse_position));\n\tdirection.x\t*= maxima.x ^^ maxima.y ? 1. : -1.;\n\tdirection.y\t*= maxima.x ^^ maxima.y ? 1. : -1.;\n\t\n\tvec2 v[4];\n\tv[0]\t\t= mouse_position;\n\tv[1]\t\t= vec2(mouse_position.x, point_position.y);\n\tv[2]\t\t= vec2(point_position.x, mouse_position.y);\n\tv[3]\t\t= point_position;\n\t\n\t\t\n\t//xbox\n\tx \t\t+= line(position, v[1], v[3]);\t\n\tx_box \t\t+= line(position, v[0]-vec2(height, 0.), v[1]-vec2(height, 0.));\t\n\tx_box \t\t+= line(position, v[0]-vec2(height, 0.), v[0]);\t\n\tx_box \t\t+= line(position, v[1], v[1]-vec2(height, 0.));\t\n\t\n\t//ybox\n\ty \t\t+= line(position, v[0], v[1]);\t\n\ty_box \t\t+= line(position, v[3], v[3]+vec2(0., width));\t\n\ty_box \t\t+= line(position, v[1], v[1]+vec2(0., width));\t\n\ty_box \t\t+= line(position, v[1]+vec2(0., width), v[3]+vec2(0., width));\t\n\t\n\t//zbox\n\tz \t\t+= line(position, v[0], v[3]);\n\tz_box \t\t+= line(position, v[0], v[0] + direction * diagonal);\t\n\tz_box \t\t+= line(position, v[3], v[3] + direction * diagonal);\t\n\tz_box \t\t+= line(position, v[0] + direction * diagonal, v[3] + direction * diagonal);\n\t\n\tfloat mouse_circle = circle(position-mouse_position, diagonal);\n\tfloat point_circle = circle(position-point_position, diagonal);\n\t\n\t\n\tfloat p_rings\t= contour(abs(.01+fract(length(position-point_position)*16.-.5)-.5)/16.) * MAP_CONTOUR;\n\tfloat m_rings\t= contour(abs(.01+fract(length(position-mouse_position)*16.-.5)-.5)/16.) * MAP_CONTOUR;\n\n\t\n\tfloat frame\t= mod(floor(time*2.5), 16.);\n\tresult\t\t-= frame > 0. ? target_point\t: 0.;\n\tresult\t\t-= frame > 1. ? mouse_point\t: 0.;\n\tresult.yz\t-= frame > 2. ? x\t\t: 0.;\n\tresult.xz\t-= frame > 3. ? y\t\t: 0.;\n\tresult.xy\t-= frame > 4. ? z\t\t: 0.;\n\t\n\tresult.yz\t-= frame > 5. ? y_box\t\t: 0.;\n\t\tresult.xz\t-= frame > 6. ? x_box\t\t: 0.;\n\n\tresult.xy\t-= frame > 7. ? z_box\t\t: 0.;\n\tresult\t\t-= frame > 8. ? point_circle\t: 0.;\n\tresult\t\t-= frame > 9. ? mouse_circle\t: 0.;\n\n//\tresult \t\t-= p_rings+m_rings;\n\t#endif\n\t\n\tgl_FragColor \t= result;\n\tgl_FragColor.w\t= 1.;\n}//sphinx\n\n\n#//Rays\nvoid view(float index, inout ray r)\n{\n\tfloat rays\t= float(RAYS);\n\tfloat ray_angle = index - rays * .5 - .5;\n\tr.direction     = normalize(VIEWTARGET-VIEWPOINT);\n\t\t\n\tr.direction \t*= rmat(ray_angle/TAU/FOV);\n\tr.origin \t= VIEWPOINT + r.direction * .125 * SCALE;\n\t\t\n\t#ifdef ORTHOGRAPHIC\n\tif(ORTHOGRAPHIC)\n\t{\n\t\tr.direction     = normalize(VIEWTARGET-VIEWPOINT);\n\t\tr.origin \t= VIEWPOINT - ray_angle * (SCALE)/rays * VIEWPOINT * rmat(atan(r.direction.x, r.direction.y));\n\t}\n\t#endif\n\t\t\n\tr.position \t= r.origin;\t\n}\n\n\nvoid emit(inout ray r, inout plot p)\n{\n\tr.prior\t  \t\t= r.origin;\n\tr.threshold \t\t= THRESHOLD;\n\t\n\tfloat travel \t\t= 0.;\n\tfloat parity\t\t= map(r.position) < 0. ? -1. : 1.;\n\t\n\tr.intersection\t\t= false;\n\t\n\tfor(int i = 1; i <= ITERATIONS; i++)\n\t{\n\t\t#ifdef RAY_ANIMATE\n\t\tray_steps++;\n\t\tif(ray_steps >= RAY_ANIMATE) return;\n\t\t#endif\n\t\t\n\t\tr.iteration++;\n\t\t\n\t\tr.prior\t  \t= r.position;\n\t\t\n\t\tr.range\t\t= map(r.position) * parity;\n\t\t\t\n\t\tr.travel \t= r.range < 0. ? r.travel * .95 + r.range : r.travel + r.range;\n\t\t\n\t\tr.position \t= r.origin + r.direction * r.travel * parity;\t\n\t\t\n\n\n\t\t#ifdef PLOT_RAYS\n\t\t\tfloat plots\t= 0.;\n\t\n\t\t\t#ifdef RAY_POSITION\n\t\t\tplots\t \t+= RAY_POSITION * point(p.position-r.position);\n\t\t\t#endif\n\t\n\t\t\t#ifdef RAY_PATH\t\n\t\t\tplots\t\t+= RAY_PATH * line(p.position, r.prior, r.position);\n\t\t\t#endif\n\t\n\t\t\t#ifdef RAY_DISTANCE\n\t\t\tplots\t\t+= RAY_DISTANCE * circle(p.position-r.prior, r.range);\n\t\t\t#endif\n\t\t\n\t\t\tvec3 hue\t= hsv(.65-float(r.iteration)/float(ITERATIONS), 1., 1.);\n\t\t\n\t\t\tp.ray \t\t= max(p.ray, hue * clamp(plots, 0., 1.));\n\t\t#endif\n\t\t\n\t\tif(r.range < r.threshold && i > 3)\n\t\t{\t\n\t\t\tr.intersection\t= true;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\tr.range \t\t= r.travel;\n\tr.travel \t= FARPLANE;\n}\n\n\nvoid derive(inout ray r, inout material m, inout plot p)\n{\n\t\n\tfloat offset\t= .125;\n\t\n\tvec4 sample\t= vec4(0.);\n\tfloat right\t= map(r.position+vec2(offset, 0.));\n\tfloat left\t= map(r.position-vec2(offset, 0.));\n\tfloat up\t\t= map(r.position+vec2(0., offset));\n\tfloat down\t= map(r.position-vec2(0., offset));\n\t\n\tm.normal\t\t= vec2(right - left, up - down) * 4.;\n\tm.normal \t= normalize(m.normal);\n    \tm.tangent\t= cross(m.normal);\n\t\n\t#ifdef PLOT_DERIVATIVE\n\tif(r.intersection)\n\t{\n\t\tfloat anim\t= 8.;\n\n\t\t#ifdef DERIVATIVE_SAMPLE\n\t\tvec2 position\t\t= p.position-r.position;\n\t\tvec2 tint\t\t= vec2(.5, 1.);\t\n\t\n\t\tp.derivative.xyz\t\t+= point(position);\n\t\t\n\t\tright \t= abs(right);\n\t\tleft \t= abs(left);\n\t\tup \t= abs(up);\n\t\tdown \t= abs(down);\n\t\t\n\t\t#ifdef DERIVATIVE_ANIMATE\n\t\tanim \t\t= DERIVATIVE_ANIMATE;\t\t\n\t\t#endif \n\t\t\n\n\t\tp.derivative.yz\t+= anim > 0. ? point(position + vec2(offset, 0.)) * tint : vec2(0.);\n\t\tp.derivative.x\t+= anim > 1. ? point(position - vec2(offset, 0.)) : 0.;\n\t\tp.derivative.xy\t+= anim > 2. ? point(position + vec2(0., offset)) : 0.;\n\t\tp.derivative.y\t+= anim > 3. ? point(position - vec2(0., offset)) : 0.;\n\t\t\n\t\tp.derivative.yz\t+= anim > 0. ? line(p.position, r.position, r.position - vec2(offset, 0.)) * tint : vec2(0.);;\n\t\tp.derivative.x\t+= anim > 1. ? line(p.position, r.position, r.position + vec2(offset, 0.)) : 0.;;\n\t\tp.derivative.xy\t+= anim > 2. ? line(p.position, r.position, r.position - vec2(0., offset)) : 0.;;\n\t\tp.derivative.y\t+= anim > 3. ? line(p.position, r.position, r.position + vec2(0., offset)) : 0.;;\n\t\t\n\t\tp.derivative.yz\t+= anim > 0. ? circle(position + vec2(offset, 0.),  left) * DERIVATIVE_SAMPLE * tint : vec2(0.);\n\t\tp.derivative.x\t+= anim > 1. ? circle(position - vec2(offset, 0.), right) * DERIVATIVE_SAMPLE : 0.;\n\t\tp.derivative.xy\t+= anim > 2. ? circle(position + vec2(0., offset),  down) * DERIVATIVE_SAMPLE : 0.;\n\t\tp.derivative.y\t+= anim > 3. ? circle(position - vec2(0., offset),    up) * DERIVATIVE_SAMPLE : 0.;\n\t\t#endif\n\t\t\n\n\t\t#ifdef DERIVATIVE_ANIMATE\t\n\t\t/* //aabb\n\t\tfloat hor\t= (right+left);\n\t\tfloat vert\t= (up+down);\n\n\t\tp.derivative.yz\t+= line(p.position, r.position, r.position - vec2(hor, 0.))*tint;\n\t\tp.derivative.x \t+= line(p.position, r.position, r.position + vec2(hor, 0.));\n\t\tp.derivative.xy\t+= line(p.position, r.position, r.position - vec2(0., vert));\n\t\tp.derivative.y \t+= line(p.position, r.position, r.position + vec2(0., vert));\n\n\n\t\tp.derivative.xyz \t+= line(p.position, r.position + vec2(hor, vert), r.position + vec2(-hor, vert));\n\t\tp.derivative.xyz \t+= line(p.position, r.position - vec2(hor, vert), r.position - vec2(-hor, vert));\n\t\tp.derivative.xyz \t+= line(p.position, r.position + vec2(hor, vert), r.position + vec2(hor, -vert));\n\t\tp.derivative.xyz \t+= line(p.position, r.position - vec2(hor, vert), r.position - vec2(hor, -vert));\n\t\t*/\n\t\t#else \n\t\tanim \t\t= 1.;\n\t\t#endif\n\t\n\t\t#ifdef DERIVATIVE_NORMAL\n\t\tp.derivative\t+= anim > 4. ? line(p.position, r.position, r.position + m.normal * DERIVATIVE_LINE_SCALE) *  DERIVATIVE_NORMAL * anim : vec3(0.);\n\t\tp.derivative\t+= anim > 4. ? point(position - m.normal * DERIVATIVE_LINE_SCALE) * DERIVATIVE_NORMAL * anim : vec3(0.);\n\t\t#endif\n\t\n\t\t#ifdef DERIVATIVE_TANGENT\n\t\tp.derivative\t+= anim > 5. ? line(p.position, r.position, r.position + m.tangent * DERIVATIVE_LINE_SCALE) * DERIVATIVE_TANGENT * anim : vec3(0.);\n\t\tp.derivative\t+= anim > 5. ? point(position - m.tangent * DERIVATIVE_LINE_SCALE) * DERIVATIVE_TANGENT * anim : vec3(0.);\n\t\t#endif\n\t}\n\t#endif\n}\n\n\n#//Material Intersection\nvoid intersect(const in float range, const in float id, inout float minimum, inout float material_id)\n{\n\tmaterial_id \t= range < minimum ? id : material_id;\n\tminimum \t= min(minimum, range);\n}\n\nfloat map(vec2 position)\n{\n\tfloat id \t= 0.;\n\tfloat range \t= FARPLANE;\n\t\n\tmap(position, range, id);\n\t\n\treturn range;\n}\n\n\n#//Shading\nfloat fresnel(const in float i, const in float ndl)\n{   \n\treturn i + (1.-i) * pow(1.-ndl, 5.0);\n}\n\n\nfloat geometry(in float i, in float ndl, in float ndv)\n{\n\tndl             = max(ndl, 0.);\n\tndv             = max(ndv, 0.);\n\tfloat k         = i * sqrt(2./PI);\n\tfloat ik        = 1. - k;\n\treturn (ndl / (ndl * ik + k)) * ( ndv / (ndv * ik + k) );\n}\n\n\nfloat distribution(const in float r, const in float ndh)\n{  \n\tfloat m     = 2./(r*r) - 1.;\n\treturn (m+r)*pow(ndh, m)*.5;\n}\n\n\nfloat shadow(const in vec2 position, const in vec2 direction, inout ray r, inout plot p)\n{\n\tfloat exposure \t= 1.0;\n\tfloat penumbra \t= .1;\n\tfloat umbra\t= length(r.position-LIGHT_POSITION);\n\t\n    \tfor(int i = 0; i < SHADOW_ITERATIONS; ++i)\n    \t{\n\t\tfloat range\t= map(position + direction * penumbra);\n\n\t\t#ifdef LIGHT_SHADOW\n\t\tp.shadow\t+= circle(p.position - position - direction * penumbra - direction * .015, range) * .5;\n\t\t#endif\n\t\t\n\t\texposure \t= min(exposure, 3. * range / penumbra);\n\t\tpenumbra \t+= range;\n\t}\n\t#ifdef LIGHT_SHADOW\n\tp.shadow\t= max(vec3(.1)*p.shadow, p.shadow * exposure * LIGHT_COLOR);\n\t#endif\n\t\t\n\treturn exposure;\n}\n\n\nfloat occlusion(in vec2 position, in vec2 normal, inout ray r, inout plot p)\n{\n  \tfloat occlusion \t= 1.;\n  \tfloat penumbra \t\t= .05;\n\tfloat max_range\t\t= .5;\n\t\n\t#ifdef LIGHT_OCCLUSION\n\tfloat rings\t= 0.;\n\t#endif\n\t\n  \tfor (int i=0; i < OCCLUSION_ITERATIONS; i++ )\n  \t{\n  \t\tfloat radius \t= .5 * penumbra * float(i);\n    \t\tfloat range \t= map(position + normal * radius);\n\t\t\n\t\tif(range < max_range)\n\t\t{\n\t\t\t#ifdef LIGHT_OCCLUSION\n\t\t\trings\t\t+= circle(p.position - position - normal * radius, range);\n\t\t\t#endif\n\t\t\t\n\t\t\tocclusion \t-= penumbra * range;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\t\n  \t}\n\t\n\t#ifdef LIGHT_OCCLUSION\n\trings \t\t= clamp(rings, 0., 1.);\n\tp.occlusion\t= max(p.occlusion, rings*.75);\n\t#endif \n\t\n  \treturn occlusion;\n}\n\n\nvoid shade(inout ray r,  inout light l, inout material m, inout plot p)\n{\n\tvec2 half_direction \t= normalize(r.direction - l.direction);\n\tfloat half_normal   \t= dot(half_direction, m.normal);\n\t\n\tif(r.intersection)\n\t{\n\t\t//exposure coefficients\n\t\tfloat light_exposure    \t= dot(m.normal,  l.direction);   \n\t\tfloat view_exposure     \t= dot(m.normal, -r.direction);  \n\t\t\n\t\t\n\t\t//microfacet lighting components\n\t\tfloat d             \t\t= distribution(m.roughness, half_normal);\n\t\tfloat g             \t\t= geometry(m.roughness, light_exposure, view_exposure);\n\t\tfloat f             \t\t= fresnel(m.index, view_exposure);\n\t\tfloat n             \t\t= clamp(1. - fresnel(f, light_exposure), 0., 1.);\n\t\t\n\t\tvec3 fog\t\t\t= vec3(.65, .65, .8);\n\n\t\n\t\t//bidrectional reflective distribution function\n\t\tfloat brdf              \t= (g*d*f)/(view_exposure*light_exposure*4.);\t\t\n\t\t\n\t\tvec3 color\t\t\t= m.color * fog + m.color * l.color * n + brdf * l.color;\n\t\t\n\t\t\t\t\n\t\tfloat shadows\t\t\t= shadow(r.position, l.direction, r, p);\n\t\tshadows\t\t\t\t= clamp(shadows, .0, 1.);\n\n\t\tfloat occlusions\t\t= occlusion(r.position, m.normal, r, p);\n\t\tocclusions\t\t\t= clamp(occlusions, .0, 1.);\n\n\t\tcolor \t\t\t\t*= occlusions * shadows;\n\t\t\n\t\tcolor\t\t\t\t= mix(color, fog, r.travel/FARPLANE/8.);\n\t\t\n\t\t#define BRDF_SCALE\t\t.05\n\t\t\n\t\t#ifdef PLOT_LIGHT\n\t\tvec2 h_position\t\t\t= r.position + half_direction * BRDF_SCALE * (.5 * brdf);\n\t\tvec2 brdf_cone\t\t\t= m.tangent * m.roughness * BRDF_SCALE;\n\t\tvec3 light_color\t\t\t= max(l.color, vec3(.05)) * shadows * occlusions;\n\t\tvec3 surface_color\t\t= max(color, vec3(.05));\n\t\t\n\t\t\t#ifdef LIGHT_BRDF\n\t\t\tvec3 brdf_plot\t\t\t= vec3(0.);\n\t\t\t\n\t\t\tvec4 term\t\t\t= normalize(vec4(d,g,f,-n)) * .25;\n\t\t\n\t\t\tvec2 t_position\t\t\t= r.position + half_direction;\n\t\t\tbrdf_plot.x\t\t\t+= line(p.position,  r.position, r.position + half_direction * term.x);\n\t\t\tbrdf_plot.x\t\t\t+= point(p.position - r.position - half_direction * term.x);\n\t\t\t\n\t\t\tbrdf_plot.y\t\t\t+= line(p.position,  r.position, r.position + half_direction * term.y);\n\t\t\tbrdf_plot.y\t\t\t+= point(p.position - r.position - half_direction * term.y);\n\t\t\t\n\t\t\tbrdf_plot.z\t\t\t+= line(p.position,  r.position, r.position + half_direction * term.z);\n\t\t\tbrdf_plot.z\t\t\t+= point(p.position - r.position - half_direction * term.z);\n\t\t\n\t\t\tbrdf_plot.xy\t\t\t+= line(p.position,  r.position, r.position + half_direction * term.w);\n\t\t\tbrdf_plot.xy\t\t\t+= point(p.position - r.position - half_direction * term.w);\n\t\t\t\n\t\t\tp.brdf\t\t\t\t= max(p.brdf, brdf_plot * LIGHT_BRDF);\n\t\t\t#endif\n\t\t\n\t\t\t#ifdef LIGHT_RAY\n\t\t\tvec3 light_plot\t\t\t= vec3(0.);\n\t\t\t\n\t\t\t//light to intersection\n\t\t\tlight_plot\t\t\t+= line(p.position, p.point, r.position - brdf_cone) * light_color;\n\t\t\tlight_plot\t\t\t+= line(p.position, p.point, r.position + brdf_cone) * light_color;\n\t\n\t\t\t//intersection to origin\n\t\t\tlight_plot\t\t\t+= line(p.position, r.origin, r.position - brdf_cone) * surface_color;\n\t\t\tlight_plot\t\t\t+= line(p.position, r.origin, r.position + brdf_cone) * surface_color;\n\t\t\tlight_plot\t\t\t+= line(p.position, r.position + brdf_cone, r.position - brdf_cone) * surface_color;\n\t\n\t\t\tlight_plot\t\t\t+= line(p.position,  h_position, r.position - brdf_cone) * surface_color;\n\t\t\tlight_plot\t\t\t+= line(p.position,  h_position, r.position + brdf_cone) * surface_color;\n\t\t\tlight_plot\t\t\t+= point(p.position - h_position) * surface_color;\n\t\t\n\t\t\tp.light\t\t\t\t= max(p.light, light_plot * LIGHT_RAY);\n\t\t\t#endif\n\t\t\n\t\t\t#ifdef LIGHT_SHADE\n\t\t\tfloat scene\t\t\t= map(p.position);\t\t\n\t\t\tfloat contour\t\t\t= 1.-clamp(abs(scene) * LINE_RESOLUTION * .25, 0., 1.);\n\t\t\tfloat spot\t\t\t= clamp(.5-length(p.position-r.position) - .125, 0., 1.);\n\t\t\tp.color\t\t\t\t= max(p.color, spot * color * contour * LIGHT_SHADE);\n\t\t\tp.color\t\t\t\t= max(p.color, point(p.position-r.origin) * surface_color);\n\t\t\t#endif\n\t\t\n\t\t\t#ifdef LIGHT_OCCLUSION\n\t\t\tp.occlusion \t= p.occlusion*fog;\n\t\t\t#endif\t\n\t\t\n\t\t\t#ifdef LIGHT_SHADOW\n\t\t\tp.shadow \t= mix(fog * p.shadow, p.shadow, fog);\n\t\t\t#endif\n\t\t#endif\n\t\t\n\t\tm.color = color;\n\t}\n}\n\n#//Lines\nfloat contour(float x)\n{\n\treturn 1.-clamp(x * LINE_RESOLUTION, 0., 1.);\n}\n\nfloat point(vec2 position, float radius)\n{\n\treturn contour(sphere(position, radius/RESOLUTION_MIN));\t\n}\n\nfloat point(vec2 position)\n{\n\treturn point(position, 4.);\t\n}\n\nfloat circle(vec2 position, float radius)\n{\n\treturn contour(torus(position, vec2(radius,0.)));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\treturn contour(segment(p, a, b));\n}\n\nfloat box(vec2 position, vec2 scale)\n{\n\treturn contour(abs(cube(position, scale)));\t\n}\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\n#//Distance Fields\nfloat face(vec2 position, vec2 normal, float translation)\n{\n  return dot(position, normal) + translation;\n}\n\n\nfloat sphere(vec2 position, float radius)\n{\n\treturn length(position)-radius;\n}\n\n\nfloat torus(vec2 position, vec2 radius)\n{\n\t\n\treturn abs(abs(length(position)-radius.x)-radius.y);\n}\n\n\nfloat cube(vec2 position, vec2 scale)\n{\n\tvec2 vertex \t= abs(position) - scale;\n\tvec2 edge \t= max(vertex, 0.);\n\tfloat interior\t= max(vertex.x, vertex.y);\n\treturn min(interior, 0.) + length(edge);\n}\n\n\nfloat simplex(vec2 position, float scale)\n{\t\t\n\tposition.y\t*= 0.57735026918\t; //1./sqrt(3.);\t\n\tvec3 edge\t= vec3(0.);\n\tedge.x\t\t= position.y + position.x;\n\tedge.y\t\t= position.x - position.y;\n\tedge.z\t\t= position.y + position.y;\n\tedge\t\t*= .86602540358; //sqrt(3.)/2.\n\n\treturn max(edge.x, max(-edge.y, -edge.z))-scale*.57735026918;\n}\n\n\nfloat fractal(vec2 position, float rotation, float translation, float scale)\n{\n\tconst int iterations \t= 8;\n\t\n\tfloat radius \t\t= 1.5/float(iterations);\t\n\t\n\trotation\t\t\t= rotation * TAU + TAU * .5;\n\t\n\tposition \t\t= abs(position);\t\t\t\n\tposition.y\t\t-= radius;\n\tscale \t\t\t*= radius;\n\tfloat result \t\t= max(position.x, position.y) - scale;\n        for (int i = 0; i < iterations; i++)\n\t{\t\t\t\n\t\tfloat magnitude\t= length(position);\n\t\t\n\t\tfloat phase \t= atan(position.x, position.y);\n\t\tphase\t \t= mod(phase, rotation) - rotation * .5; \n\t\t\n\t\tposition.x \t= magnitude * cos(phase);\n\t\tposition.y \t= magnitude * sin(phase);\n\t\n\t\tposition \t= abs(position);\t\t\n\t\t\n\t\tposition.y\t-= translation;\n\t\t\n\t\ttranslation\t*= .7;\n\t\tscale\t\t*= .8;\n\t\trotation\t*= -.98;\n\t\t\n\t\tresult \t\t= min(max(position.x, position.y) - scale, result);\n\t}\n\t\n\treturn result;\n}\n\nfloat segment(vec2 position, vec2 a, vec2 b)\n{\n\treturn distance(position, project(position, a, b));\n}\n\n\n#//Matrices\nmat2 rmat(in float t)\n{\n\tfloat c = cos(t);\n\tfloat s = sin(t);   \n\treturn mat2(c,s,-s,c);\n}\n\n#//White Noise\nfloat hash(in float v )\n{\n    return fract(sin(v)*12345.6789);\n}\n\n\nfloat hash(in vec2 uv) \n{ \n    return fract(sin(+uv.y*512.*cos(uv.x)+uv.x)*12345.6789); \n}\n\n\nfloat value_noise(vec2 uv)\n{\n\tconst float k \t\t= 257.;\n\tvec4 l  \t\t= vec4(floor(uv),fract(uv));\n\tfloat u \t\t= l.x + l.y * k;\n\tvec4 v  \t\t= vec4(u, u+1.,u+k, u+k+1.);\n\tv       \t\t= fract(fract(v*1.23456789)*9.18273645*v);\n\tl.zw    \t\t= l.zw*l.zw*(3.-2.*l.zw);\n\tl.x     \t\t= mix(v.x, v.y, l.z);\n\tl.y     \t\t= mix(v.z, v.w, l.z);\n\treturn mix(l.x, l.y, l.w);\n}\n\n\n#//Pink Noise\nfloat fbm(vec2 uv)\n{\n\tfloat a = .5;\n\tfloat f = 2.;\n\tfloat n = 0.;\n\tconst int octaves = 6;\n\tfor(int i = 0; i < octaves; i++)\n\t{\n\t\tn += value_noise(uv * f) * a;\n\t\tf *= 2.;\n\t\ta *= .5;\n\t}\n\treturn n;\n}\n\n\n#//Projection\nvec2 cross(in vec2 uv)\n{\n\treturn vec2(-uv.y, uv.x);\n}\n\nvec2 project(vec2 position, vec2 a, vec2 b)\n{\n\tvec2 q\t \t= b - a;\t\n\tfloat u \t= dot(position - a, q)/dot(q, q);\n\tu \t\t= clamp(u, 0., 1.);\n\treturn mix(a, b, u);\n}\n\n\n#//Constructors\nray construct_ray(void)\n{ \n\tray r;\n\tr.origin\t= vec2(0.);\n\tr.position\t= vec2(0.);\n\tr.prior\t\t= vec2(0.);\n\tr.direction\t= vec2(0.);\n\tr.travel\t= 0.;\n\tr.range\t\t= 0.;\n\tr.iteration\t= 0.;\n\tr.intersection\t= false;\n  \treturn r;\n}\n\nmaterial construct_material(void)\n{ \n\tmaterial m;\n\tm.id        \t= 0.;\n\tm.index     \t= 0.;\n\tm.roughness \t= 0.;\n\tm.opacity\t= 0.;\n\tm.uv        \t= vec2(0.);\n\tm.normal    \t= vec2(0.);\n\tm.tangent   \t= vec2(0.);\n\tm.color     \t= vec3(0.);\n\treturn m;\n}\n\nlight construct_light(void)\n{\n\tlight l;\n\tl.position    = vec2(0.);\n  \tl.direction   = vec2(0.);\n  \tl.color       = vec3(0.);\n\treturn l;\n}\n\nplot construct_plot(const in vec2 position)\n{\n\tplot p;\n\tp.prior\t\t= vec2(0.);\n\tp.position\t= position;\n\tp.point\t\t= vec2(0.);\n  \tp.ray\t\t= vec3(0.);\n \tp.light\t\t= vec3(0.);\n\tp.color\t\t= vec3(0.);\n\tp.brdf\t\t= vec3(0.);\n\tp.derivative\t= vec3(0.);\n  \tp.occlusion\t= vec3(0.);\n  \tp.shadow\t\t= vec3(0.);\n  \tp.map\t\t= vec3(0.);\n\treturn p;\n}", "user": "3893771", "parent": "/e#46985.0", "id": 47106}