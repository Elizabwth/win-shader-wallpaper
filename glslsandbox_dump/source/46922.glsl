{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n//ramsey's theorem for pairs\n//https://www.quantamagazine.org/mathematicians-bridge-finite-infinite-divide-20160524/ <- for playing with this \n\n\n#define ROWS \t\t1\t\n#define COLUMNS\t\t64\n#define PRINT\t\ttrue\n\n//font drawing stuff\nfloat extract_bit(float n, float e);\nfloat sprite(float n, vec2 p);\t\t\t\nfloat digit(float n, vec2 p);\nfloat print(float n, vec2 position);\nfloat center_print(float n, vec2 position);\n\n\nvoid main( void ) {\n\n\tvec2 fc \t\t= gl_FragCoord.xy;\n\tvec2 extent\t\t= resolution.xy;  \n\tvec2 border\t\t= vec2(.125, 0.);\n\tvec2 uv \t\t= fc.xy/extent.xy - border;\n\tfloat columns\t\t= float(COLUMNS);\n\tfloat rows\t\t= float(ROWS);\n\t\n\tvec2 domain\t\t= vec2(columns, rows);\n\t\n\tvec2 field \t\t= floor((uv - border) * domain);\n\t\n\t\n\t\n\t//ramseys theorem for pairs\n\tbool comparison \t= false;\n\t\n\t\n\tfloat i \t\t= floor(fract(time * .125) * columns * 2. - columns * .5);\n\t\n\t\n\tbool in_mod\t\t= uv.x > .125 && uv.x < .625;\n\tbool center_line \t= abs(uv.y-.5) * 2. < 1./columns;\n\tbool hilight\t\t= center_line && i == field.x;\n\t\n\t\n\tvec2 print_uv\t\t= mod(fc.xy, extent/domain) - (extent/domain) * .5;\n\tfloat n\t\t\t= field.y == 0. ? field.x : field.y;\n\tfloat print\t\t= center_print(abs(n), print_uv) * float(PRINT);\n\tprint \t\t\t*= .25 + float(in_mod);\t\t\n\t\n\t\n\t\n\tvec3 color\t\t= vec3(0., .5, .125);\n\t\n\tvec4 result\t\t= vec4(0., 0., 0., 1.);\n\t\n\t\n\tresult.xyz \t\t= float(comparison) * color;\n\tresult.xy\t\t+= vec2(hilight && !in_mod,hilight && in_mod)*.45;\n\tresult\t\t\t+= print * .95;\n\tresult \t\t\t+= field.x/domain.x * .5;\n\tgl_FragColor \t\t= result;\n}//sphinx\n\n\nfloat extract_bit(float n, float e)\n{\n\treturn fract(n/exp2(e+1.));\n}\n\n\nfloat sprite(float n, vec2 p)\n{\n\tp\t\t= floor(p);\n\tfloat bounds \t= float(all(bvec2(p.x < 3., p.y < 5.)) && all(bvec2(p.x >= 0., p.y >= 0.)));\n\treturn extract_bit(n, (2. - p.x) + 3. * p.y) * bounds;\n}\n\n\t\t\t\t\nfloat digit(float n, vec2 p)\n{\n\treturn\t(n == 1.) ? sprite( 9362., p) \n\t\t\t: n == 2. ? sprite(29671., p) \n\t\t\t: n == 3. ? sprite(29391., p) \n\t\t\t: n == 4. ? sprite(23497., p) \n\t\t\t: n == 5. ? sprite(31183., p) \n\t\t\t: n == 6. ? sprite(31215., p) \n\t\t\t: n == 7. ? sprite(29257., p) \n\t\t\t: n == 8. ? sprite(31727., p) \n\t\t\t: n == 9. ? sprite(31695., p) \n\t\t\t: \t    sprite(31599., p);\n}\n\n\t\n\nfloat print(float n, vec2 position)\n{\t\n\tfloat offset\t= 4.;\n\tfloat result\t= 0.;\n\t\n\tfor(int i = 0; i < 8; i++)\n\t{\n\t\tfloat place = pow(10., float(i));\n\t\t\n\t\tif(n >= place || i == 0)\n\t\t{\n\t\t\tposition.x\t+= 4.;\n\t\t\tresult\t \t+= digit(floor(mod(floor(n/place)+.5, 10.)), position);\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\t\n\t}\n\treturn floor(result+.5);\n}\n   \n\n\nfloat center_print(float n, vec2 position)\n{\n\tposition.y \t+= 2.;\n\tfloat badlog \t= floor(log2(max(n, 1.))/log(5.))+2.;\n\tposition.x \t-= n == 0. ? 2. : badlog;\n\treturn print(n, position);\n}", "user": "3893771", "parent": null, "id": 46922}