{"code": "#ifdef GL_ES\n//precision highp float;\nprecision lowp float;\n#endif\n\nuniform float time;\nvarying vec2 surfacePosition;\n  \n#define ptpi 1385.4557313670110891409199368797 //powten(pi)\n#define pipi  36.462159607207911770990826022692 //pi pied, pi^pi\n#define picu  31.006276680299820175476315067101 //pi cubed, pi^3\n#define pepi  23.140692632779269005729086367949 //powe(pi);\n#define chpi  11.59195327552152062775175205256  //cosh(pi)\n#define shpi  11.548739357257748377977334315388 //sinh(pi)\n#define pisq  9.8696044010893586188344909998762 //pi squared, pi^2\n#define twpi  6.283185307179586476925286766559  //two pi, 2*pi\n#define pi    3.1415926535897932384626433832795 //pi\n#define e     2.7182818284590452353602874713526 //eulers number \n#define sqpi  1.7724538509055160272981674833411 //square root of pi\n#define phi   1.6180339887498948482045868343656 //golden ratio\n#define hfpi  1.5707963267948966192313216916398 //half pi, 1/pi\n#define cupi  1.4645918875615232630201425272638 //cube root of pi\n#define prpi  1.4396194958475906883364908049738 //pi root of pi\n#define lnpi  1.1447298858494001741434273513531 //logn(pi);\n#define trpi  1.0471975511965977461542144610932 //one third of pi, pi/3\n#define thpi  0.99627207622074994426469058001254//tanh(pi)\n#define lgpi  0.4971498726941338543512682882909 //log(pi)      \n#define rcpi  0.31830988618379067153776752674503// reciprocal of pi  , 1/pi \n#define rcpipi  0.0274256931232981061195562708591 // reciprocal of pipi  , 1/pipi\n\nfloat tt = ((time));\nfloat t = (rcpi*(pi+tt/pisq))+pepi;\nfloat k = (lgpi*(pi+tt/chpi))+chpi;\n\nvec3 qAxis = normalize(vec3(sin(t*(prpi)), cos(k*(cupi)), cos(k*(hfpi)) ));\nvec3 wAxis = normalize(vec3(cos(k*(-trpi)/pi), sin(t*(rcpi)/pi), sin(k*(lgpi)/pi) ));\nvec3 sAxis = normalize(vec3(cos(t*(trpi)), sin(t*(-rcpi)), sin(k*(lgpi)) ));\nfloat raxe = qAxis.x+qAxis.y+qAxis.z+wAxis.x+wAxis.y+wAxis.z+sAxis.x+sAxis.y+sAxis.z;\nfloat axe = raxe*raxe;\n\nvec3 camPos = (vec3(0.0, 0.0, -1.0));\nvec3 camUp  = (vec3(0.0,1.0,0.0));\nfloat focus = 9.15;\nvec3 camTarget = vec3(0.5)*sAxis;\n\nvec3 rotate(vec3 vec, vec3 axis, float ang)\n{\n    return vec * cos(ang) + cross(axis, vec) * sin(ang) + axis * dot(axis, vec) * (1.0 - cos(ang));\n}\n\n\n\nvec3 pin(vec3 v)\n{\n    vec3 q = vec3(0.0);\n    v.zxy = vec3(sin(v.x),sin(v.y+1.04719),sin(v.z+4.18879))*0.5+0.5;\n    return (v);\n}\nvec3 spin(vec3 v)\n{\n    for(int i = 1; i <4; i++)\n    {\n        v=pin(rotate((v),pin(v/(1.+axe)),float(i*i)+raxe))*e;\n    }\n    return (v.xyz);\n}\n\nvec3 fin(vec3 v){\n\n\tvec4 vt = vec4(v,(v.x+v.y+v.z)/pi);\n\tvec4 vs = vt;\n\tvt.xyz  += pin(vs.xyz);\n\tvt.xyz  += pin(vs.yzw);\n\tvt.xyz  += pin(vs.zwx);\n\tvt.xyz  += pin(vs.wxy);\n\treturn spin(vt.xyz/pisq);\n}\n\n\nvec3 sfin(vec3 v)\n{\n    for(int i = 1; i < 5; i++)\n    {\n        v =(v+fin(v*float(i)));\n    }\n    return (normalize((pin(v.zxy)))+(spin(v.zxy*rcpi)));\n}\n\nfloat smin( float f1, float f2 )\n{\n    float h = clamp(0.5+0.5*(f2-f1)*100., 0.0, 1.0);\n    return mix(f2, f1, h) - 0.01*h*(1.0-h);\n}\n\n\n\nfloat map(vec3 p)\n{\n\n\t//return sdTorus(p,vec2(pi,lgpi));\n    return abs(max(-smin( smin(length(p.xy)-sqpi, length(p.yz)-sqpi), length(p.zx)-sqpi), length(p)-pi));\n}\n\n\n\nvec3 nrm(vec3 p) {\n\tvec2 q = vec2(0.000001, 0.000005);\n\treturn normalize(vec3( map(p + q.yxx) - map(p - q.yxx),\n\t\t     map(p + q.xyx) - map(p - q.xyx),\n\t\t     map(p + q.xxy) - map(p - q.xxy) ));\n}\n\n\nvoid main( void )\n{\n    vec2 pos = (surfacePosition)*twpi;//(sin(t*pi)+2.0);\n    float ang = (sin(t*lnpi)*pi)+(distance(sAxis,wAxis)+distance(qAxis,sAxis)+distance(wAxis,qAxis));\n    camPos = pisq*(camPos * cos(ang) + cross(qAxis, camPos) * sin(ang) + qAxis * dot(qAxis, camPos) * (1.0 - cos(ang)));\n   \n    vec3 camDir = normalize(camTarget-camPos);\n    camUp = rotate(camUp, camDir, sin(t*prpi)*pi);\n    vec3 camSide = cross(camDir, camUp);\n    vec3 sideNorm=normalize(cross(camUp, camDir));\n    vec3 upNorm=cross(camDir, sideNorm);\n    vec3 worldFacing=(camPos + camDir);\n    vec3 rayDir = -normalize((worldFacing+sideNorm*pos.x + upNorm*pos.y - camDir*((focus))));\n   \n    float show=0.0;\n   \n    float r = .1;\n    float s = 0.9;\n    float temp = 0.;\n    vec3 vt = vec3(0.0);\n    vec3 ht = vec3(0.0);\n    vec3 tv = vec3(0.0);\n    for(int i = 0 ; i < 200; i++) {\n\ttemp = map((camPos + rayDir * (r)));\n    \tif(temp < 0.0001) \n    \t{\n\t\t\n\t\tshow = 1.;\n\t\ttv =vt+sfin(pi*(camPos + rayDir * (r)));\n     \t\tvt = (vt+(tv/(float(i)*r))*(e/(e+exp((tv.x+tv.y+tv.z)))))*0.5;\n\t\tif( ht==vec3(0.0))\n\t\t{\n\t\t\tht = (camPos + rayDir * (r));\n\t\t\trayDir =  refract(rayDir, camPos/pisq, 1.25);\n\t\t}\n     \t\tr += 0.001;\n\t\ts*=.98;\n\t\t\n    \t}\n    \tif(r>pepi){break;} \n    \tr += temp;\n    \ts+=0.03;\n    }\n    vt=normalize(vt);\n    float n=clamp(0.5,0.9,abs(dot(rayDir*2.5,nrm(ht))/((s)))); \n    vec3 clr =show*(vt)*(n);\t\n    gl_FragColor = vec4(clr, 1.0);\n}", "user": "1ffb629", "parent": "/e#25936.24", "id": 47189}