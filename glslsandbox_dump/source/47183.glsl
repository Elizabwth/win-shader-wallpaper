{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/XdyBzz\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\n\n// --------[ Original ShaderToy begins here ]---------- //\n//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.6;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.01;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.0;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 0.6;\t// how fast to rotate (0 = no rotation)\n//const float dotSize \t\t\t= 0.3;\t// how much to scale recursion at each step\n//const int   recursionCount\t= 6;\t// how deep to recurse\n//const float blur\t\t\t\t= 4.0;\t// how much blur\n//const float outline\t\t\t= 0.015; // how thick is the outline\n\n//#define dotSize (iMouse.x/iResolution.x)\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s + p.y*c));\n}\nvec4 HsvToRgb(vec4 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec4(s_n) + vec4(s) * cos(2.0 * pi * (c.x + vec4(1.0, 0.6666, .3333, 1.0)));\n}\n\nfloat GetFocusRotation(int i, bool side) \n{ \n    //float theta =  pi/2.0 + (pi/8.0)*float(i)*float(i);\n    //return theta + turnSpeed*iTime; \n        \n    //if (side)\n    //   i += 1;\n    \n    float theta = 2.0*pi*RandFloat(i);\n    return theta + turnSpeed*mix(-1.0, 1.0, RandFloat(30+i))*iTime; \n}\n\nbool GetFocusSide(int i)\n{\n    return (RandFloat(50+i) < 0.5);\n}\n\nvec2 GetFocusPos(int i )\n{ \n    bool side = GetFocusSide(i);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i, side));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat YinYang2( vec2 p, out float dotDistance, float co, float scale, float dotSize, float blur)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n    {\n       if (r > 1.0)\n           c = 0.0;\n    }\n    dotDistance = r;\n    \n    // top\n    r = length(2.0*p - vec2(0, 1));\n    if (p.x >= 0.0)\n    {\n       if (r < 1.0)\n           c = 0.0;\n    }\n    if (p.y >= 0.0)\n         dotDistance = r;\n    \n    // outline\n    //r = length(p);\n    //c = mix(c, co, smoothstep(1.0-b, 1.0, r));\n    \n    return c;\n}\n\nvec4 RecursiveYinYang(vec2 p, int iterations, float scale, float dotSize)\n{\n    int recursionCount = int(mix(4.0, 18.0, dotSize));\n    float outline\t= 0.;//mix(0.015, 0.0, dotSize);\n    float blur\t\t= 0.0;//mix(4.0, 0.0, dotSize);\n    \n    bool side = (p.y > 0.0);\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < 18; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r, side);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = YinYang2(p, dotDistance, co, scale, dotSize, blur);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = 0.0;//blur*scale/min(iResolution.y,iResolution.x);\n            \n            //co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = (dotDistance < dotSize+outline+b && p.y > 0.0)? 1 : 0;\n            float hue = 0.233*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co, 1.0); // stop if outside or reached limit\n        }\n        \n\t\t// check if top or bottom\n        side = (p.y > 0.0);\n        co = side? 1.0 : 0.0;\n        p.y += mix(0.5, -0.5, co);\n        \n        scale *= 2.0/dotSize;\n        p *= 2.0/dotSize;\t\t// apply recursion scale\n        p = Rotate(p, -theta);\t// cancel out rotation\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n    \n\tuv = (2.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    \n\tvec2 p = uv;\n    vec2 p2 = p;\n    \n    // wander center\n\tp.x += 0.3*sin(0.234*iTime);\n\tp.y += 0.3*sin(0.2*iTime);\n    \n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n    \n    float dotSize = 1.0;\n    //float dotSize = iMouse.x/iResolution.x;\n    \n\t// update zoom, apply pow to make rate constant\n    float recursionSize = 2.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get focus offset\n\tvec2 offset = GetFocusPos(iterations);\n\tfor (int i = 0; i < 20; ++i)\n        offset += (GetFocusPos(iterations+i+1) / recursionSize) * pow(1.0 / recursionSize, float(i));\n    \n    // apply zoom and offset\n\tp = p*zoom + offset;\n    \n    // make the yin yang\n    color = RecursiveYinYang(p, iterations, zoom, dotSize);\n    \n    //vec4 color1 = vec4(0.0,0.0,0.4,1.0);\n    //vec4 color2 = mix(vec4(0.0,1.0,1.0,1.0), vec4(1.0,1.0,1.0,1.0), uv.y);\n    //color = mix(color1, color2, color.z);\n    \n    //color.x = 0.0;\n    //color.y = 0.1;\n    \n    // wander hue\n    //color.x += (0.1*p2.y + 0.1*p2.x + 0.05*iTime);\n    \n    // map to rgp space\n    color = HsvToRgb(color);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "27f154a", "parent": null, "id": 47183}