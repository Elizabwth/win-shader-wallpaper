{"code": "// co3moz\n// rotating and translating square example 3\n\nprecision mediump float;\nuniform float time;\nuniform vec2 resolution;\n\nfloat taimi;\n#define formula(s) (pixel.x - (s) < square.x && pixel.x + (s)> square.x && pixel.y - (s)< square.y && pixel.y + (s) > square.y)\nvec3 drawSquare(in vec2 pixel, in vec2 square, in vec3 setting) {\n\tif(formula(setting.x) && !(formula(setting.x - setting.y))) return vec3(setting.z / 40.0);\n\treturn vec3(0.0);\n}\n\nvoid main(void) {\n\ttaimi = time + sin((1.0 + sin(time + cos(time * 1.4 + 2.0 * gl_FragCoord.x / resolution.x) * 3.0)) * gl_FragCoord.y / resolution.y);\t\n\t\n\tfloat angle = sin(taimi) * 0.3;\n\t\n\tmat2 rotation = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); // this is a 2D rotation matrix\n\tvec2 aspect = resolution.xy / min(resolution.x, resolution.y); // for squared tiles, we calculate aspect\n\tvec2 position = (gl_FragCoord.xy / resolution.xy) * aspect; // position of pixel we need to multiply it with aspect, so we get squared tiles\n\tvec2 center = vec2(0.5) * aspect; // 0.5 is center but we need to multiply it with aspect (0.5 isn't center for squared tiles)\n\t\n\tposition *= rotation;\n\tcenter *= rotation;\n\t\n\tvec3 color = vec3(0.0);\n\tfor(int i = 0; i < 40; i++) {\n\t\tvec3 d = drawSquare(position, center + vec2(sin(float(i) / 10.0 + taimi) / 4.0, 0.0), vec3(0.01 + sin(float(i) / 100.0), 0.01 , float(i)));\n\t\tif(length(d) != 0.0) color = d;//vec3(sin(taimi),cos(taimi),0.50); // fix for old graphics card\n\t}\n\tgl_FragColor = vec4(sin(0.2*(taimi + 3.2))*cos(taimi*10.*color), 1.0);\n}", "user": "bb07244", "parent": "/e#46977.0", "id": 47051}