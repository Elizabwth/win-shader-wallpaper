{"code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D backbuffer;\n\nconst float t = 0.1;\nconst float a = 0.01;\n\nvec2 position;\nvec2 pixel;\n\nvec4 prevColor(vec2 offset)\n{\n\treturn texture2D(backbuffer, position + pixel * offset);\n}\n\nfloat prevU(int offsetX, int offsetY, int offsetT)\n{\n\tvec4 color = prevColor(vec2(offsetX, offsetY));\n\n\treturn (offsetT == 1 ? color.b : color.a) * 2.0 - 1.0;\n}\n\nvec4 encodeU(float now, float past)\n{\n\t//return vec4(now, 0.0, 0.0, past);\n\treturn vec4(0.0, 0.0, (now + 1.0) / 2.0, (past + 1.0) / 2.0);\n}\n\nvoid main( void ) {\n\t\n\tposition = ( gl_FragCoord.xy / resolution.xy );\n\tpixel = 1./resolution;\n\t\n\tfloat h = min(pixel.x, pixel.y);\n\n\tfloat u;\n\tif (position.x <= pixel.x || position.x >= 1.0 - pixel.x\n\t || position.y <= pixel.y || position.y >= 1.0 - pixel.y)\n\t{\t// boundary conditions\n\t\tu = 0.0;\n\t}\n\telse\n\t{\t// wave equation\n\t\tfloat u_xx = 0.0;\n\t\tu_xx +=      prevU( 1, 0, 1);\n\t\tu_xx -= 2. * prevU( 0, 0, 1);\n\t\tu_xx +=      prevU(-1, 0, 1);\n\t\t//u_xx /= pixel.x * pixel.x;\n\t\tu_xx /= h*h;\n\t\t\n\t\tfloat u_yy = 0.0;\n\t\tu_yy +=      prevU(0,  1, 1);\n\t\tu_yy -= 2. * prevU(0,  0, 1);\n\t\tu_yy +=      prevU(0, -1, 1);\n\t\t//u_yy /= pixel.y * pixel.y;\n\t\tu_yy /= h*h;\n\t\t\n\t\tu = 0.0;\n\t\tu += 2. * prevU(0, 0, 1);\n\t\tu -=      prevU(0, 0, 2);\n\t\tu += a*a * t*t * ( u_xx + u_yy );\n\t}\n\t\n\t// Initial undisturbed conditions\n\tif (mod(time, 10.0) < 0.1)\n\t{\n\t\tu = 0.0;\n\t\t//if (distance(position, vec2(0.5, 0.5)) < 0.1) u = 0.9;\n\t\t//if (distance(vec2(position.x / resolution.x * resolution.y, position.y), vec2(0.5, 0.5)) < 0.1) u = 0.9;\n\t\t//if (distance(gl_FragCoord.xy, mouse*resolution) < 5.0)\tu = 0.9;\n\t}\n\n\n\t//if (distance(position, mouse) < 0.05)\n\tif (distance(gl_FragCoord.xy, mouse*resolution) < 10.0)\n\t{\t// disturbalce\n\t\t/*float rnd1 = mod(fract(sin(dot(position + time * 0.001, vec2(14.9898,78.233))) * 43758.5453), 1.0);\n\t\tif (rnd1 > 0.01) {\n\t\t\tu = 0.5;\n\t\t} else {\n\t\t\tu = 0.25;\n\t\t}*/\n\t\t\n\t\t//u = 0.5 * ( sin(time*2.0) + 1.0 ) / 2.0;\n\t\tu = 0.75 * sin(time*4.0);\n\t\t//u = 0.5 + 0.5 * ( sin(time) + 1.0 ) / 2.0;\n\t\t//u = 0.5;\n\t\t//if (mod(time, 4.0) < 0.1)\tu = -0.9;\n\t}\n\t\n\tgl_FragColor = encodeU(u, prevU(0, 0, 1));\n\t\n\t\n\t// Adds mouse-centered light reflections on R and G components\n\tvec2 grad = vec2(prevU(1,0,1)-prevU(-1,0,1), prevU(0,1,1)-prevU(0,-1,1));\t// Gradient at current position\n\tvec2 v = mouse - gl_FragCoord.xy / resolution; \t\t\t\t\t// Vector from pos to mouse\n\tfloat f = -dot(grad, v/length(v));\t\t\t\t\t\t// Resulting factor \n\tgl_FragColor.rg = vec2(log(1.0+f) / (0.7+0.7*length(v)));\t\t\t// Uses factor in RG channels after transformation\n\n}", "user": "611809e", "parent": null, "id": 47028}