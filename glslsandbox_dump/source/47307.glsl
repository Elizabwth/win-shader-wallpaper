{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/XddcWl\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nvec3  iMouse;\n\n// --------[ Original ShaderToy begins here ]---------- //\n// Thanks iq and Shane\n\n#define EPS      0.001\n#define STEPS     1028\n#define FAR        100.\n#define PI acos( -1.0 )\n#define TPI   PI * 2.0\n\nfloat hash( float n )\n{\n\n    return fract( sin( n ) * 45843.349 );\n    \n}\n\nfloat noise( in vec3 x )\n{\n\n    vec3 p = floor( x );\n    vec3 k = fract( x );\n    \n    k *= k * k * ( 3.0 - 2.0 * k );\n    \n    float n = p.x + p.y * 57.0 + p.z * 113.0; \n    \n    float a = hash( n );\n    float b = hash( n + 1.0 );\n    float c = hash( n + 57.0 );\n    float d = hash( n + 58.0 );\n    \n    float e = hash( n + 113.0 );\n    float f = hash( n + 114.0 );\n    float g = hash( n + 170.0 );\n    float h = hash( n + 171.0 );\n    \n    float res = mix( mix( mix ( a, b, k.x ), mix( c, d, k.x ), k.y ),\n                     mix( mix ( e, f, k.x ), mix( g, h, k.x ), k.y ),\n                     k.z\n    \t\t\t\t );\n    \n    return res;\n    \n}\n\nfloat fbm( in vec3 p )\n{\n\n    float f = 0.0;\n    f += 0.5000 * noise( p ); p *= 2.02;\n    f += 0.2500 * noise( p ); p *= 2.03;\n    f += 0.1250 * noise( p ); p *= 2.01;\n    f += 0.0625 * noise( p );\n    f += 0.0125 * noise( p );\n    return f / 0.9375;\n    \n}\n\nvec2 path(in float z)\n{\n    float s = sin(z/24.)*cos(z/12.); return vec2(s*12., 0.);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n    \n}\n\nfloat map( vec3 p )\n{\n\n    /*vec2 tun = abs(p.xy-fbm(p))*vec2(0.5, 0.1071);\n    float n = 1. - max(tun.x, tun.y) + (0.5);\n    return min(n, p.y + fbm(p));*/\n    \n    float tun = length( p.xy - path( p.z ) ) - 12.0;\n    float dif = length( p.xy - path( p.z ) ) - 6.5;\n    float fin = max( tun, -dif );\n    return fin - fbm( p + iTime );\n\n}\n\nvec3 norm( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0.0 );\n    return normalize( vec3( map( p + e.xyy ) - map( p - e.xyy ),\n                            map( p + e.yxy ) - map( p - e.yxy ),\n                            map( p + e.yyx ) - map( p - e.yyx )\n                          ) );\n    \n}\n\nfloat softShadows( in vec3 ro, in vec3 rd )\n{\n\n    float res = 1.0;\n    for( float t = 0.1; t < 8.0; ++t )\n    {\n    \n        float h = map( ro + rd * t );\n        if( h < EPS ) return 0.0;\n        res = min( res, 2.0 * h / t );\n    \n    }\n    \n    return res;\n\n}\n\nvec3 shad( vec3 ro, vec3 rd, float t )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    vec3 lig = normalize( vec3( 0.0, 0.0, iTime ) );\n    vec3 ref = reflect( rd, n );\n    vec3 col = vec3( 0.0 );\n    //vec3 ref = texture( iChannel0, reflect( rd, n ) ).xyz;\n    \n    float amb = 0.5 + 0.5 * n.y;\n    float dif = max( 0.0, dot( n, lig ) );\n    float sha = softShadows( p, lig );\n    float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0 );\n    float rim = pow( 1.0 + dot( n, rd ), 2.0 );\n    \n    col += 0.4 * amb;\n    col += 0.2 * dif * sha;\n    col += 1.0 * spe;\n    col += 0.5 * rim;\n    col += mix( vec3( 0.3, 0.1, 0.0 ), vec3( 0.0, 0.1, 0.2 ), fbm( p + iTime ) );\n    \n    return col;\n    \n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0; d = EPS;\n    for( int i = 0; i < STEPS; ++i )\n    {\n    \n        d = 0.5 * map( ro + rd * t );\n        if( d < EPS || t > FAR ) break;\n        \n        t += d;\n    \n    }\n    \n    return t;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord ) / iResolution.y;\n    vec2 mou = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = vec3( ( -mou.x * TPI ), 0.0, iTime );\n    vec3 ww = normalize( vec3( 0.0 ) - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n    vec3 rd = normalize( uv.x * uu + uv.y * vv + 1.5 * ww );\n    \n    //vec3 rd = ro + vec3( 0.0, 0.1, 0.5 );//ro + vec3( 0.0, 0.1, 0.5 );\n    rd.xy += path( rd.z ); \n    ro.xy += path( ro.z );\n    \n    float d = 0.0;\n    float t = ray( ro, rd, d );\n    \n\tvec3 col = d < EPS ? shad( ro, rd, t ) : vec3( 1.0 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n    iMouse = vec3(mouse * resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}", "user": "1eca43", "parent": null, "id": 47307}