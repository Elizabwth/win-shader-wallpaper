{"code": "// Cheap 2D Humanoid SDF for dropping into scenes to add a sense of scale.\n// Hazel Quantock 2018\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License. http://creativecommons.org/licenses/by-nc-sa/4.0/\n// gigatron for glslsandbox\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform float time;\nuniform vec2 resolution;\n\n\n\nfloat RoundMax( float a, float b, float r )\n{\n    a += r; b += r;\n    \n    float f = ( a > 0. && b > 0. ) ? sqrt(a*a+b*b) : max(a,b);\n    \n    return f - r;\n}\n\nfloat RoundMin( float a, float b, float r )\n{\n    return -RoundMax(-a,-b,r);\n}\n\n// Humanoid, feet placed at <0,0>, with height of ~1.8 units on y\nfloat Humanoid( in vec2 uv, in float phase )\n{\n    #define Rand(idx) fract(phase*pow(1.618,float(idx)))\n    float n3 = sin((uv.y-uv.x*.7)*11.+phase)*.014; // \"pose\"\n    float n0 = sin((uv.y+uv.x*1.1))*.007;\n    float n1 = sin((uv.y-uv.x*.8)*37.+phase*4.)*.004;\n    float n2 = sin((uv.y+uv.x*.9)*71.+phase*8.)*.002;\n    //uv.x += n0+n1+n2; uv.y += -n0+n1-n2;\n    \n    float head = length((uv-vec2(0,1.65))/vec2(1,1.2))-.15/1.2;\n    float neck = length(uv-vec2(0,1.5))-.05;\n    float torso = abs(uv.x)-.25;\n    //torso += .2*(1.-cos((uv.y-1.)*3.));\n    //torso = RoundMax( torso, abs(uv.y-1.1)-.4, .2*(uv.y-.7)/.8 );\n    torso = RoundMax( torso, uv.y-1.5, .2 );\n    torso = RoundMax( torso, -(uv.y-.5-.4*Rand(3)), .0 );\n\n    float f = RoundMin(head,neck,.04);\n    f = RoundMin(f,torso,.02);\n    \n    float leg =\n        Rand(1) < .3 ?\n        abs(uv.x)-.1-.1*uv.y : // legs together\n    \tabs(abs(uv.x+(uv.y-.8)*.1*cos(phase*3.))-.15+.1*uv.y)-.05-.04*Rand(4)-.07*uv.y; // legs apart\n    leg = max( leg, uv.y-1. );\n    \n    f = RoundMin(f,leg,.2*Rand(2));\n    \n    f += (-n0+n1+n2+n3)*(.1+.9*uv.y/1.6);\n    \n    return max( f, -uv.y );\n}\n\n\nvoid main( void )\n{\n    vec2 uv = (gl_FragCoord.xy-resolution.xy*vec2(.5,0))/resolution.y;\n    uv = uv*2.-vec2(0,0);\n    float ph = 2.+floor(time)*2.; // randomize\n    uv.x += time*0.2;\n    float w = .7;\n    float sss = floor(uv.x/w);\n    uv.x = uv.x - (sss + .5)*w;\n    float phase = ph*sss;\n    float sdf = step(0.0001, -Humanoid( uv, phase ));\n    sdf -= step(0.0001, -Humanoid( uv * 2.0, phase * 2.0 )) * 0.5;\n\t//sdf += Humanoid(uv*2.0, phase);\n\t\n    float r=0.5; \n\n    gl_FragColor = vec4(vec3(sdf), 1.0); // map SDF to slightly soft black & white image\n}", "user": "79e95a", "parent": "/e#47253.0", "id": 47321}