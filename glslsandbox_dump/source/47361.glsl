{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nvec3 GetColorFromPhiThetaW( vec3 PhiThetaW )\n{\n  const float SubDivPhi = 10.0, SubDivTheta = 10.0;\n  const vec3 NetHigh = vec3(1, 0, 0);\n  const vec3 NetLow = vec3(1, 1, 0);\n  const vec3 BackHigh = vec3(0, 0, 0);\n  const vec3 BackLow = vec3(0, 0, 1);\n  \n  if (fract(PhiThetaW.x * SubDivPhi) < 0.1 || fract(PhiThetaW.y * SubDivTheta) < 0.1)\n    return 0.5 * (1.0 - PhiThetaW.z) * NetHigh + 0.5 * (PhiThetaW.z + 1.0) * NetLow;\n  return 0.5 * (1.0 - PhiThetaW.z) * BackHigh + 0.5 * (PhiThetaW.z + 1.0) * BackLow;\n}\n\nvec3 CartesianToRPhiTheta( vec3 Cartesian )\n{\n  float r = length(Cartesian);\n  float Phi = sign(Cartesian.z) * acos(Cartesian.x / length(Cartesian.xz));\n  float Theta = acos(-Cartesian.y / r);\n\n  return vec3(r, Phi, Theta);\n}\n\nfloat SphereIntersect( vec3 Loc, vec3 Ray )\n{\n  float R2 = 1.0;\n  float oc2 = dot(Loc, Loc);\n  float ok = dot(-Loc, Ray);\n  float h2 = R2 - oc2 + ok * ok;\n  float Threshold = 1e-4;\n  if (R2 - oc2 > Threshold)\n    return ok + sqrt(h2);\n\n  if (ok > Threshold && h2 > Threshold)\n    return ok - sqrt(h2);\n  return -1.0;\n}\n\nvoid main( void )\n{\n  vec3 WHPos = vec3(0, 0, 0);\n  vec3 Loc = vec3(3.0 * cos(time / 3.0), 0, 3.0 * sin(time / 3.0));\n  const vec3 Up = vec3(0, 1, 0);\n  vec3 Dir = normalize(WHPos - Loc);\n  vec3 Right = cross(Up, Dir);\n  const float ProjDist = 1.0;\n\n  vec2 ScreenSize = resolution;\n  vec2 ProjSize = ScreenSize / min(ScreenSize.x, ScreenSize.y);\n\n  vec2 Pos = 2.0 * gl_FragCoord.xy / ScreenSize - 1.0;\n  vec3 Ray = ProjSize.x * Pos.x * Right - ProjSize.y * Pos.y * Up + Dir * ProjDist;\n  Ray = normalize(Ray);\n  \n  vec3 DirToWh = normalize(WHPos - Loc);\n\n  vec2 EquaDir = normalize(vec2(length(Ray / dot(Ray, DirToWh) - DirToWh), 1));\n  vec3 EquaRight = normalize(Ray / dot(Ray, DirToWh) - DirToWh);\n  vec2 DirRPhi = normalize(vec2(EquaDir.y, EquaDir.x / Loc.x));\n  //vec2 DirRPhi = normalize(CartesianToRPhiTheta(Loc + Right * 0.05 * EquaDir.x + Dir * 0.05 * EquaDir.y).xy - CartesianToRPhiTheta(Loc - Right * 0.05 * EquaDir.x - Dir * 0.05 * EquaDir.y).xy);\n  float Ksi = asin(DirRPhi.y / DirRPhi.x);\n  vec3 LocS = CartesianToRPhiTheta(Loc);\n\n  const float b0 = 1.0;\n  const float b02 = 1.0;\n  float ro = LocS.x - b0;\n  float d1 = asin(sqrt(b02 / (b02 + ro * ro)));\n  float h = sin(Ksi) / sin(d1);\n  if (Pos.x > 0.0)\n  {\n    gl_FragColor = vec4(vec3(h), 1);\n    return;\n  }\n  \n  //float dPhi = h * I;\n\n\n  float t = SphereIntersect(Loc, Ray);\n  if (t > 0.0)\n  {\n    vec3 LPhiTheta = CartesianToRPhiTheta(Loc + t * Ray);\n    gl_FragColor = vec4(GetColorFromPhiThetaW(vec3(LPhiTheta.yz, 1)), 1);\n    return;\n  }\n\n  gl_FragColor = vec4(GetColorFromPhiThetaW(vec3(CartesianToRPhiTheta(Ray).yz, -1)), 1);\n  return;\n}\n", "user": "2b304f1", "parent": null, "id": 47361}