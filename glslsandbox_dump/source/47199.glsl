{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Inspired by \"The Fractal Geometry of Nature\", Benoit B. Mandelbrot, 1977, 1983, page 57\n// Change the resolution dropdown to 0.5.\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define MAX_ITERATIONS 14\n\nmat2 rotateAndScale(float angle, float scale) {\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * scale;\n}\n\nbool pointInTriangle(vec2 p1, vec2 p2, vec2 p3, vec2 pos)\n{\n\t// http://totologic.blogspot.fr/2014/01/accurate-point-in-triangle-test.html\n\tfloat denominator = (p1.x*(p2.y - p3.y) + p1.y*(p3.x - p2.x) + p2.x*p3.y - p2.y*p3.x);\n\tfloat t1 = (pos.x*(p3.y - p1.y) + pos.y*(p1.x - p3.x) - p1.x*p3.y + p1.y*p3.x) / denominator;\n\tfloat t2 = (pos.x*(p2.y - p1.y) + pos.y*(p1.x - p2.x) - p1.x*p2.y + p1.y*p2.x) / -denominator;\n\tfloat s = t1 + t2;\n\n\treturn 0. <= t1 && t1 <= 1. && 0. <= t2 && t2 <= 1. && s <= 1.;\n}\n\nvoid main( void ) {\n\n\tvec2 aspect = resolution / resolution.x;\n\tvec2 position = gl_FragCoord.xy * aspect / resolution;\n\tmat2 topMatrix = rotateAndScale(-0.97, 0.55);\n\tfloat branchDistance = topMatrix[0].x;\n\tfloat minSize = max(mouse.x, 10.0 / resolution.x);\n\t\n\tvec2 start = vec2(0.05, 0.1);\n\tvec2 end = vec2(0.95, 0.1);\n\tvec2 top = start + topMatrix * (end - start);\n\tvec3 color = (position.y > start.y) ? vec3(0.3, 0.5, 0.6) : vec3(0.5, 0.3, 0.1);\n\t\n\tfor (int i = 0; i < MAX_ITERATIONS; ++i) {\n\t\tvec2 delta = end - start;\n\t\tfloat baseDistance = length(delta);\n\t\tvec2 branch1 = start + delta * branchDistance * 0.94;\n\t\tvec2 branch2 = start + delta * branchDistance / 0.94;\n\t\tif (pointInTriangle(branch1, branch2, top, position)) {\n\t\t\tcolor = vec3(1.0);\n\t\t\tbreak;\n\t\t}\n\t\t// Left branch\n\t\tvec2 newTop = branch1 + topMatrix * (top - branch1);\n\t\tif (pointInTriangle(branch1, top, newTop, position)) {\n\t\t\tif (baseDistance < minSize) {\n\t\t\t\tcolor = vec3(0.4, 1.0, 0.45);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = branch1;\n\t\t\tend = top;\n\t\t\ttop = newTop;\n\t\t\tcontinue;\n\t\t}\n\t\t// Right branch\n\t\tnewTop = top + topMatrix * (branch2 - top);\n\t\tif (pointInTriangle(top, branch2, newTop, position)) {\n\t\t\tif (baseDistance < minSize) {\n\t\t\t\tcolor = vec3(0.4, 1.0, 0.45);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart = top;\n\t\t\tend = branch2;\n\t\t\ttop = newTop;\n\t\t\tcontinue;\n\t\t}\n\t\tif (baseDistance < minSize) {\n\t\t\tbreak;\n\t\t}\n\t\t// Left side\n\t\tnewTop = start + topMatrix * (branch1 - start);\n\t\tif (pointInTriangle(start, branch1, newTop, position)) {\n\t\t\tend = branch1;\n\t\t\ttop = newTop;\n\t\t\tcontinue;\n\t\t}\n\t\t// Right side\n\t\tnewTop = branch2 + topMatrix * (end - branch2);\n\t\tif (pointInTriangle(branch2, end, newTop, position)) {\n\t\t\tstart = branch2;\n\t\t\ttop = newTop;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tgl_FragColor = vec4( vec3( color ), 1.0 );\n\n}", "user": "745cd9a", "parent": null, "id": 47199}