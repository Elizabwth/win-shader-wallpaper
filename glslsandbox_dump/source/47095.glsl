{"code": "// written by: saidwho12\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define inf 1.e32\nconst float PI = 3.14159,\n\teps = .00001,\n\tt_min = .01,\n\tt_max = 1000.;\nconst int iter_max = 256;\n\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nmat3 rotateX( in float theta ) {\n\tfloat s = sin(theta), c = cos(theta);\n\treturn mat3(1, 0, 0,\n\t\t   0, c, s,\n\t\t   0, -s, c);\n}\n\nmat3 rotateY( in float theta ) {\n\tfloat s = sin(theta), c = cos(theta);\n\treturn mat3(c, 0, -s,\n\t\t   0, 1, 0,\n\t\t   s, 0, c);\n}\n\nfloat opS( in float d1, in float d2 ) {\n\treturn max(d1, -d2);\n}\n\nfloat opI( in float d1, in float d2 ) {\n\treturn max(d1, d2);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat f( in vec3 p ) {\n\tvec3 b = vec3(1.+.0001, vec2(.3333333));\n\tvec3 theta = .25*vec3(PI*time);\n\tvec3 p0 = rotateX(theta.x)*p;\n\t//pModPolar(p0.xy, 12.);\n\treturn opS(sdBox(p0, vec3(1)), min(min(sdBox(p0, b), sdBox(p0, b.yxz)), sdBox(p0, b.zyx)));\n}\n\nvec3 n( in vec3 p ) {\n\treturn normalize(vec3(\n\t\tf(vec3(p.x+eps, p.yz)) - f(vec3(p.x-eps, p.yz)),\n\t\tf(vec3(p.x, p.y+eps, p.z)) - f(vec3(p.x, p.y-eps, p.z)),\n\t\tf(vec3(p.xy, p.z+eps)) - f(vec3(p.xy, p.z-eps))\n\t));\n}\n\t\nfloat trace( in vec3 ro, in vec3 rd ) {\n\tfloat t = 0.;\n\tfor(int i = 0; i<iter_max; ++i) {\n\t\tfloat r = f(ro+rd*t);\n\t\tt+=r;\n\t\tif(r<eps) return t>t_max ? inf : t;\n\t}\n\treturn inf;\n}\n\nvoid main( void ) {\n\tvec2 p = (2.*gl_FragCoord.xy - resolution.xy) / resolution.y;\n\tvec3 \tro = vec3(0,0,3),\n\t\tfw = vec3(0,0,-1),\n\t\tup = vec3(0,1,0),\n\t\tri = cross(fw, up),\n\t\trd = normalize(fw+p.x*ri+p.y*up),\n\t\tc = vec3(0);\n\tfloat t = trace(ro, rd);\n\tif(t!=inf) {\n\t\tvec3 P = ro+rd*t, N = n(P);\n\t\t//c += fract(P-.5);\n\t\t//c += fract(t);\n\t\tc += N;\n\t}\n\t\n\tgl_FragColor = vec4(c, 1);\n}", "user": "9e97c01", "parent": null, "id": 47095}