{"code": "/*\n * Original shader from: https://www.shadertoy.com/view/4sVfWw\n */\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// glslsandbox uniforms\nuniform float time;\nuniform vec2 resolution;\n\n// shadertoy globals\nfloat iTime;\nvec3  iResolution;\nconst vec3  iMouse = vec3(0.);\n\n// --------[ Original ShaderToy begins here ]---------- //\n#define detail 5\n#define steps 40\n#define time iTime*0.5\n\n//draw octree grid\n//#define drawgrid\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n//random function from https://www.shadertoy.com/view/MlsXDf\nfloat rnd(vec4 v) { return fract(4e4*sin(dot(v,vec4(13.46,41.74,-73.36,14.24))+17.34)); }\n\n//0 is empty, 1 is subdivide and 2 is full\nint getvoxel(vec3 p, float size) {\n    if (p.x == 0.0 && p.y == 0.0) {\n        return 0;\n    }\n    \n    float val = rnd(vec4(p,size));\n    \n    /*if (val < 0.5) {\n        return 0;\n    } else if (val < 0.8) {\n        return 1;\n    } else {\n        return 2;\n    }*/\n    \n    return int(val*val*3.0);\n}\n\n//ray-cube intersection, on the inside of the cube\nvec3 voxel(vec3 ro, vec3 rd, float size)\n{\n    size *= 0.5;\n    \n    vec3 hit = -(sign(rd)*(ro-size)-size)/max(abs(rd),0.001);\n    \n    return hit;\n}\n\nvoid mainImage( out vec4 fragColor,  vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) /iResolution.y;\n    float size = 1.0;\n    \n    vec3 ro = vec3(0.5+sin(time)*0.4,0.5+cos(time)*0.4,time);\n    vec3 rd = normalize(vec3(uv,1.0));\n    \n    //if the mouse is in the bottom left corner, don't rotate the camera\n    if (length(iMouse.xy) > 40.0) {\n    \trd.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n    \trd.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 lro = mod(ro,size);\n    vec3 fro = ro-lro;\n    vec3 mask;\n    bool exitoct = false;\n    int recursions = 0;\n    float dist = 0.0;\n    int i = 0;\n    float edge = 1.0;\n    \n    //the octree traverser loop\n    //each iteration i either:\n    // - check if i need to go up a level\n    // - check if i need to go down a level\n    // - check if i hit a cube\n    // - go one step forward if cube is empty\n    for (int i = 0; i < steps; i++)\n    {\n        int voxelstate = getvoxel(fro,size);\n        \n        //i go up a level\n        if (exitoct)\n        {\n            \n            vec3 newfro = floor(fro/size*0.5)*size*2.0;\n            \n            lro += fro-newfro;\n            fro = newfro;\n            \n            recursions--;\n            size *= 2.0;\n            \n            exitoct = (recursions > 0) && (abs(dot(mod(fro/size+0.5,2.0)-1.0+mask*sign(rd)*0.5,mask))<0.1);\n        }\n        //subdivide\n        else if(voxelstate == 1)\n        {\n            //if i have rached the octree limit, break\n            if(recursions>detail) break;\n            \n            recursions++;\n            size *= 0.5;\n            \n            //find which of the 8 voxels i will enter\n            vec3 mask2 = step(vec3(size),lro);\n            fro += mask2*size;\n            lro -= mask2*size;\n        }\n        //move forward\n        else if (voxelstate == 0)\n        {\n            //raycast and find distance to nearest voxel surface in ray direction\n            vec3 hit = voxel(lro, rd, size);\n            if (hit.x < min(hit.y,hit.z)) {\n                mask = vec3(1,0,0);\n            } else if (hit.y < hit.z) {\n                mask = vec3(0,1,0);\n            } else {\n                mask = vec3(0,0,1);\n            }\n            float len = dot(hit,mask);\n            \n            //moving forward in ray direction, and checking if i need to go up a level\n            ro += rd*len;\n            lro += rd*len-mask*sign(rd)*size;\n            vec3 newfro = fro+mask*sign(rd)*size;\n            exitoct = (floor(newfro/size*0.5+0.25)!=floor(fro/size*0.5+0.25))&&(recursions>0);\n            fro = newfro;\n        }\n        else\n        {\n            break;\n        }\n#ifdef drawgrid\n        vec3 q = abs(lro/size-0.5)*(1.0-mask);\n        edge = min(edge,-(max(max(q.x,q.y),q.z)-0.5)*80.0*size);\n#endif\n    }\n    \n    if(i < steps)\n    {\n    \tfloat val = fract(dot(fro,vec3(15.23,754.345,3.454)));\n        vec3 normal = mask*sign(rd);\n        vec3 color = sin(val*vec3(39.896,57.3225,48.25))*0.5+0.5;\n    \tfragColor = vec4(color*(normal*0.25+0.75),1.0);\n        \n        vec3 q = abs(lro/size-0.5)*(1.0-mask);\n        edge = clamp(-(max(max(q.x,q.y),q.z)-0.5)*20.0*size,0.0,edge);\n        fragColor *= vec4(edge);\n    }\n}\n// --------[ Original ShaderToy ends here ]---------- //\n\n#undef time\n\nvoid main(void)\n{\n    iTime = time;\n    iResolution = vec3(resolution, 0.0);\n\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n    gl_FragColor.a = 1.0;\n}", "user": "615ddf9", "parent": null, "id": 47499}