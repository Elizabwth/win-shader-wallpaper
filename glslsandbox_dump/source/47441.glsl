{"code": "// https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright \u00a9 2013 Inigo Quilez\n// \u672c\u30d7\u30ed\u30b0\u30e9\u30e0\u306f\u4e0a\u8a18\u30d7\u30ed\u30b0\u30e9\u30e0\u3092\u6539\u5909\u3057\u305f\u3082\u306e\u3067\u3042\u308b\u3002\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n#define M_GETA   1.0\n#define M_SHARI  2.0\n#define M_MAGURO 3.0\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n// Signed Distance Functions\n\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p)-s;\t\n}\n\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p)-b, 0.0));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p)-b, 0.0)) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\nfloat sdCylinder(vec3 p, vec3 c)\n{\n\treturn length(p.xz-c.xy) - c.z;\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat length2(vec2 p)\n{\n\treturn sqrt(p.x * p.x + p.y + p.y);\n}\n\nfloat length6(vec2 p)\n{\n\tp = p * p * p; p = p * p;\n\treturn pow(p.x + p.y, 1.0 / 6.0);\n}\n\nfloat length8( vec2 p )\n{\n\tp = p * p; p = p * p; p = p * p;\n\treturn pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length2(p.xz) - t.x, p.y);\n    return length8(q) - t.y;\n}\n\n// Operations\n\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opS(float d1, float d2)\n{\n\treturn max(-d2, d1);\n}\n\nfloat opI(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\nvec3 opRep(vec3 p, vec3 c)\n{\n\treturn mod(p, c) - 0.5 * c;\n}\n\n// 3D Models\n\nvec2 shari(vec3 p)\n{\n\treturn vec2(udRoundBox(p, vec3(0.1, 0.1, 0.22), 0.005), M_SHARI);\n}\n\nvec2 maguro(vec3 p)\n{\n\tvec2 res = vec2(udRoundBox(p - vec3(0.0, 0.1, 0.0), vec3(0.13, 0.04, 0.3), 0.005), M_MAGURO);\n\treturn opU(res, shari(p));\n}\n\nvec2 geta(vec3 p)\n{\n\tvec2 tmp = opU(vec2(udRoundBox(p - vec3(0.5, -0.2, 0.0), vec3(0.1, 0.1, 0.5), 0.005), M_GETA),\n\t\t       vec2(udRoundBox(p - vec3(-0.5, -0.2, 0.0), vec3(0.1, 0.1, 0.5), 0.005), M_GETA));\n\treturn opU(vec2(udRoundBox(p, vec3(0.8, 0.1, 0.5), 0.01), M_GETA),\n\t\t   tmp);\n}\n\nvec2 map(vec3 p)\n{\n\tvec3 pos = p;\n\tvec2 res = vec2(50.0);\n\t pos = opRep(p, vec3(2.0));\n\tres =  geta(pos);\n\tres = opU(res, maguro(pos - vec3(0.0, 0.2, 0.0)));\n\treturn res;\n}\n\n// Rendering Functions\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\t\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 64; i++) {\n\t\tfloat precis = 0.0004 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax)\n\t\t\tbreak;\n\t\tt += res.x;\n\t\tm = res.y;\n\t}\n\tif (t > tmax)\n\t\tm = -1.0;\n\treturn vec2(t, m);\n}\n\nvec3 calcNormal(vec3 p)\n{\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map (p + e.xyy).x + \n\t\t\t e.yxy * map (p + e.yxy).x + \n\t\t\t e.yyx * map (p + e.yyx).x + \n\t\t\t e.xxx * map (p + e.xxx).x);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tvec3 p = ro + t * rd;\n\t\n\t// description \u30e1\u30e2 res.y \u306e\u5024\u3054\u3068\u306b\u8272\u306e\u51e6\u7406\n\tif (m < 0.0)\n\t\treturn col;\n\tif (m == M_GETA)\n\t\tcol = vec3(1, 1, 1);\n\tif (m == M_SHARI)\n\t\tcol = vec3(0.8);\n\tif (m == M_MAGURO)\n\t\tcol = vec3(0.8, 0.2, 0.2);\n\t\n\tvec3 lig = normalize(vec3(-0.4, 0.7, -0.6));\n\tvec3 nor = calcNormal(p);\n\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\n\t\n\tvec3 lin = vec3(0.0);\n        lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n        lin += 0.40 * amb * vec3(0.40,0.60,1.00);\n\tcol *= lin;\n\t\n\treturn col;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid main()\n{\n\tvec2 mo = mouse.xy / resolution.xy;\n\tvec3 col = vec3(0.0);\n\tvec2 p = (-resolution.xy + gl_FragCoord.xy * 2.0) / resolution.y;\n\t\n\t// camera\n\tvec3 ro = vec3(-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n\t\t       2.0 + 2.0 * mo.y,\n\t\t       0.5 + 4.0 * sin(0.1 * time + 6.0 * mo.x) );\n        vec3 ta = vec3(0.0, 0.0, 0.0);\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\t\n\tcol += render(ro, rd);\n\t\n\tcol = pow(col, vec3(0.4545));\n\n\tgl_FragColor = vec4(col, 1.0);\n\n}", "user": "e104cd9", "parent": "/e#47376.2", "id": 47441}