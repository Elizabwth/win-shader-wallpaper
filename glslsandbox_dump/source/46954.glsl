{"code": "//Modified by Vlad 03/05/2018\n//Hacking in some basic texturing, based on the awsome shadertoy PSX rendering demo: https://www.shadertoy.com/view/Mt3Gz2\n//HOWEVER, the uv perspective transformations are incorrect, so if anybody has any ideas on how to fix them, please fork away ;) \n// Good ref: http://web.cs.ucdavis.edu/~amenta/s12/perspectiveCorrect.pdf\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n#define PI 3.1415\n#define TAU PI * 2.00\n\n//I know, there is no less effiecient way of implementing per-pixel 3D graphics\n//Vlad: Any better suggestions? \nmat4 view = mat4(1), pMatrix;\nvec2 clipspace;\n\nfloat near = 0.1;\nfloat far = 100.0;\nfloat zoom = 2.0;\n\nvec3 colorBuffer = vec3(135, 206, 235) / 255.;\nfloat depthBuffer = 1.0;\n\nvoid translate(vec3 pos)\n{\n\tview *= mat4(\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\tpos, 1\n\t);\t\n}\n\nfloat hash( vec2 p ) \n{\n   float h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise1(vec2 p) \n{\n    #ifndef BILINEAR\n\t\treturn hash(floor(p));\n    #else    \n        vec2 i = floor(p);\n        vec2 f = fract(p);\n    \tvec2 tx = mix(vec2(hash(i),hash(i+vec2(0.,1.))) ,\n                      vec2(hash(i+vec2(1.,0.)),hash(i+vec2(1.))),f.x);\n        return mix(tx.x,tx.y,f.y);\n    #endif\n}\n\nvec4 textureBox(vec2 uv) \n{\n    const vec2 RES = vec2(8.0, 8.0);\n    vec2 iuv = (floor(uv * RES) + 0.5) / RES;  \n    //vec2 iuv = uv / RES;  \n    float n = noise1(uv * RES);\n    n = max(abs(iuv.x - 0.5), abs(iuv.y - 0.5)) * 2.0;\n    n = n * n;\n    n = 0.5 + n * 0.4 + noise1(uv * RES) * 0.1;\n    return vec4(n, n*0.8, n*0.5, 1.0);\n\t//return vec4(uv.x, uv.y, 1.0, 1.0); //debug\n}\n\nvoid scale(vec3 pos)\n{\n\tview[0] *= pos.x;\n\tview[1] *= pos.y;\n\tview[2] *= pos.z;\n}\n\nvoid rotate (vec3 u, float a)\n{\n\tu = normalize(u);\n\tfloat s = sin(a), c = cos(a), c1 = 1. - c;\n\t\n\tview *= mat4 (\n\t\tc + u.x * u.x * c1, u.x * u.y * c1 - u.z * s, u.x * u.z * c1 + u.y * s, 0,\n\t\tu.y * u.x * c1 + u.z * s, c + u.y * u.y * c1, u.y * u.z * c1 - u.x * s, 0,\n\t\tu.z * u.x * c1 - u.y * s, u.z * u.y * c1 + u.x * s, c + u.z * u.z * c1, 0,\n\t\t0, 0, 0, 1\n\t);\n}\n\nmat4 perspective (float FOV, float aspectRatio, float _near, float _far)\n{\n\tfloat f = 1.0 / tan(FOV / 2.0);\n\tfloat nf = _near - _far;\n\t\n\treturn mat4(f / aspectRatio, 0, 0, 0,\n\t0, f, 0, 0,\n\t0, 0, (_far + _near) / nf, -1,\n\t0, 0, (2.0 * _far * _near) / nf, 0);\n}\n\n\nvec3 setView (mat4 view, vec3 pos)\n{\n\tvec4 c = view * vec4(pos, 1);\n\t\n\treturn c.xyz / c.w;\n}\n\nvoid tri(vec3 color, vec3 p0, vec3 p1, vec3 p2, bool firstTriangle)\n{\n\tvec3 vp0 = setView(pMatrix *view, p0);\n\tvec3 vp1 = setView(pMatrix *view, p1);\n\tvec3 vp2 = setView(pMatrix *view, p2);\n\t      \n\tvec2 v0 = vp2.xy - vp0.xy;\n\tvec2 v1 = vp1.xy - vp0.xy;\n\tvec2 v2 = clipspace - vp0.xy;\n\t\n\tfloat dot00 = dot(v0, v0);\n\tfloat dot01 = dot(v0, v1);\n\tfloat dot02 = dot(v0, v2);\n\tfloat dot11 = dot(v1, v1);\n\tfloat dot12 = dot(v1, v2);\n\n\tfloat f = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\t\n\t//Todo: Figure out how to compute the perspective corrections for the UV coordinates\n\t\n\tfloat u = (dot11 * dot02 - dot01 * dot12) * f;\n\tfloat v = (dot00 * dot12 - dot01 * dot02) * f;\n\tfloat w = 1.0 - u - v;\n\t\n\t\t\n\tif (u >= 0. && v >= 0. && w >= 0.)\n\t{\n\t\tp0 = setView(view, p0);\n\t\tp1 = setView(view, p1);\n\t\tp2 = setView(view, p2);\n\n\t\tfloat depth = vp0.z * w + vp1.z * v + vp2.z * u;\n\t\tvec3 pos = p0 * w + p1 * v + p2 * u;\n\t\t\n\n\t\t//LEQUAL OpenGL Equivelent\n\t\tif (depthBuffer >= depth && depth >= -1.0)\n\t\t{\n\t\t\t//lighting\n\t\t\tvec3 normal = normalize(cross (p1 - p0, p0 - p2));\n\t\t\tvec3 npos = normalize(pos);\n\t\t\t\n\n\t\t\t//Mirror UV's\n\t\t\tif(firstTriangle)\n\t\t\t{\n\t\t\t\tcolor = textureBox(vec2(u, v)).xyz * dot(npos, normal);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcolor = textureBox(vec2(1.0 - v, 1.0 - u)).xyz * dot(npos, -normal); //Flip UV coordinates and subtract from upper right triangle (do the same for the normals)\n\t\t\t}\n\t\t\t\n\t\t\tdepthBuffer = depth;\n\t\t\tcolorBuffer = color;\n\t\t}\n\t}\n}\n\nvoid quad(vec3 color, vec3 p1, vec3 p2, vec3 p3, vec3 p4)\n{\n\ttri(color, p1, p2, p3, true);\n\ttri(color, p4, p2, p3, false);\n}\n\nvoid drawScene()\n{\n\ttranslate(vec3(0, 0, -5));\n\t\n\trotate(vec3(0, 1, 0), time);\n\t\n\t{\n\t\tmat4 cache = view;\n\t\tview = mat4(view);\n\t\t\n\t\ttranslate (vec3(0, abs(sin(time / 2. * TAU)) * 2. - 1., 0));\n\t\trotate(vec3(1, 0, 1), -time * PI + PI * (clipspace.y));\n\t\t\n\t\tquad(vec3(1, 0, 1), vec3(-1, -1, 1), vec3(1, -1, 1), vec3(-1, 1, 1), vec3(1, 1, 1));\n\t\tquad(vec3(1, 1, 0), vec3(-1, -1, -1), vec3(-1, 1, -1), vec3(1, -1, -1), vec3(1, 1, -1));\n\t\t\n\t\tquad(vec3(0, 0, 1), vec3(1, -1, -1), vec3(1, 1, -1), vec3(1, -1, 1), vec3(1, 1, 1));\n\t\tquad(vec3(0, 1, 0), vec3(-1, -1, -1), vec3(-1, -1, 1), vec3(-1, 1, -1), vec3(-1, 1, 1));\n\t\t\n\t\tquad(vec3(1, 0, 0), vec3(-1, 1, -1), vec3(-1, 1, 1), vec3(1, 1, -1), vec3(1, 1, 1));\n\t\tquad(vec3(0, 1, 1), vec3(-1, -1, -1), vec3(1, -1, -1), vec3(-1, -1, 1), vec3(1, -1, 1));\n\t\t\n\t\tview = cache;\n\t}\n\t\n\t{\n\t\tmat4 cache = view;\n\t\tview = mat4(view);\n\t\t\n\t\ttranslate(vec3(0, -2, 0));\n\t\t\n\t\tquad(vec3(1, 1, 1), vec3(-2, 0, -2), vec3(-2, 0, 2), vec3(2, 0, -2), vec3(2, 0, 2));\n\t\tquad(vec3(89, 26, 20) / 100., vec3(-3, -0.01, -3), vec3(-3, -0.01, 3), vec3(3, -0.01, -3), vec3(3, -0.01, 3));\n\t\t\n\t\tview = cache;\n\t}\n}\n\nvoid main( void ) \n{\n\tclipspace = gl_FragCoord.xy / resolution * 2.0 - 1.0;\n\tpMatrix = perspective(PI / zoom, resolution.x / resolution.y, near, far);\n\t\n\tdrawScene();\n\t\n\tgl_FragColor = vec4(colorBuffer, 1);\n}", "user": "8dacf50", "parent": "/e#46943.0", "id": 46954}