{"code": "precision highp float;\n\n//arithmetic encoder / decoder / h4x (note no time input or framebuffer, see parent for encoder decoder)\n\n//TL:DR -> list of stuff on the left gets encoded into a line (the vertical black line) on probability space (the mess in the middle) and then decoded out onto the right side in the same order\n//the magic is that the space has every possible order crammed in proportional to the inputs, and the line picks the spot that matches the order\n\n//left side  - input series of symbols\n//center     - probability space of all potential series with matching symbol ratios\n//right side - series decoded from probability set and encoded phase\n\n//the space is preserved as a fractal, which is handy\n//every pixel could be running it's own set, if you were into that for whatever reason\n\n//it still could optimized more, and less iterative (http://glslsandbox.com/e#27191.0) maybe..?\n\n\nuniform vec2 mouse;\nuniform vec2 resolution;\nvarying vec2 surfacePosition;\n\n#define SYMBOLS\t\t2\n#define ELEMENTS\t8\n\n//#define POLAR\n\n#define MIN_RESOLUTION min(resolution.x, resolution.y)\n\n#define LINE_WIDTH MIN_RESOLUTION/16./MIN_RESOLUTION\n\n//#define DEBUG_SPACE\n#ifdef DEBUG_SPACE\nvec2\tg_debug = vec2(0.);\n#endif\n\n\nfloat\tencode(in float probability[SYMBOLS], in float set[ELEMENTS]);\nvoid\tdecode(in float phase, in float probability[SYMBOLS], out float set[ELEMENTS]);\nvoid\tcount(inout float set[ELEMENTS], inout float probability[SYMBOLS]);\nvoid\tderive(inout float probability[SYMBOLS]);\nvoid\tzero(out float set[ELEMENTS]);\nfloat\tsum(in float probability[SYMBOLS]);\nvec3\tsymbol_color(float i);\nvec3\tsymbol_h4x_color(float i);\nvec3\thsv(float h,float s,float v);\nfloat \tverify_set(vec2 uv, in float set[ELEMENTS], in float verification[ELEMENTS]);\nvec3 \tdisplay_set(vec2 uv, in float set[ELEMENTS]);\nvoid\tassign_random_symbols(out float set[ELEMENTS]);\nvoid\tassign_gpu_h4x(out float set[ELEMENTS]);\n\nfloat\thash(vec2 uv);\n\n\nvoid main( void ) \n{\n\t//formatting\n\tvec2 uv \t\t\t= gl_FragCoord.xy/resolution.xy;\n\tvec2 p\t\t\t\t= uv;\n\t\n\t#ifdef POLAR\n\tp \t\t\t\t= uv * 2. - 1.;\n\tp\t\t\t\t*= resolution.xy/MIN_RESOLUTION;\n\tp\t\t\t\t= vec2((atan(p.x, p.y)+(4.*atan(1.)))/(8.*atan(1.)), length(p));\n\t#endif\n\t\n\t#ifdef DEBUG_SPACE\n\tg_debug.y\t\t\t= p.y;\n\t#endif\n\t\n\t//assign some random symbols to the series based on mouse position and a random hash\n\tfloat set[ELEMENTS];\n\tassign_gpu_h4x(set);\n\t\n\tfloat verification_set[ELEMENTS];\n\tassign_gpu_h4x(verification_set);\t\n\t\n\tvec3 initial_set \t\t= display_set(uv.yx, set);\n\n\t\n\t//encode the set into a phase within it's probabilities\n\tfloat probability[SYMBOLS];\n\tcount(set, probability);\n\tderive(probability);\n\t\n\t\n\tfloat phase \t\t\t= encode(probability, set);\n\n\t\n\t//wipe the set (no cheating!)\n\tzero(set);\n\t\n\t\n\tdecode(phase, probability, set);\n\tvec3 decoded_set \t\t= display_set(uv.yx, set);\n\t\n\tfloat phase_line\t\t= float(abs(p.x-phase)<.0025);\n\t#ifdef POLAR\n\tphase_line\t\t\t= float(abs(p.x-phase)<.0025/length(p*4.));\n\t#endif\n\t\n\tfloat error_mask \t\t= clamp(verify_set(p.yx, set, verification_set)+.5, 0., 1.);\n\n\t//decode the entire space for visualization (not a particular set, but all sets with the matching symbol probabilities)\n\tphase\t\t\t\t= p.x;\n\tdecode(phase, probability, set);\n\t\n\tvec3 probability_set \t\t= display_set(p.yx, set);\n\n\tprobability_set \t\t*= error_mask;\n\t\n\t//display the results\n\tvec4 result\t\t\t= vec4(0.);\n\tfloat scaled_uv\t\t\t= uv.x * 64.;\n\tfloat column\t\t\t= floor(scaled_uv);\n\tfloat display_initial_set\t= float(column < 1.);\n\tfloat display_decoded_set\t= float(column > 62.);\n\tfloat display_probability_set\t= float(scaled_uv < 63. - LINE_WIDTH && scaled_uv > 1. + LINE_WIDTH);\n\t\n\tinitial_set\t\t\t*= display_initial_set;\n\tdecoded_set\t\t\t*= display_decoded_set;\n\tprobability_set\t\t\t*= display_probability_set;\n\t\n\tresult.xyz\t\t\t= initial_set + decoded_set + probability_set;\n\tresult.xyz\t\t\t-= phase_line * float(length(probability_set) > 0.);\n\t\n\n\tresult.w \t\t\t= 1.;\n\t\n\tgl_FragColor \t\t\t= result;\n\t\n\t#ifdef DEBUG_SPACE\n\tg_debug.y\t\t\t= fract(p.y*float(ELEMENTS))*float(p.y*float(ELEMENTS)<float(ELEMENTS));\n\tgl_FragColor\t\t\t= vec4(g_debug.xy, 0., 1.);\n\t#endif\n}//sphinx\n\n\nfloat encode(in float probability[SYMBOLS], in float set[ELEMENTS])\n{\n\tfloat period \t= 0.;\n\tfloat phase\t= 0.;\n\n\tfloat interval[SYMBOLS];\n\tfor(int i = 0; i < SYMBOLS; i++)\n\t{\n\t\tinterval[i] = probability[i];\n\t}\n\t\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfor(int j = 0; j < SYMBOLS; j++)\n\t\t{\n\t\t\tif(set[i] == float(j))\n\t\t\t{\n\t\t\t\tperiod = probability[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tphase +=  interval[j];\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < ELEMENTS; j++)\n\t\t{\n\t\t\tinterval[j] *= clamp(period, 0., 1.);\n\t\t}\n\t}\n\t\n\treturn phase;\n}\n\n\nvoid decode(in float phase, in float probability[SYMBOLS], out float set[ELEMENTS])\n{\n\tfloat period \t= 1.;\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfloat theta = phase;\n\n\t\tfor(int j = SYMBOLS-1; j >= 0; j--)\n\t\t{\t\t\t\n\t\t\tbool match\t\t= period > theta;\n\t\t\tset[i]\t\t\t= match ? float(j) \t\t\t\t: set[i];\n\t\t\tphase \t\t\t= match ? abs(theta-period)/probability[j]\t: phase;\t\t\t\t\t\n\t\t\tperiod\t\t\t= period - probability[j];\n\t\t}\n\t\t\n\t\tperiod = phase+phase;\n\t\t\n\t\t#ifdef DEBUG_SPACE\n\t\tif(floor(g_debug.y*float(ELEMENTS))==float(i))\n\t\t{\n\t\t\tg_debug.x = 1.-period/2.;\n\t\t}\n\t\t#endif\n\t}\n}\n\n\nfloat sum(in float probability[SYMBOLS])\n{\n\tfloat sum = 0.;\n\tfor(int i = 0; i < SYMBOLS; i++)\n\t{\n\t\tsum += probability[i];\n\t}\n\t\n\treturn sum;\n}\n\n\nvoid count(inout float series[ELEMENTS], inout float probability[SYMBOLS])\n{\n\tfor(int j = 0; j < SYMBOLS; j++)\n\t{\n\t\tprobability[j] = 0.;\t\n\t}\n\t\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfor(int j = 0; j < SYMBOLS; j++)\n\t\t{\n\t\t\tprobability[j] += float(series[i] == float(j));\n\t\t}\n\t}\n}\n\n\nvoid derive(inout float probability[SYMBOLS])\n{\t\n\tfloat s = 1./sum(probability);\n\tfor(int i = 0; i < SYMBOLS; i++)\n\t{\n\t\tprobability[i] *= s;\n\t}\n}\n\n\nvoid zero(out float set[ELEMENTS])\n{\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tset[i] = 0.;\n\t}\n}\n\n\nvec3 display_set(vec2 uv, in float set[ELEMENTS])\n{\n\tfloat index\t\t= floor(uv.x * float(ELEMENTS));\n\tvec3 visualization\t= vec3(0.);\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tif(float(i) == index)\n\t\t{\n\t\t\tvisualization = symbol_h4x_color(set[i]);\n\t\t}\n\t}\n\t\n\tfloat grid = float(fract(uv.x * float(ELEMENTS)+LINE_WIDTH*.5)>LINE_WIDTH);\n\treturn visualization * grid;\n}\n\n\nfloat verify_set(vec2 uv, in float set[ELEMENTS], in float verification[ELEMENTS])\n{\n\tfloat index\t\t= floor(uv.x * float(ELEMENTS));\n\tfloat error_mask\t= 1.;\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tif(float(i) == index)\n\t\t{\n\t\t\terror_mask *= float(set[i] == verification[i]);\n\t\t}\n\t}\n\n\treturn error_mask;\n}\n\n\nvec3 symbol_color(float i)\n{\n\treturn hsv(i/float(SYMBOLS)*.75, 1., 1.);\t\t\n}\n\nvec3 symbol_h4x_color(float i)\n{\n\treturn vec3(1., 1., 1.) * i/float(SYMBOLS)\t;\n}\n\n\n\nvec3 hsv(float h,float s,float v)\n{\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\n\nfloat hash(vec2 uv)\n{\n\treturn clamp(fract(cos(uv.x+sin(uv.y))*12345.6789), pow(2., -16.), 1.-pow(2., -16.));\n}\n\n\nvoid assign_mouse_symbols(out float set[ELEMENTS])\n{\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfloat symbol \t= floor(hash(mouse+float(i)/float(SYMBOLS))*float(SYMBOLS));\n\t\tset[i] \t= symbol;\n\t}\n}\n\nvoid assign_random_symbols(out float set[ELEMENTS])\n{\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfloat symbol \t= floor(hash(mouse+float(i)/float(ELEMENTS))*float(SYMBOLS));\n\t\tset[i] \t= symbol;\n\t}\n}\n\nvoid assign_gpu_h4x(out float set[ELEMENTS])\n{\n\tfor(int i = 0; i < ELEMENTS; i++)\n\t{\n\t\tfloat symbol \t= 2.; //floating point failure point!\n\t\tset[i] \t= symbol;\n\t}\n}", "user": "9ea3a0e", "parent": "/e#40447.6", "id": 47460}