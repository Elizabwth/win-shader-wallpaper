{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n// coronar star burn / valerysntx\n\n// port from https://www.shadertoy.com/view/lsySzd\n// \"Volumetric explosion\" by Duke\n//-------------------------------------------------------------------------------------\n// Based on \"Supernova remnant\" (https://www.shadertoy.com/view/MdKXzc) \n// and other previous shaders \n// otaviogood's \"Alien Beacon\" (https://www.shadertoy.com/view/ld2SzK)\n// and Shane's \"Cheap Cloud Flythrough\" (https://www.shadertoy.com/view/Xsc3R4) shaders\n// Some ideas came from other shaders from this wonderful site\n// Press 1-2-3 to zoom in and zoom out.\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n// Whoever forced \"BOTH\" to be the default was a complete jackass...way to ruin a beautiful shader...\n//\n// comment this string to see each part in full screen\n#define BOTH\n// uncomment this string to see left part\n#define LEFT\n\n//#define LOW_QUALITY\n\n#define DITHERING\n\n#define TONEMAPPING\n\n//-------------------\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nfloat fbm( vec3 p )\n{\n   return noise(p*.06125)*.5 + noise(p*.125)*.25 + noise(p*.25)*.125 + noise(p*.4)*.2;\n}\n\nfloat rand(vec2 co)\n{\n   return fract(sin(dot(co*0.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Sphere( vec3 p, float r )\n{\n   return length(p)-r;\n}\n\n//==============================================================\n// otaviogood's noise from https://www.shadertoy.com/view/ld2SzK\n//--------------------------------------------------------------\n// This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n// It should work the same on all computers since it's not based on a hash function like some other noises.\n// It can be much faster than other noise functions if you're ok with some repetition.\nconst float nudge = 41.;\t// size of perpendicular vector\nfloat normalizer = 11.0 / length(1.0 + nudge*nudge);\t// pythagorean theorem on that perpendicular to maintain scale\nfloat SpiralNoiseC(vec3 p)\n{\n    float n = mod(time * 31.2, 4.3); // noise amount\n    float iter = 2.0;\n    for (int i = 0; i < 36; i++)\n    {\n        // add sin and cos scaled inverse with the frequency\n        n += -abs(sin(p.y*iter) + cos(p.x*iter)) / iter;\t// abs for a ridged look\n        \n\t  // rotate by adding perpendicular and scaling down\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        // rotate on other axis\n        p.xz += vec2(-p.z, p.x) * nudge;\n        p.xz *= normalizer;\n        // increase the frequency\n        iter *= 1.733733;\n    }\n    return n;\n}\n//&\nfloat VolumetricExplosion(vec3 p)\n{\n    float final = Sphere(p,2.);\n    #ifdef LOW_QUALITY\n    final += noice(p*12.5)*.2;\n    #else\n    final += fbm(p*50.5);\n    #endif\n    final += SpiralNoiseC(p.zxy*0.4132+333.)*0.025;\n\n    return final;\n}\n\nfloat map(vec3 p) \n{\n\tR(p.xz, mouse.x*1.8*pi+time*0.1);\n\n\tfloat VolExplosion = VolumetricExplosion(p/01.)*0.5; // scale\n    \n\treturn VolExplosion;\n}\n//--------------------------------------------------------------\n\n// assign color to the media\nvec3 computeColor( float density, float radius )\n{\n\t// color based on density alone, gives impression of occlusion within\n\t// the media\n\tvec3 result = mix( vec3(0.0,0.0,0.8), vec3(0.0,0.0,02.0), density );\n\t\n\t// color added to the media\n\tvec3 colCenter = 17.*vec3(0.0,0.0,0.0);\n\tvec3 colEdge = 17.5*vec3(010,0.53,0.0);\n\tresult *= mix( colCenter, colEdge, min( (radius+.105)/1.9, 16.15 ) );\n\t\n\treturn result;\n}\n\nbool RaySphereIntersect(vec3 org, vec3 dir, out float near, out float far)\n{\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 12.;\n\tfloat delta = b*b - c;\n\tif( delta < 0.0) \n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n// Applies the filmic curve from John Hable's presentation\n// More details at : http://filmicgames.com/archives/75\nvec3 ToneMapFilmicALU(vec3 _color)\n{\n\t_color = max(vec3(10), _color - vec3(0.004));\n\t_color = (_color * (6.2*_color + vec3(0.5))) / (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nfloat gamma = 1.0;\n\n\n/*\n\nThis shader experiments the effect of different tone mapping operators.\nThis is still a work in progress.\n\nMore info:\nhttp://slideshare.net/ozlael/hable-john-uncharted2-hdr-lighting\nhttp://filmicgames.com/archives/75\nhttp://filmicgames.com/archives/183\nhttp://filmicgames.com/archives/190\nhttp://imdoingitwrong.wordpress.com/2010/08/19/why-reinhard-desaturates-my-blacks-3/\nhttp://mynameismjp.wordpress.com/2010/04/30/a-closer-look-at-tone-mapping/\nhttp://renderwonk.com/publications/s2010-color-course/\n\n--\nZavie\n\n*/\nvec3 simpleReinhardToneMapping(vec3 color)\n{\n\tfloat exposure = 1.5;\n\tcolor *= exposure/(1. + color / exposure);\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 lumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 whitePreservingLumaBasedReinhardToneMapping(vec3 color)\n{\n\tfloat white = 2.;\n\tfloat luma = dot(color, vec3(0.2126, 0.7152, 0.0722));\n\tfloat toneMappedLuma = luma * (1. + luma / (white*white)) / (1. + luma);\n\tcolor *= toneMappedLuma / luma;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 RomBinDaHouseToneMapping(vec3 color)\n{\n    color = exp( -1.0 / ( 2.72*color + 0.15 ) );\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\n\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 2.;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n\tcolor = pow(color, vec3(1. / gamma));\n\treturn color;\n}\n\nvoid main( void )\n{  \n\n    \tvec2 uv = gl_FragCoord.xy/resolution.xy;\n\t// ro: ray origin\n\t// rd: direction of the ray\n\tvec3 rd = normalize(vec3((gl_FragCoord.xy-0.5*resolution.xy)/resolution.y, 1.0));\n\tvec3 ro = vec3(0., 0., -6.);\n    \t\n\t#ifdef DITHERING\n\tvec2 seed = uv + fract(time);\n\t#endif \n\t\n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    \tconst float h = 0.1;\n   \n\tvec4 sum = vec4(0.0);\n   \n    \tfloat min_dist=0.0, max_dist=0.0;\n\n   \tif(RaySphereIntersect(ro, rd, min_dist, max_dist))\n    \t{\n       \n\tt = min_dist*step(t,min_dist);\n   \n\t// raymarch loop\n    \t#ifdef LOW_QUALITY\n\tfor (int i=0; i<6; i++)\n    \t#else\n    \tfor (int i=0; i<86; i++)\n    \t#endif\n\t{\n\t \n\t    vec3 pos = ro + t*rd;\n  \n\t    // Loop break conditions.\n\t    if(td>0.9 || d<0.12*t || t>10. || sum.a > 0.99 || t>max_dist) break;\n        \n\t    // evaluate distance function\n\t    float d = map(pos);\n        \n\t    #ifdef BOTH\n\t    if (uv.x<1.0)\n\t    {\n            \td = abs(d)+0.07;\n\t    }\n\t    #else\n\t    #ifdef LEFT\n\t    d = abs(d)+0.07;\n\t    #endif\n\t    #endif\n        \n\t    // change this string to control density \n\t    d = max(d,0.03);\n        \n\t    // point light calculations\n\t    vec3 ldst = vec3(0.0)-pos;\n\t    float lDist = max(length(ldst), 0.001);\n\t    \n\t    // the color of light \n\t    vec3 lightColor=vec3(1.0,0.5,0.25);\n        \n\t    sum.rgb+=(lightColor/exp(lDist*lDist*lDist*.08)/30.); // bloom\n        \n\t    if (d<h) \n\t    {\n\t    // compute local density \n\t    ld = h - d;\n            \n\t    // compute weighting factor \n\t    w = (1. - td) * ld;\n     \n\t    // accumulate density\n\t    td += w + 1./200.;\n\t\t\n\t    vec4 col = vec4( computeColor(td,lDist), td );\n            \n            // emission\n            sum += sum.a * vec4(sum.rgb, 0.0) * 0.2 / lDist;\t\n            \n\t    // uniform scale density\n\t    col.a *= 0.2;\n\t    // colour by alpha\n\t    col.rgb *= col.a;\n\t    // alpha blend in contribution\n\t    sum = sum + col*(1.0 - sum.a);  \n       \n\t    }\n      \n\t    td += 1./70.;\n\t\t\n\t    #ifdef DITHERING\n\t    d=abs(d)*(.8+0.2*rand(seed*vec2(i)));\n\t    #endif \n\t\t\n\t    // trying to optimize step size\n\t    #ifdef LOW_QUALITY\n\t    t += max(d*0.25,0.01);\n\t    #else\n\t    t += max(d * 0.08 * max(min(length(ldst),d),2.0), 0.01);\n\t    #endif\n                \n\t}\n    \n\t// simple scattering\n\t#ifdef LOW_QUALITY    \n\tsum *= 1. / exp( ld * 0.2 ) * 0.9;\n\t#else\n\tsum *= 1. / exp( ld * 0.2 ) * 0.8;\n\t#endif\n        \n   \tsum = clamp( sum, 0.0, 1.0 );\n   \n\tsum.xyz = sum.xyz*sum.xyz*(3.0-2.0*sum.xyz);\n    \n\t}\n   \n\t#ifdef TONEMAPPING\n\t/* \n\t\t\n\t\tMore realistic tonemapping / https://www.shadertoy.com/view/lslGzl\n\t\tvalerysntx\n\n\t*/\n\t// gl_FragColor = vec4(ToneMapFilmicALU(sum.xyz * gamma),1.0);\t\n\t// gl_FragColor = vec4(filmicToneMapping(sum.xyz),1.0);\n\tgl_FragColor = vec4(whitePreservingLumaBasedReinhardToneMapping(sum.xyz), 1);\n\t// gl_FragColor = vec4(Uncharted2ToneMapping(sum.xyz),1);\t\n\n\n\t#else\n\tgl_FragColor = vec4(sum.xyz,1.0);\n\t#endif\n\t//gl_FragColor = vec4(filmicToneMapping(sum.xyz),1.0);\n}", "user": "c382659", "parent": "/e#45347.0", "id": 47167}