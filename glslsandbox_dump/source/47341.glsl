{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nvec3 ray_march(in vec3 ro, in vec3 rd, vec3 mouse1, vec3 disk)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 32;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Calculate our current position along the ray\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        // We wrote this function earlier in the tutorial -\n        // assume that the sphere is centered at the origin\n        // and has unit radius\n        float distance_to_closest = distance_from_sphere(current_position, disk, 1.0);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) // hit\n        {\n            // We hit something! Return red for now\n\t    float _f = (dot((current_position-disk), (current_position-disk) + mouse1-disk))*0.5;\n            return vec3(_f*0.6, _f*0.6, _f*0.25);\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE) // miss\n        {\n            break;\n        }\n\n        // accumulate the distance traveled thus far\n        total_distance_traveled += distance_to_closest;\n    }\n\treturn vec3(0.0);\n}\n//X\nmat3 rotCam(float angle) {\n\treturn mat3(1.0, 0.0, 0.0,\n\t\t    0.0, cos(angle), -sin(angle),\n\t\t    0.0, sin(angle), cos(angle));\n}\n//Y \nmat3 rotCamY(float angle) {\n\treturn mat3(cos(angle), 0.0, sin(angle),\n\t\t    0.0, 1., 0.0,\n\t\t    -sin(angle), 0.0, cos(angle));\n}\nvoid main() {\n\n\tvec2 uv = ( gl_FragCoord.xy / resolution.xy ) *2.0 -1.0;\n\tuv.x *= resolution.x/resolution.y;\n\tvec2 mouse1 = mouse *2.0 -1.0;\n\n\t\n\tvec3 sun = vec3 (-0, 3., 3.);\n\tvec3 camera_position = vec3(0,  0.0, -8.);\n\t//vec3 camera_position = vec3(3.*sin(1.+time),  0.0, -7. + 3. * cos(1.+time));\n\n\t\n\t//camera_position += vec3(0.0, 0.0, 2.0); \n\t//camera_position *= rotCam(1.+time);\n\t//camera_position -= vec3(0.0, 0.0, 2.0); \n\t\n\t//camera_position -= vec3(0.0, 0.0, fract(time));\n    \tvec3 ro = camera_position;\n    \tvec3 rd = vec3(uv, 1.);\n\n\tsun *= rotCamY(1.+time);\n\t\n\tvec3 shaded_color = vec3(0.0);\n    \tshaded_color = ray_march(ro, rd, sun, vec3(0.0));\n\tshaded_color += ray_march(ro, rd, sun, vec3 (3.0, 0.0, -.0));\n\tshaded_color += ray_march(ro, rd, sun, sun);\t\n\n\tgl_FragColor = vec4(shaded_color, 1.0);\n\n}", "user": "d0627d0", "parent": null, "id": 47341}