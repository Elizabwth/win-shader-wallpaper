{"code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\nconst float PI  = 3.141592653589793;\nconst float PI2 = PI * 2.;\n\n#define s(x) clamp(x,0.,1.)\n#define _G sG()\n#define _L sL()\n#define _S sS()\n#define _C sC()\n#define _H sH()\n#define _O sO()\n#define _D sD()\n#define _U sU()\n#define _T sT()\n#define _2 s2()\n#define _1 s1()\n#define _8 s8()\n\nvec2 pos;\n\nfloat slice(float x,float start,float end){\n     return step(start,x)*step(x,end)*x;\n}\n\nfloat tslice(float x,float start,float end){\n     return 1.-step(step(start,x)*step(x,end)*x,0.);\n}\n\nfloat sqr(float x){\n   return -2.*(step(.5,fract(x*.5))-.5);\n}\n\nmat2 rotate2d(float a){\n\tfloat c=cos(a);\n\tfloat s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat fill(float d,float r){return step(0.,r - d);}\nfloat lBox(vec2 p){return max(abs(p.x),abs(p.y));}\nfloat sBox(vec2 p,float r){return fill(lBox(p),r);}\nfloat lRect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\nfloat sRect(vec2 p,vec2 size){return fill(lRect(p,size),0.);}\nvoid i(){pos.x-=2.;}\nvoid cr(float x){pos.x=x+2.;pos.y+=2.;}\nfloat sG(vec2 p){\n\treturn s(s(sBox(p,.6)-sBox(p,.4))\n\t+sRect(p-vec2(.2,0)  ,vec2(.2,.1))\n\t-sRect(p-vec2(.5,.25),vec2(.1,.15)));}\nfloat sL(vec2 p){return s(sBox(p,.6)-sBox(p-.2,.6));}\nfloat sS(vec2 p){\n\treturn s(sBox(p,.6)\n\t-sRect(p-vec2( .1, .25),vec2(.5,.15))\n\t-sRect(p-vec2(-.1,-.25),vec2(.5,.15)));\n}\nfloat sC(vec2 p){\n\treturn s(sBox(p,.6)\n\t-sRect(p-vec2(.1,0.),vec2(.5,.4)));\n}\nfloat sO(vec2 p){return s(sBox(p,.6)-sBox(p,.4));}\nfloat sH(vec2 p){\n\treturn s(sBox(p,.6)\n        -sRect(p+vec2(0.,-.35),vec2(.4,.25))\n\t-sRect(p+vec2(0.,+.35),vec2(.4,.25)));\n}\nfloat sD(vec2 p){return s(sBox(p,.6)-sBox(p,.4));}\nfloat sU(vec2 p){\n\treturn s(sBox(p,.6)\n     -sRect(p+vec2(0.,-.35),vec2(.4,.75)));\n}\nfloat sT(vec2 p){\n\treturn s(sBox(p,.6)\n        -sRect(p+vec2(-.5,+.15),vec2(.4,.5))\n\t-sRect(p+vec2(0.5,+.15),vec2(.4,.5)));\n}\nfloat s1(vec2 p){return sRect(p-vec2(0,0),vec2(.1,.6));}\nfloat s2(vec2 p){return sS(vec2(-p.x,p.y));}\nfloat s8(vec2 p){\n\treturn s(sBox(p,.6)\n\t-sRect(p-vec2( .0, .25),vec2(.4,.15))\n\t-sRect(p-vec2(-.0,-.25),vec2(.4,.15)));\n}\n\nfloat sG(){i();return sG(pos);}\nfloat sD(){i();return sD(pos);}\nfloat sU(){i();return sU(pos);}\nfloat sT(){i();return sT(pos);}\nfloat sL(){i();return sL(pos);}\nfloat sS(){i();return sS(pos);}\nfloat sC(){i();return sC(pos);}\nfloat sO(){i();return sO(pos);}\nfloat sH(){i();return sH(pos);}\nfloat s2(){i();return s2(pos);}\nfloat s1(){i();return s1(pos);}\nfloat s8(){i();return s8(pos);}\n\nfloat layerGDUTSCHOOL2018(vec2 p){\n   p.x+=1.;\n   p.y-=.4;\n   p*=6.;\n   p.x-=1.;\n   pos=p;\n   pos.x+=2.;\n   float l;\n   l+=_G+_D+_U+_T;cr(p.x);\n   l+=_S+_C+_H+_O+_O+_L;cr(p.x);\n   l+=_2+_O+_1+_8;cr(p.x);\n   return s(l);\n}\n\nvec2 transitionZoomIn(  vec2 p,float t){ return p*clamp(t,0.,1.);}\nvec2 transitionZoomOut( vec2 p,float t){ return p*clamp(1.-t,0.,1.);}\nvec2 effectPixelate(    vec2 p,float t){ return floor(p*pow(2.,t*5.))/pow(2.,t*5.);}\nvec2 effectRotateGlicth(vec2 p,float t){\n   p*=rotate2d(t*5.);\n   p.y+=sqr(p.x*10.)*sin(t)*.01;\n   p*=rotate2d(-t*5.);\n   return p;\n}\n\nvec2 effectProlongPolar(vec2 p,float t){\n   float a = mod((atan(p.y,p.x) + PI2 + clamp(t*PI*.5,0.,PI2)),PI2);\n   float r = length(p);\n   r=min(r,t/5.);\n   return vec2(r*cos(a),r*sin(a));\n}\t\n\nvec2 effectProlongX(vec2 p,float t){\n   p.x=sign(p.x)*min(abs(p.x),t/5.);\n   return p;\n}\t\n\nfloat maskRadar(vec2 p,float t){\n   float a = mod((atan(p.y,p.x) + PI2 - t),PI2);\n   return 1.-a/PI2;\n}\t\n\nvec3 layerFakeChromaticAberration(vec2 p,float t){\n   float l=layerGDUTSCHOOL2018(p);\n   float purple=layerGDUTSCHOOL2018(p+vec2(.005+.005*sin(p.y*30.+t*10.),0.));\n   float green =layerGDUTSCHOOL2018(p-vec2(.005+.005*cos(p.y*30.+t*10.),0.));\n   return vec3(.8,.5,1.)*purple+vec3(.5,1.,.5)*green+vec3(l);\t\n}\n\nvec3 scene1(vec2 p,float t){\n   p=transitionZoomIn(p,t);\n   return layerFakeChromaticAberration(p,t);\n}\t\n\nvec3 scene2(vec2 p,float t){\n   vec2 o = transitionZoomOut(p,t);\n   return layerFakeChromaticAberration(o,t)*(1.-t)+layerFakeChromaticAberration(p,t);\n}\t\n\nvec3 scene3(vec2 p,float t){\n   p=effectRotateGlicth(p,t);\n   return layerFakeChromaticAberration(p,t);\n}\t\n\nvec3 scene4(vec2 p,float t){\n   p=effectPixelate(p,fract(t));\n   return layerFakeChromaticAberration(p,t);\n}\t\n\nvec3 scene5(vec2 p,float t){\n   p=effectRotateGlicth(p,t);\n   p=effectProlongX(p,t);\n   p=effectProlongPolar(p,t);\n   return layerFakeChromaticAberration(p,t);\n}\t\n\nvec3 scene6(vec2 p,float t){\n   return layerFakeChromaticAberration(p,t)*maskRadar(p,t);\n}\t\n\nvoid main(void){\n   vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n   vec3 color = vec3(0.,0.,0.);\n\t\n   float t = mod(time,16.);\n   float tc = 0.;\n   float ti;\n   ti=1.;color+= tslice(t,tc,tc+ti) * scene1(p,t-tc);tc+=ti;\n   ti=1.;color+= tslice(t,tc,tc+ti) * scene2(p,t-tc);tc+=ti;\n   ti=1.;color+= tslice(t,tc,tc+ti) * scene3(p,t-tc);tc+=ti;\n   ti=1.;color+= tslice(t,tc,tc+ti) * scene4(p,t-tc);tc+=ti;\n   ti=6.;color+= tslice(t,tc,tc+ti) * scene5(p,t-tc);tc+=ti;\n   ti=6.;color+= tslice(t,tc,tc+ti) * scene6(p,t-tc);tc+=ti;\n\t\n   gl_FragColor = vec4(color, 1.0);\n}\n", "user": "8f825bc", "parent": null, "id": 47142}